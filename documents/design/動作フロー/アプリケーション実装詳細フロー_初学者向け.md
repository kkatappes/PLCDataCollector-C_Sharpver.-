# PLCデータ取得アプリケーション - 詳細動作フロー分析レポート（初学者向け解説版）

**作成日**: 2025-12-01
**対象**: andon/Core 実装コード
**目的**: Step間の繋がり・オブジェクトフロー・コード各行の詳細解説

---

## このドキュメントについて

このドキュメントは、C#初学者でも理解できるように、各コードの行単位での詳細な解説を含めています。
以下の記号を使用しています：

- `//` : その行の説明コメント
- `★` : 特に重要なポイント
- `✅` : 正常な動作
- `⚠️` : 注意が必要な点
- `❌` : エラーケース

---

## 目次

1. [アプリケーション起動フロー](#1-アプリケーション起動フロー)
2. [Step1: 初期化フェーズ](#2-step1-初期化フェーズ1回のみ実行)
3. [Step2: フレーム構築](#3-step2-フレーム構築)
4. [Step3: PLC接続](#4-step3-plc接続)
5. [Step4: データ送受信](#5-step4-データ送受信)
6. [Step6: データ解析](#6-step6-データ解析)
7. [Step7: JSON出力](#7-step7-json出力)
8. [エラーハンドリング](#8-エラーハンドリング)

---

## 1. アプリケーション起動フロー

### Program.cs - アプリケーションのエントリーポイント

```csharp
// ファイル: andon/Program.cs
using Microsoft.Extensions.DependencyInjection;  // DIコンテナ機能を使うための宣言
using Microsoft.Extensions.Hosting;              // ホスト（アプリ実行環境）を使うための宣言
using Andon.Services;                            // 自作のサービスクラスを使うための宣言

namespace Andon;  // このファイルが所属する名前空間（フォルダのようなもの）

public class Program  // Programクラスの定義開始
{
    // Main: アプリケーションが起動したとき最初に実行されるメソッド
    // static: インスタンスを作らなくても呼び出せるメソッド
    // async: 非同期処理（待機が必要な処理）を使うことを宣言
    // Task<int>: 非同期で整数を返すことを表す型
    public static async Task<int> Main(string[] args)
    {
        try  // エラーが起きるかもしれない処理を囲む
        {
            // ホスト（アプリの実行環境）を作成
            var host = CreateHostBuilder(args).Build();
            // ★CreateHostBuilder: DIコンテナの設定を行うメソッド
            // ★Build(): 設定を元に実際のホストインスタンスを作成

            // ホストを非同期で起動（待機）
            await host.RunAsync();
            // ★await: この処理が終わるまで待つ（でも他の処理をブロックしない）

            return 0;  // 正常終了（終了コード0）を返す
        }
        catch (Exception ex)  // エラーが起きた場合の処理
        {
            // エラーメッセージをコンソールに表示
            Console.WriteLine($"Application failed: {ex.Message}");
            // ★$"...": 文字列補間（変数の値を埋め込める）
            // ★{ex.Message}: 例外オブジェクトのメッセージプロパティ

            return 1;  // エラー終了（終了コード1）を返す
        }
    }

    // CreateHostBuilder: ホストの設定を行うメソッド
    // IHostBuilder: ホストビルダーのインターフェース型
    public static IHostBuilder CreateHostBuilder(string[] args) =>
        // ★=>: ラムダ式（短い書き方）、メソッドの中身を1行で表現

        Host.CreateDefaultBuilder(args)  // デフォルト設定のホストビルダーを作成
        // ★CreateDefaultBuilder: ログ設定などの標準機能を自動で設定

            .ConfigureServices((hostContext, services) =>
            // ★ConfigureServices: DIコンテナにサービスを登録する設定
            // ★hostContext: ホストの設定情報（設定ファイルの内容など）
            // ★services: DIコンテナ（依存性注入のためのサービス登録先）
            {
                // 自作のDI設定メソッドを呼び出し
                DependencyInjectionConfigurator.Configure(services);
                // ★Configure: 各クラスをDIコンテナに登録

                // バックグラウンドサービスとしてAndonHostedServiceを登録
                services.AddHostedService<AndonHostedService>();
                // ★AddHostedService: アプリ起動時に自動実行されるサービス
                // ★<AndonHostedService>: ジェネリック型パラメータ（型を指定）
            });
}
```

### DependencyInjectionConfigurator.cs - DIコンテナ設定

```csharp
// ファイル: andon/Services/DependencyInjectionConfigurator.cs
using Microsoft.Extensions.DependencyInjection;  // DIコンテナ機能
using Microsoft.Extensions.Logging;              // ログ機能
using Andon.Core.Interfaces;                     // インターフェース定義
using Andon.Core.Controllers;                    // コントローラークラス
using Andon.Core.Managers;                       // マネージャークラス
using Andon.Core.Models.ConfigModels;            // 設定モデル

namespace Andon.Services;

public static class DependencyInjectionConfigurator
// ★static class: インスタンス化できないクラス（ユーティリティクラス）
{
    // Configure: DIコンテナにサービスを登録するメソッド
    // IServiceCollection: サービスを登録するためのコレクション
    public static void Configure(IServiceCollection services)
    {
        // ===== ログ設定 =====
        services.AddLogging(builder =>
        // ★AddLogging: ログ機能を追加
        // ★builder: ログの設定を行うビルダー
        {
            builder.AddConsole();  // コンソールにログを出力
            builder.SetMinimumLevel(LogLevel.Information);
            // ★SetMinimumLevel: 出力する最低ログレベル
            // ★LogLevel.Information: 情報レベル以上のログを出力
        });

        // ===== Options設定（デフォルト値）=====
        services.Configure<DataProcessingConfig>(options =>
        // ★Configure<T>: オプションパターンの設定
        // ★DataProcessingConfig: データ処理の設定クラス
        {
            options.MonitoringIntervalMs = 5000;  // デフォルト5秒
            // ★MonitoringIntervalMs: データ収集の周期（ミリ秒）
        });

        // ===== Singleton登録 - アプリ全体で1つのインスタンスを共有 =====
        services.AddSingleton<IApplicationController, ApplicationController>();
        // ★AddSingleton: シングルトン（1つだけのインスタンス）として登録
        // ★IApplicationController: インターフェース（抽象的な型）
        // ★ApplicationController: 実装クラス（実際の型）

        services.AddSingleton<ILoggingManager, LoggingManager>();
        // ★アプリ全体でログマネージャーを共有

        services.AddSingleton<ErrorHandler>();  // インターフェースなし
        // ★<ErrorHandler>: インターフェースがない場合は型だけ指定

        services.AddSingleton<ResourceManager>();  // インターフェースなし

        // ===== Transient登録 - 要求ごとに新しいインスタンスを生成 =====
        services.AddTransient<IExecutionOrchestrator, ExecutionOrchestrator>();
        // ★AddTransient: 毎回新しいインスタンスを作成
        // ★実行制御は毎回新しく作る（状態を持たない）

        services.AddTransient<ConfigToFrameManager>();  // インターフェースなし
        // ★フレーム構築も毎回新しく作る

        services.AddTransient<IDataOutputManager, DataOutputManager>();
        services.AddTransient<ITimerService, TimerService>();

        // ===== MultiConfig関連 - Transient登録 =====
        services.AddTransient<MultiPlcConfigManager>();
        services.AddTransient<MultiPlcCoordinator>();
    }
}
```

---

## 2. Step1: 初期化フェーズ（1回のみ実行）

### ApplicationController.cs - Step1実装

```csharp
// ファイル: andon/Core/Controllers/ApplicationController.cs
// ExecuteStep1InitializationAsync: Step1初期化メソッド
public async Task<InitializationResult> ExecuteStep1InitializationAsync(
    string configDirectory = "./config/",  // 設定ファイルのディレクトリパス（デフォルト値）
    CancellationToken cancellationToken = default)  // キャンセル通知用トークン
    // ★async Task<InitializationResult>: 非同期でInitializationResultを返す
    // ★CancellationToken: 処理を途中でキャンセルするための仕組み
    // ★= default: デフォルト値（省略可能パラメータ）
{
    try  // エラーハンドリング開始
    {
        // ----- ログ出力: 開始 -----
        await _loggingManager.LogInfo("Starting Step1 initialization");
        // ★await: LogInfoメソッドの完了を待つ
        // ★_loggingManager: クラスのフィールド（メンバ変数）
        // ★LogInfo: 情報レベルのログを出力するメソッド

        // ----- 設定ファイルから複数PLC設定を読み込み -----
        var configs = _configManager.GetAllConfigurations();
        // ★var: 型推論（コンパイラが自動で型を判断）
        // ★configs: 読み込んだ設定のリスト（List<PlcConfiguration>型）
        // ★GetAllConfigurations(): Excelファイルから設定を読み込むメソッド

        _plcConfigs = configs.ToList();  // Listに変換して保存
        // ★_plcConfigs: クラスのフィールド（継続実行で再利用）
        // ★ToList(): IEnumerableをListに変換

        _plcManagers = new List<IPlcCommunicationManager>();
        // ★new List<...>(): 新しいリストインスタンスを作成
        // ★IPlcCommunicationManager: 通信マネージャーのインターフェース

        // ----- 設定ごとにPlcCommunicationManagerを作成 -----
        foreach (var config in configs)  // 各設定に対してループ
        // ★foreach: コレクションの各要素に対して繰り返し処理
        // ★var config: 現在処理中の設定オブジェクト
        {
            // === ConnectionConfig作成 ===
            var connectionConfig = new ConnectionConfig
            // ★new: 新しいインスタンスを作成
            // ★ConnectionConfig: 接続設定を保持するクラス
            {
                // オブジェクト初期化子（プロパティを一括設定）
                IpAddress = config.IpAddress,
                // ★IpAddress: IPアドレス（例: "192.168.1.100"）

                Port = config.Port,
                // ★Port: ポート番号（例: 5000）

                UseTcp = config.ConnectionMethod == "TCP"
                // ★UseTcp: TCP接続かどうか（true/false）
                // ★==: 等価比較演算子（同じかどうか判定）
                // ★"TCP"と一致すればtrue、それ以外（"UDP"）はfalse
            };

            // === TimeoutConfig作成 ===
            var timeoutConfig = new TimeoutConfig
            {
                ConnectTimeoutMs = config.Timeout,
                // ★ConnectTimeoutMs: 接続タイムアウト（ミリ秒）

                SendTimeoutMs = config.Timeout,
                // ★SendTimeoutMs: 送信タイムアウト（ミリ秒）

                ReceiveTimeoutMs = config.Timeout
                // ★ReceiveTimeoutMs: 受信タイムアウト（ミリ秒）
            };

            // === PlcCommunicationManager作成 ===
            var manager = new PlcCommunicationManager(
                connectionConfig,  // 第1引数: 接続設定
                timeoutConfig);    // 第2引数: タイムアウト設定
            // ★PlcCommunicationManager: PLC通信を管理するクラス
            // ★コンストラクタ: クラスのインスタンスを作成するメソッド
            // ★省略されたパラメータ（socketFactory）はnull（本番環境）

            // === リストに追加 ===
            _plcManagers.Add(manager);
            // ★Add: リストの末尾に要素を追加
            // ★_plcManagers: 作成したマネージャーを保存するリスト
        }  // foreach終了

        // ----- ログ出力: 完了 -----
        await _loggingManager.LogInfo("Step1 initialization completed");

        // ----- 成功結果を返す -----
        return new InitializationResult
        // ★return: メソッドの戻り値を返す
        {
            Success = true,           // 成功フラグ
            PlcCount = configs.Count  // 読み込んだPLC数
            // ★Count: コレクションの要素数を取得するプロパティ
        };
    }
    catch (Exception ex)  // エラーが発生した場合
    // ★Exception: すべての例外の基底クラス
    // ★ex: 例外オブジェクト（エラーの詳細情報を持つ）
    {
        // ----- エラーログ出力 -----
        await _loggingManager.LogError(ex, "Step1 initialization failed");
        // ★LogError: エラーレベルのログ出力
        // ★ex: 例外オブジェクトを渡す

        // ----- 失敗結果を返す -----
        return new InitializationResult
        {
            Success = false,              // 失敗フラグ
            ErrorMessage = ex.Message     // エラーメッセージ
            // ★ex.Message: 例外のメッセージプロパティ
        };
    }
}
```

---

## 3. Step2: フレーム構築

### SlmpFrameBuilder.cs - ReadRandomフレーム構築

```csharp
// ファイル: andon/Utilities/SlmpFrameBuilder.cs
// BuildReadRandomRequest: ReadRandomコマンドのフレームを構築
public static byte[] BuildReadRandomRequest(
    List<DeviceSpecification>? devices,  // デバイスリスト（nullかもしれない）
    // ★?: null許容型（nullを許容する参照型）
    // ★DeviceSpecification: デバイス指定情報を持つクラス

    string frameType = "3E",             // フレームタイプ（デフォルト"3E"）
    ushort timeout = 32)                 // タイムアウト値（デフォルト32）
    // ★ushort: 符号なし16ビット整数（0～65535）
{
    // ----- 1. 入力検証 -----
    ValidateInputs(devices, frameType);
    // ★ValidateInputs: 入力値が正しいかチェックするメソッド
    // ★不正な値の場合は例外をスロー

    // ----- 2. フレーム構築開始 -----
    var frame = new List<byte>();
    // ★List<byte>: バイト配列のリスト（可変長）
    // ★byte: 8ビット整数（0～255）、SLMPフレームは1バイト単位

    // ----- 3. サブヘッダ構築 -----
    ushort sequenceNumber = _sequenceManager.GetNext(frameType);
    // ★sequenceNumber: シーケンス番号（4Eフレームで使用）
    // ★_sequenceManager: シーケンス番号を管理するクラス

    frame.AddRange(BuildSubHeader(frameType, sequenceNumber));
    // ★AddRange: 複数の要素を一度に追加
    // ★BuildSubHeader: サブヘッダバイト列を作成
    // ★3Eフレーム: [0x50, 0x00]
    // ★4Eフレーム: [0x54, 0x00, seq_low, seq_high, 0x00, 0x00]

    // ----- 4. ネットワーク設定構築 -----
    frame.AddRange(BuildNetworkConfig());
    // ★BuildNetworkConfig: ネットワーク設定バイト列を作成
    // ★[0x00, 0xFF, 0xFF, 0x03, 0x00]
    //   ネットワーク番号, PC番号, I/O番号(LE), 局番

    // ----- 5. データ長プレースホルダ -----
    int dataLengthPosition = frame.Count;
    // ★dataLengthPosition: データ長を書き込む位置を記録
    // ★frame.Count: 現在のフレーム長（要素数）

    frame.AddRange(new byte[] { 0x00, 0x00 });
    // ★new byte[]: 新しいバイト配列を作成
    // ★{ 0x00, 0x00 }: 配列初期化子（初期値を指定）
    // ★後でここにデータ長を書き込む

    // ----- 6. コマンド部構築 -----
    frame.AddRange(BuildCommandSection(
        timeout,                    // 監視タイマ
        0x0403,                    // ReadRandomコマンド
        // ★0x0403: 16進数リテラル（10進数で1027）

        0x0000,                    // サブコマンド（固定）
        (byte)devices!.Count,      // ワード点数
        // ★(byte): キャスト（型変換）
        // ★devices!: null非許容演算子（nullでないことを保証）
        // ★.Count: デバイスの個数

        0x00));                    // Dword点数=0固定

    // ----- 7. デバイス指定部構築 -----
    frame.AddRange(BuildDeviceSpecificationSection(devices));
    // ★foreach device in devices
    //   device.ToDeviceSpecificationBytes() を呼び出し
    //   [デバイス番号3バイト(LE), デバイスコード1バイト] を追加

    // ----- 8. データ長更新 -----
    UpdateDataLength(frame, dataLengthPosition, frameType);
    // ★dataLength = frame.Count - dataLengthPosition - 2
    // ★frame[dataLengthPosition] = dataLength の下位バイト
    // ★frame[dataLengthPosition + 1] = dataLength の上位バイト

    // ----- 9. フレーム検証 -----
    ValidateFrame(frame.ToArray());
    // ★ToArray(): ListをArray（配列）に変換
    // ★ValidateFrame: フレームが正しい形式か検証

    // ----- 10. 返却 -----
    return frame.ToArray();
    // ★byte[]: バイト配列として返す
}
```

### DeviceSpecification.cs - デバイス指定バイト列作成

```csharp
// ファイル: andon/Core/Models/DeviceSpecification.cs
// ToDeviceSpecificationBytes: デバイス指定を4バイト配列に変換
public byte[] ToDeviceSpecificationBytes()
{
    // ----- 結果格納用の配列を作成 -----
    var result = new byte[4];
    // ★byte[4]: 4要素のバイト配列
    // ★SLMP仕様: [デバイス番号3バイト(LE), デバイスコード1バイト]

    // ----- デバイス番号を3バイトに変換 -----
    var deviceNumberBytes = ToDeviceNumberBytes();
    // ★ToDeviceNumberBytes(): デバイス番号を3バイトに変換するメソッド
    // ★リトルエンディアン形式（下位バイトから順に）

    // ----- デバイス番号（3バイト）をコピー -----
    Array.Copy(deviceNumberBytes, 0, result, 0, 3);
    // ★Array.Copy: 配列のコピー
    // ★第1引数: コピー元配列
    // ★第2引数: コピー元の開始インデックス（0から）
    // ★第3引数: コピー先配列
    // ★第4引数: コピー先の開始インデックス（0から）
    // ★第5引数: コピーするバイト数（3バイト）

    // ----- デバイスコード（1バイト）を設定 -----
    result[3] = (byte)Code;
    // ★result[3]: 配列の4番目の要素（インデックスは0から始まる）
    // ★(byte)Code: DeviceCode列挙型をbyteにキャスト
    // ★例: DeviceCode.D (0xA8) → 0xA8

    // ----- 完成したバイト配列を返す -----
    return result;
    // ★例: D100の場合
    //   [0x64, 0x00, 0x00, 0xA8]
    //    ^^^^^^^^^^^^^^^^^^^^  ^^^^
    //    デバイス番号(LE)      コード
}

// ToDeviceNumberBytes: デバイス番号を3バイト配列に変換（LE）
public byte[] ToDeviceNumberBytes()
{
    return new byte[]
    {
        (byte)(DeviceNumber & 0xFF),           // 下位バイト
        // ★DeviceNumber: デバイス番号（int型、例: 100）
        // ★& 0xFF: ビットAND演算（下位8ビットだけを取り出す）
        // ★(byte): 結果をbyteにキャスト

        (byte)((DeviceNumber >> 8) & 0xFF),    // 中位バイト
        // ★>> 8: 右シフト演算（8ビット右にシフト）
        // ★例: 0x1234 >> 8 = 0x0012
        // ★& 0xFF: 下位8ビットだけを取り出す

        (byte)((DeviceNumber >> 16) & 0xFF)    // 上位バイト
        // ★>> 16: 16ビット右にシフト
    };
    // ★例: DeviceNumber = 100 (0x000064)
    //   下位: 0x64, 中位: 0x00, 上位: 0x00
    //   → [0x64, 0x00, 0x00]
}
```

---

## 4. Step3: PLC接続

### PlcCommunicationManager.cs - ConnectAsync実装

```csharp
// ファイル: andon/Core/Managers/PlcCommunicationManager.cs
// ConnectAsync: PLCに接続するメソッド
public async Task<ConnectionResponse> ConnectAsync()
{
    // ----- 接続開始時刻を記録 -----
    var startTime = DateTime.UtcNow;
    // ★DateTime.UtcNow: 現在のUTC時刻を取得
    // ★UTC: 協定世界時（タイムゾーン非依存）

    try
    {
        // ----- 1. IP検証 -----
        if (!System.Net.IPAddress.TryParse(_connectionConfig.IpAddress, out _))
        // ★TryParse: 文字列がIPアドレスとして有効か検証
        // ★out _: 出力パラメータ（結果は使わないので_で破棄）
        // ★!: 論理否定演算子（falseの場合にtrue）
        {
            // === IP不正の場合 ===
            _stats.AddConnection(false);
            // ★_stats: 統計情報を管理するオブジェクト
            // ★AddConnection(false): 失敗した接続を記録

            _stats.AddConnectionError(ErrorConstants.ValidationError);
            // ★AddConnectionError: エラー種別を記録

            throw new PlcConnectionException(
                $"不正なIPアドレス: {_connectionConfig.IpAddress}",
                new ArgumentException($"Invalid IP address: {_connectionConfig.IpAddress}"));
            // ★throw: 例外をスロー（エラーを発生させる）
            // ★PlcConnectionException: カスタム例外クラス
            // ★new ArgumentException: 内部例外を作成
        }

        // ----- 2. 既存接続チェック -----
        if (_connectionResponse?.Status == ConnectionStatus.Connected)
        // ★?: null条件演算子（nullの場合は評価しない）
        // ★== ConnectionStatus.Connected: 既に接続済みかチェック
        {
            throw new InvalidOperationException(Constants.ErrorMessages.AlreadyConnected);
            // ★InvalidOperationException: 不正な操作の例外
        }

        // ----- 3. Socket作成 -----
        Socket socket;
        // ★Socket: ネットワーク通信用のクラス

        if (_socketFactory != null)  // ★テスト環境の場合
        {
            // === テスト用のSocketを作成 ===
            socket = _socketFactory.CreateSocket(_connectionConfig.UseTcp);
            // ★_socketFactory: テスト用のSocket作成インターフェース
            // ★本番環境では常にnull
        }
        else  // ★本番環境の場合（常にこちら）
        {
            // === 実際のSocketを作成 ===
            if (_connectionConfig.UseTcp)  // TCP接続の場合
            {
                socket = new Socket(
                    AddressFamily.InterNetwork,  // IPv4を使用
                    // ★AddressFamily: アドレスファミリ（プロトコル系統）

                    SocketType.Stream,           // ストリーム型（TCP）
                    // ★Stream: データをストリーム（連続データ）として扱う

                    ProtocolType.Tcp);           // TCPプロトコル
                // ★Tcp: Transmission Control Protocol（信頼性の高い通信）
            }
            else  // UDP接続の場合
            {
                socket = new Socket(
                    AddressFamily.InterNetwork,  // IPv4を使用
                    SocketType.Dgram,            // データグラム型（UDP）
                    // ★Dgram: データをパケット単位で扱う

                    ProtocolType.Udp);           // UDPプロトコル
                // ★Udp: User Datagram Protocol（高速だが信頼性は低い）
            }
        }

        // ----- 4. 接続実行 -----
        var ipAddress = System.Net.IPAddress.Parse(_connectionConfig.IpAddress);
        // ★Parse: 文字列をIPAddressオブジェクトに変換

        var endpoint = new IPEndPoint(ipAddress, _connectionConfig.Port);
        // ★IPEndPoint: IPアドレスとポート番号のペア
        // ★例: 192.168.1.100:5000

        var connectTimeoutMs = _timeoutConfig.ConnectTimeoutMs;
        // ★接続タイムアウト値を取得（ミリ秒）

        var cts = new CancellationTokenSource(connectTimeoutMs);
        // ★CancellationTokenSource: キャンセル通知を発行するクラス
        // ★タイムアウト時間を指定してインスタンス作成

        await socket.ConnectAsync(endpoint, cts.Token);
        // ★ConnectAsync: 非同期で接続
        // ★endpoint: 接続先（IPアドレス:ポート）
        // ★cts.Token: タイムアウト用のキャンセルトークン
        // ★await: 接続完了まで待機

        // ----- 5. タイムアウト設定 -----
        socket.SendTimeout = _timeoutConfig.SendTimeoutMs;
        // ★SendTimeout: 送信タイムアウト時間（ミリ秒）

        socket.ReceiveTimeout = _timeoutConfig.ReceiveTimeoutMs;
        // ★ReceiveTimeout: 受信タイムアウト時間（ミリ秒）

        // ----- 6. 接続情報記録 -----
        _connectionResponse = new ConnectionResponse
        {
            Status = ConnectionStatus.Connected,  // 接続済み状態
            Socket = socket,                      // Socketオブジェクト
            ConnectedAt = DateTime.UtcNow,        // 接続時刻
            IpAddress = _connectionConfig.IpAddress,  // IPアドレス
            Port = _connectionConfig.Port         // ポート番号
        };
        // ★_connectionResponse: フィールドに保存（後続処理で使用）

        // ----- 7. 返却 -----
        return _connectionResponse;
    }
    catch (Exception ex)  // エラーが発生した場合
    {
        // エラーログ出力・統計記録などの処理
        // （省略）
        throw;  // 例外を再スロー（呼び出し元に伝播）
    }
}
```

---

## 5. Step4: データ送受信

### Step4-1: SendFrameAsync - 送信処理

```csharp
// ファイル: andon/Core/Managers/PlcCommunicationManager.cs
// SendFrameAsync: フレームを送信するメソッド
public async Task SendFrameAsync(string frameHexString)
// ★frameHexString: 16進数文字列（例: "5000..."）
{
    // ----- 1. 入力検証 -----
    if (string.IsNullOrEmpty(frameHexString))
    // ★string.IsNullOrEmpty: nullまたは空文字列かチェック
    {
        throw new ArgumentException(Constants.ErrorMessages.InvalidFrame, nameof(frameHexString));
        // ★nameof: パラメータ名を文字列として取得
    }

    // ----- 2. 未接続チェック -----
    if (_connectionResponse?.Status != ConnectionStatus.Connected || _connectionResponse?.Socket == null)
    // ★||: 論理OR演算子（どちらかがtrueならtrue）
    {
        throw new InvalidOperationException(Constants.ErrorMessages.NotConnected);
    }

    // ----- 3. フレーム文字列をバイト配列に変換 -----
    byte[] frameBytes;

    if (_connectionConfig.IsBinary)  // Binary形式の場合
    {
        // === 16進数文字列をバイナリに変換 ===
        frameBytes = ConvertHexStringToBytes(frameHexString);
        // ★"5000" → [0x50, 0x00]
    }
    else  // ASCII形式の場合
    {
        // === 文字列をそのままASCIIバイトに変換 ===
        frameBytes = System.Text.Encoding.ASCII.GetBytes(frameHexString);
        // ★Encoding.ASCII: ASCII文字エンコーディング
        // ★GetBytes: 文字列をバイト配列に変換
    }

    // ----- 4. ソケット送信 -----
    try
    {
        int sentBytes = await _connectionResponse.Socket.SendAsync(
            frameBytes,        // 送信するバイト配列
            SocketFlags.None); // フラグ（通常はNone）
        // ★SendAsync: 非同期で送信
        // ★戻り値: 送信したバイト数
        // ★await: 送信完了まで待機

        // ----- 5. 送信統計記録 -----
        _stats.SentFrames++;
        // ★++: インクリメント演算子（1増やす）

        _stats.SentBytes += sentBytes;
        // ★+=: 複合代入演算子（加算して代入）

        _stats.LastSentAt = DateTime.UtcNow;
        // ★最終送信時刻を記録
    }
    catch (SocketException ex)  // ソケットエラーの場合
    // ★SocketException: ネットワークエラー専用の例外
    {
        // エラー処理
        throw;
    }
}
```

### Step4-2: ReceiveResponseAsync - 受信処理

```csharp
// ファイル: andon/Core/Managers/PlcCommunicationManager.cs
// ReceiveResponseAsync: レスポンスを受信するメソッド
public async Task<RawResponseData> ReceiveResponseAsync(int receiveTimeoutMs)
// ★receiveTimeoutMs: 受信タイムアウト時間（ミリ秒）
{
    // ----- 1. 接続状態チェック -----
    if (_socket == null)
    {
        throw new InvalidOperationException(ErrorMessages.NotConnectedForReceive);
    }

    // ----- 2. 受信バッファ準備 -----
    byte[] buffer = new byte[8192];
    // ★buffer: 受信データを格納する配列（8KBサイズ）
    // ★8192 = 8 * 1024（通常のバッファサイズ）

    var startTime = DateTime.UtcNow;
    // ★受信開始時刻を記録

    // ----- 3. タイムアウト制御付き受信 -----
    var cts = new CancellationTokenSource(receiveTimeoutMs);
    // ★タイムアウト時間でキャンセルトークンを作成

    try
    {
        int receivedBytes;
        // ★receivedBytes: 受信したバイト数を格納する変数

        // === Socket型判定（テスト環境 or 本番環境）===
        if (_socket.GetType().Name == "MockSocket")  // ★テスト環境
        {
            // === テスト環境用の処理 ===
            var mockSocket = _socket as dynamic;
            // ★dynamic: 動的型（実行時に型が決まる）
            // ★as: キャスト演算子（変換）

            receivedBytes = await mockSocket.ReceiveAsync(
                new ArraySegment<byte>(buffer),  // 受信バッファのセグメント
                // ★ArraySegment<byte>: 配列の一部を表す構造体

                SocketFlags.None,
                cts.Token);
        }
        else  // ★本番環境（常にこちら）
        {
            // === 通常のSocket処理 ===
            receivedBytes = await _socket.ReceiveAsync(
                new ArraySegment<byte>(buffer),
                // ★ArraySegment: 配列全体を指定

                SocketFlags.None,
                // ★SocketFlags: ソケット操作のフラグ
                // ★None: 特別な処理なし

                cts.Token);
                // ★キャンセルトークン（タイムアウト検知用）
        }

        // ----- 4. 受信データ抽出 -----
        byte[] responseData = new byte[receivedBytes];
        // ★実際に受信したバイト数分の配列を作成

        Array.Copy(buffer, 0, responseData, 0, receivedBytes);
        // ★buffer → responseData にコピー
        // ★第1引数: コピー元
        // ★第2引数: コピー元開始位置（0から）
        // ★第3引数: コピー先
        // ★第4引数: コピー先開始位置（0から）
        // ★第5引数: コピーするバイト数

        // ----- 5. 受信統計記録 -----
        _stats.ReceivedFrames++;
        _stats.ReceivedBytes += receivedBytes;
        _stats.LastReceivedAt = DateTime.UtcNow;

        // ----- 6. 返却 -----
        return new RawResponseData
        {
            ResponseData = responseData,
            // ★受信した生データ（バイト配列）

            DataLength = receivedBytes,
            // ★受信バイト数

            ReceivedAt = DateTime.UtcNow,
            // ★受信時刻

            ReceiveTime = DateTime.UtcNow - startTime,
            // ★受信にかかった時間（TimeSpan型）

            ResponseHex = Convert.ToHexString(responseData),
            // ★16進数文字列に変換（ログ出力用）

            FrameType = FrameType.Frame3E  // 仮値（後で判定）
        };
    }
    catch (OperationCanceledException)  // タイムアウトの場合
    // ★OperationCanceledException: キャンセル時の例外
    {
        throw new TimeoutException($"受信タイムアウト: {receiveTimeoutMs}ms");
    }
}
```

---

## 6. Step6: データ解析

### Step6-1: ProcessReceivedRawData - 基本処理

```csharp
// ファイル: andon/Core/Managers/PlcCommunicationManager.cs
// ProcessReceivedRawData: 受信データを基本処理するメソッド
public async Task<BasicProcessedResponseData> ProcessReceivedRawData(
    byte[] rawData,                                // 受信した生データ
    ProcessedDeviceRequestInfo processedRequestInfo,  // 要求情報
    CancellationToken cancellationToken = default)    // キャンセルトークン
{
    // ----- 入力検証 -----
    if (rawData == null || rawData.Length == 0)
    {
        throw new ArgumentException(ErrorMessages.InvalidRawDataFormat);
    }

    // ----- 処理開始時刻とパフォーマンス計測 -----
    var startTime = DateTime.Now;
    var stopwatch = System.Diagnostics.Stopwatch.StartNew();
    // ★Stopwatch: 高精度な時間計測クラス
    // ★StartNew(): 計測開始

    // ----- 結果オブジェクト作成 -----
    var result = new BasicProcessedResponseData
    {
        IsSuccess = true,
        ProcessedDevices = new List<ProcessedDevice>(),
        // ★ProcessedDevice: 処理済みデバイス情報を保持するクラス

        Errors = new List<string>(),
        Warnings = new List<string>(),
        ProcessedAt = startTime,
        ProcessingTimeMs = 0,  // 後で設定
        ProcessedDeviceCount = 0,
        TotalDataSizeBytes = rawData.Length
    };

    try
    {
        // ----- フレームタイプ自動判定 -----
        FrameType detectedFrameType;
        // ★FrameType: 列挙型（Frame3E_Binary, Frame4E_Binary等）

        try
        {
            detectedFrameType = DetectFrameTypeFromSubheader(rawData);
            // ★サブヘッダ（先頭2バイト）からフレーム型を判定
            // ★0xD0 0x00 → Frame3E_Binary
            // ★0xD4 0x00 → Frame4E_Binary
        }
        catch (FormatException ex)
        {
            Console.WriteLine($"[ERROR] フレームタイプ自動判定失敗: {ex.Message}");
            throw;  // 例外を再スロー
        }

        // ----- SLMPフレーム構造検証 -----
        if (!ValidateSlmpFrameStructure(rawData, detectedFrameType))
        // ★フレームの最小長、構造が正しいかチェック
        {
            throw new FormatException(ErrorMessages.InvalidRawDataFormat);
        }

        // ----- フレーム構造解析 -----
        (ushort EndCode, byte[] DeviceData) frameData;
        // ★タプル: 複数の値を1つの変数で受け取る
        // ★EndCode: 終了コード（0x0000 = 正常）
        // ★DeviceData: デバイスデータ部分（バイト配列）

        switch (detectedFrameType)
        // ★switch: 値によって処理を分岐
        {
            case FrameType.Frame3E_Binary:
                frameData = Parse3EFrameStructure(rawData);
                // ★3Eフレーム（Binary）を解析
                break;  // switch文を抜ける

            case FrameType.Frame4E_Binary:
                frameData = Parse4EFrameStructure(rawData);
                // ★4Eフレーム（Binary）を解析
                break;

            case FrameType.Frame3E_ASCII:
                frameData = Parse3EFrameStructureAscii(rawData);
                // ★3Eフレーム（ASCII）を解析
                break;

            case FrameType.Frame4E_ASCII:
                frameData = Parse4EFrameStructureAscii(rawData);
                // ★4Eフレーム（ASCII）を解析
                break;

            default:
                // ★上記以外のケース（想定外）
                throw new NotSupportedException($"Frame type {detectedFrameType} is not supported");
                // ★NotSupportedException: サポートされていない機能の例外
        }

        // ----- 終了コード確認 -----
        if (frameData.EndCode != 0x0000)
        // ★0x0000以外はPLCエラー
        {
            throw new InvalidOperationException(
                string.Format(ErrorMessages.InvalidEndCode, frameData.EndCode.ToString("X4")));
            // ★string.Format: 文字列フォーマット
            // ★ToString("X4"): 16進数4桁で文字列化
        }

        // ----- デバイス値抽出 -----
        var extractedDevices = ExtractDeviceValues(frameData.DeviceData, processedRequestInfo, startTime);
        // ★DeviceDataからデバイス値を抽出
        // ★戻り値: List<ProcessedDevice>

        // ----- 処理済みデバイスリストに追加 -----
        foreach (var device in extractedDevices)
        {
            result.ProcessedDevices.Add(device);
            Console.WriteLine($"[DEBUG] デバイス値抽出: {device.DeviceName}={device.Value}({device.DataType})");
            // ★デバッグログ出力
        }

        result.ProcessedDeviceCount = result.ProcessedDevices.Count;

        // ----- ビット展開適用（オプション）-----
        if (_bitExpansionSettings.Enabled)
        // ★ビット展開機能が有効な場合
        {
            result.ProcessedDevices = ApplyBitExpansion(
                result.ProcessedDevices,
                _bitExpansionSettings);
            // ★ワードデバイスを16ビットに展開
        }

        // ----- 処理時間計算 -----
        stopwatch.Stop();
        // ★計測停止

        result.ProcessingTimeMs = Math.Max(stopwatch.ElapsedMilliseconds, 1);
        // ★Math.Max: 2つの値のうち大きい方を返す
        // ★最小1msに設定（0ms回避）

        return result;
    }
    catch (ArgumentException ex)
    {
        return HandleProcessingError(result, stopwatch, ex, "前処理情報エラー");
        // ★エラーハンドリング（例外を再スローしない）
    }
    // （他のcatch句も同様）
}
```

### ExtractDeviceValues - デバイス値抽出

```csharp
// ExtractDeviceValues: デバイスデータからデバイス値を抽出
private List<ProcessedDevice> ExtractDeviceValues(
    byte[] deviceData,                           // デバイスデータ部分
    ProcessedDeviceRequestInfo requestInfo,      // 要求情報
    DateTime processedAt)                        // 処理時刻
{
    var result = new List<ProcessedDevice>();
    // ★結果リスト

    int offset = 0;
    // ★offset: 現在の読み取り位置（バイト単位）

    // 要求したデバイスごとにループ
    foreach (var device in requestedDevices)
    {
        // ----- サイズ計算 -----
        int size = device.Unit == "word" ? 2 :
                   device.Unit == "dword" ? 4 : 1;
        // ★三項演算子: 条件 ? 真の値 : 偽の値
        // ★word: 2バイト, dword: 4バイト, bit: 1バイト

        // ----- 値のバイト列を取り出す -----
        byte[] valueBytes = deviceData[offset..(offset + size)];
        // ★範囲演算子: [開始..終了]
        // ★例: offset=0, size=2 → deviceData[0..2] （0,1番目）

        // ----- データ型変換 -----
        object value = ConvertDataType(valueBytes, device.DataType);
        // ★ConvertDataType: バイト列を実際の値に変換
        // ★戻り値: object型（任意の型を格納できる）

        // ----- ProcessedDeviceを作成 -----
        var processedDevice = new ProcessedDevice
        {
            DeviceName = device.ItemName,
            // ★例: "D100"

            DeviceCode = device.Code,
            // ★例: DeviceCode.D

            Address = device.DeviceNumber,
            // ★例: 100

            Value = value,
            // ★例: 12345（ushort型）

            DataType = device.DataType,
            // ★例: "word"

            ProcessedAt = processedAt
            // ★処理時刻
        };

        result.Add(processedDevice);

        // ----- 次のデバイスの位置に移動 -----
        offset += size;
        // ★offsetを増やして次のデバイスに進む
    }

    return result;
}
```

### ConvertDataType - データ型変換

```csharp
// ConvertDataType: バイト列を指定されたデータ型に変換
private object ConvertDataType(byte[] bytes, string dataType)
{
    switch (dataType)
    {
        case "word":
            // === 符号なし16ビット整数 ===
            return BitConverter.ToUInt16(bytes, 0);
            // ★BitConverter: バイト配列と基本型を相互変換するクラス
            // ★ToUInt16: バイト配列を16ビット符号なし整数に変換
            // ★第1引数: バイト配列
            // ★第2引数: 開始位置（0から）
            // ★例: [0x39, 0x30] → 0x3039 (LE) → 12345

        case "dword":
            // === 符号なし32ビット整数 ===
            return BitConverter.ToUInt32(bytes, 0);
            // ★ToUInt32: 32ビット符号なし整数に変換
            // ★例: [0x00, 0x00, 0x30, 0x39] → 0x39300000 (LE)

        case "bit":
            // === ビット値 ===
            return (bytes[0] & 0x10) != 0;
            // ★bytes[0]: 最初のバイト
            // ★& 0x10: ビット4をチェック（SLMP仕様）
            // ★!= 0: 0でなければtrue
            // ★戻り値: bool型

        case "signed":
            // === 符号付き16ビット整数 ===
            return BitConverter.ToInt16(bytes, 0);
            // ★ToInt16: 符号付き16ビット整数に変換
            // ★負の値も表現可能

        default:
            // === 未対応の型 ===
            throw new NotSupportedException($"Unsupported data type: {dataType}");
    }
}
```

---

## 7. Step7: JSON出力

### DataOutputManager.cs - OutputToJson実装

```csharp
// ファイル: andon/Core/Managers/DataOutputManager.cs
// OutputToJson: ProcessedResponseDataをJSON形式で出力
public void OutputToJson(
    ProcessedResponseData data,                    // 処理済みデータ
    string outputDirectory,                        // 出力先ディレクトリ
    string ipAddress,                              // IPアドレス
    int port,                                      // ポート番号
    Dictionary<string, DeviceEntryInfo> deviceConfig)  // デバイス設定
    // ★Dictionary: キーと値のペアを格納するコレクション
    // ★<string, DeviceEntryInfo>: キーが文字列、値がDeviceEntryInfo型
{
    try
    {
        // ----- データ検証 -----
        ValidateInputData(data, outputDirectory, ipAddress, port, deviceConfig);

        // ----- ファイル名生成 -----
        var timestamp = data.ProcessedAt;
        var dateString = timestamp.ToString("yyyyMMdd_HHmmssfff");
        // ★ToString("..."):日時を文字列に変換
        // ★"yyyyMMdd_HHmmssfff": フォーマット指定
        //   yyyy: 4桁の年, MM: 2桁の月, dd: 2桁の日
        //   HH: 24時間制の時, mm: 分, ss: 秒, fff: ミリ秒
        // ★例: "20251201_103045123"

        var ipString = ipAddress.Replace(".", "-");
        // ★Replace: 文字列置換
        // ★"192.168.1.100" → "192-168-1-100"

        var fileName = $"{dateString}_{ipString}_{port}.json";
        // ★文字列補間でファイル名を作成
        // ★例: "20251201_103045123_192-168-1-100_5000.json"

        var filePath = Path.Combine(outputDirectory, fileName);
        // ★Path.Combine: パスを結合（OS依存の区切り文字を自動処理）
        // ★例: "C:\output" + "file.json" → "C:\output\file.json"

        // ----- ディレクトリ存在確認・自動作成 -----
        if (!Directory.Exists(outputDirectory))
        // ★Directory.Exists: ディレクトリの存在確認
        {
            Directory.CreateDirectory(outputDirectory);
            // ★CreateDirectory: ディレクトリを作成（親ディレクトリも自動作成）
        }

        // ----- items配列構築 -----
        var itemsList = new List<object>();
        // ★List<object>: 任意の型のオブジェクトを格納できるリスト

        foreach (var kvp in data.ProcessedData)
        // ★kvp: KeyValuePair（キーと値のペア）
        {
            var deviceData = kvp.Value;
            // ★Value: Dictionaryの値部分を取得

            if (deviceData.Code.IsBitDevice())
            // ★IsBitDevice(): ビットデバイスかどうか判定する拡張メソッド
            {
                // === ビットデバイスは16ビット展開 ===
                AddBitDeviceItems(itemsList, deviceData, deviceConfig);
            }
            else
            {
                // === ワード/ダブルワードデバイスはそのまま ===
                AddWordDeviceItem(itemsList, kvp.Key, deviceData, deviceConfig);
            }
        }

        // ----- JSON構造構築 -----
        var jsonData = new
        // ★new: 匿名型のインスタンスを作成
        // ★匿名型: 名前のない型（プロパティのみ定義）
        {
            source = new
            {
                plcModel = "Unknown",  // PLC機種名（Phase7で実装予定）
                ipAddress = ipAddress,
                port = port
            },
            timestamp = new
            {
                local = timestamp.ToString("yyyy-MM-ddTHH:mm:ss.fffzzz")
                // ★ISO 8601形式
                // ★zzz: タイムゾーン（+09:00など）
            },
            items = itemsList.ToArray()
            // ★ToArray(): ListをArrayに変換
        };

        // ----- JSON出力（インデント付き）-----
        var options = new JsonSerializerOptions
        // ★JsonSerializerOptions: JSON変換のオプション
        {
            WriteIndented = true,
            // ★WriteIndented: 読みやすいようにインデントを追加

            Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping
            // ★Encoder: 文字のエンコード方法
            // ★UnsafeRelaxedJsonEscaping: 日本語などをそのまま出力
        };

        var jsonString = JsonSerializer.Serialize(jsonData, options);
        // ★JsonSerializer.Serialize: オブジェクトをJSON文字列に変換
        // ★System.Text.Json名前空間のクラス

        File.WriteAllText(filePath, jsonString);
        // ★File.WriteAllText: ファイルにテキストを書き込み
        // ★既存ファイルは上書き

        // ----- ログ出力完了 -----
        var fileInfo = new FileInfo(filePath);
        // ★FileInfo: ファイル情報を取得するクラス

        Console.WriteLine($"[INFO] JSON出力完了: ファイル={fileName}, ファイルサイズ={fileInfo.Length}バイト");
        // ★fileInfo.Length: ファイルサイズ（バイト）
    }
    catch (ArgumentNullException ex)
    // ★ArgumentNullException: 引数がnullの場合の例外
    {
        Console.WriteLine($"[ERROR] データがnullです: {ex.Message}");
        throw;  // 例外を再スロー
    }
    // （他のcatch句も同様）
}
```

### AddBitDeviceItems - ビットデバイス展開

```csharp
// AddBitDeviceItems: ビットデバイスを16ビットに展開してitemsに追加
private void AddBitDeviceItems(
    List<object> itemsList,                // 追加先リスト
    DeviceData deviceData,                 // デバイスデータ
    Dictionary<string, DeviceEntryInfo> deviceConfig)  // デバイス設定
{
    // ----- ワード値を取得 -----
    ushort wordValue = Convert.ToUInt16(deviceData.Value);
    // ★Convert.ToUInt16: objectをushortに変換
    // ★例: 0x00FF → 255

    // ----- 16ビットループ -----
    for (int bitIndex = 0; bitIndex < BitsPerWord; bitIndex++)
    // ★BitsPerWord: 定数16（1ワード = 16ビット）
    // ★bitIndex: 0から15までループ
    {
        // === ビット値を取得 ===
        bool bitValue = (wordValue & (1 << bitIndex)) != 0;
        // ★(1 << bitIndex): 左シフト演算
        //   bitIndex=0: 1 << 0 = 0b00000001 (1)
        //   bitIndex=1: 1 << 1 = 0b00000010 (2)
        //   bitIndex=2: 1 << 2 = 0b00000100 (4)
        // ★wordValue & ...: ビットAND演算
        //   例: 0b11111111 & 0b00000001 = 0b00000001 (1)
        //   例: 0b11111111 & 0b00010000 = 0b00010000 (16)
        // ★!= 0: 結果が0でなければtrue

        // === アドレス文字列を作成 ===
        string address = $"{deviceData.DeviceName}.{bitIndex}";
        // ★例: "M10.0", "M10.1", ..., "M10.15"

        // === itemsに追加 ===
        itemsList.Add(new
        // ★匿名型のオブジェクトを作成してリストに追加
        {
            address = address,
            value = bitValue,
            digits = GetDigits(deviceConfig, deviceData)
            // ★桁数を取得（設定ファイルから）
        });
    }
}
```

---

## 8. エラーハンドリング

### 継続実行モードでのエラー処理

```csharp
// ファイル: andon/Core/Controllers/ExecutionOrchestrator.cs
// ExecuteMultiPlcCycleAsync_Internal: 複数PLCのサイクル実行
private async Task ExecuteMultiPlcCycleAsync_Internal(
    List<PlcConfiguration> plcConfigs,
    List<Interfaces.IPlcCommunicationManager> plcManagers,
    CancellationToken cancellationToken)
{
    // ----- 入力検証 -----
    if (plcManagers == null || plcManagers.Count == 0)
    {
        return;  // エラーログ出力後、処理を終了
    }

    // ----- 各PLCに対してループ -----
    for (int i = 0; i < plcManagers.Count; i++)
    {
        var manager = plcManagers[i];
        var config = plcConfigs[i];

        try
        {
            // ----- キャンセルチェック -----
            cancellationToken.ThrowIfCancellationRequested();
            // ★ThrowIfCancellationRequested: キャンセル要求があれば例外スロー
            // ★OperationCanceledException をスロー

            // ----- Step2: フレーム構築 -----
            var frame = _configToFrameManager!.BuildReadRandomFrameFromConfig(config);
            // ★!: null非許容演算子（nullでないことを保証）

            // ----- Step3-6: 完全サイクル実行 -----
            var result = await manager.ExecuteFullCycleAsync(
                connectionConfig,
                timeoutConfig,
                frame,
                deviceRequestInfo,
                cancellationToken);

            // ----- Step7: データ出力 -----
            if (result.IsSuccess && result.ProcessedData != null)
            {
                _dataOutputManager?.OutputToJson(
                    result.ProcessedData,
                    outputDirectory,
                    config.IpAddress,
                    config.Port,
                    deviceConfig);
                // ★?: null条件演算子（nullの場合は実行しない）
            }
        }
        catch (OperationCanceledException)
        // ★キャンセル要求の場合
        {
            throw;  // ★例外を再スロー（上位に伝播）
            // ★キャンセルは正常なフローなので上位で処理
        }
        catch (Exception ex)
        // ★その他すべての例外
        {
            // ===== エラーログ出力 =====
            // （LoggingManager追加時に実装）

            // ===== ★重要: 例外を再スローしない =====
            // ★ここで止まらず、次のPLCの処理を継続
            // ★1つのPLCの失敗が他のPLCに影響しない

            _ = ex;  // ★警告回避（使用していない変数）
            // ★_: 破棄（discard）、値を捨てる
        }
    }
}
```

### データ破損時のエラー処理

```csharp
// ProcessReceivedRawData内のエラーハンドリング
catch (FormatException ex)
// ★FormatException: データ形式エラー
{
    return HandleProcessingError(result, stopwatch, ex, "データ形式エラー");
    // ★★重要: throw しない（例外を再スローしない）
    // ★エラー情報を含む結果オブジェクトを返す
}

// HandleProcessingError: エラー処理メソッド
private BasicProcessedResponseData HandleProcessingError(
    BasicProcessedResponseData result,
    Stopwatch stopwatch,
    Exception ex,
    string errorCategory)
{
    // ----- 失敗状態に設定 -----
    result.IsSuccess = false;
    // ★処理失敗フラグを立てる

    // ----- エラーメッセージを追加 -----
    result.Errors.Add($"{errorCategory}: {ex.Message}");
    // ★Errors: エラーメッセージのリスト
    // ★Add: リストに追加

    // ----- 処理時間を記録 -----
    result.ProcessingTimeMs = stopwatch.ElapsedMilliseconds;
    // ★ElapsedMilliseconds: 経過ミリ秒

    // ----- エラーログ出力 -----
    Console.WriteLine($"[ERROR] {errorCategory}: {ex.Message}");

    // ----- 結果オブジェクトを返す -----
    return result;
    // ★★重要: throwしない、結果を返す
    // ★呼び出し元でIsSuccessをチェックしてエラー判定
}
```

---

## C#の重要な概念（初学者向け）

### 1. 非同期処理（async/await）

```csharp
// async: このメソッドは非同期処理を含むことを宣言
// Task<T>: 非同期でT型の値を返すことを表す
public async Task<string> GetDataAsync()
{
    // await: この処理の完了を待つ（でも他の処理をブロックしない）
    var result = await SomeAsyncOperation();
    // ★awaitがあると、処理が完了するまで待機
    // ★でも、CPUは他の処理を実行できる（ブロックしない）

    return result;
}

// 同期版との比較
public string GetDataSync()  // ★asyncなし
{
    var result = SomeOperation();  // ★awaitなし、処理完了まで待機
    return result;
    // ★この間、CPUは他のことができない（ブロック）
}
```

### 2. null許容型と演算子

```csharp
// null許容型
string? name = null;  // ★?: nullを許容する参照型
// ★C# 8.0以降、参照型はデフォルトでnull非許容

// null条件演算子
int? length = name?.Length;
// ★?: nameがnullの場合は評価しない（lengthはnull）
// ★nameがnullでない場合のみ.Lengthを評価

// null合体演算子
string displayName = name ?? "Unknown";
// ★??: 左側がnullの場合は右側を返す
// ★nameがnullなら"Unknown"、nullでなければnameの値

// null非許容演算子
string definitelyNotNull = name!;
// ★!: nameは絶対にnullでないことを保証
// ★コンパイラの警告を抑制（実行時にnullならエラー）
```

### 3. LINQ（Language Integrated Query）

```csharp
// データソース
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };

// ToList(): IEnumerableをListに変換
var list = numbers.Where(n => n > 2).ToList();
// ★Where: 条件に合う要素だけを抽出
// ★n => n > 2: ラムダ式（無名関数）、nが2より大きい

// Select: 各要素を変換
var doubled = numbers.Select(n => n * 2);
// ★各要素を2倍に変換

// FirstOrDefault: 最初の要素を取得（なければデフォルト値）
var first = numbers.FirstOrDefault(n => n > 10);
// ★10より大きい最初の要素（なければ0）

// Count: 要素数を取得
int count = numbers.Count;
```

### 4. ジェネリック型

```csharp
// List<T>: T型の要素を持つリスト
List<int> numbers = new List<int>();
// ★<int>: intだけを格納できるリスト

List<string> names = new List<string>();
// ★<string>: stringだけを格納できるリスト

// ジェネリックメソッド
public T GetValue<T>(string key)
// ★<T>: 型パラメータ（呼び出し時に型を指定）
{
    // Tは実際の型に置き換えられる
}

// 使用例
int value = GetValue<int>("age");
// ★<int>: Tをintとして使用
```

### 5. デリゲートとラムダ式

```csharp
// デリゲート: メソッドへの参照を保持する型
Func<int, int, int> add = (a, b) => a + b;
// ★Func<T1, T2, TResult>: T1,T2を受け取りTResultを返すデリゲート
// ★(a, b) => a + b: ラムダ式（匿名関数）

int result = add(1, 2);  // ★3

// Action: 戻り値なしのデリゲート
Action<string> print = message => Console.WriteLine(message);
// ★Action<T>: Tを受け取り戻り値なし

print("Hello");  // ★"Hello"を出力
```

### 6. プロパティとフィールド

```csharp
public class Person
{
    // フィールド（変数）
    private string _name;  // ★private: クラス内部からのみアクセス可能

    // プロパティ（getterとsetterを持つ）
    public string Name
    // ★public: 外部からアクセス可能
    {
        get { return _name; }       // ★getter: 値を取得
        set { _name = value; }      // ★setter: 値を設定
        // ★value: 設定される値を表すキーワード
    }

    // 自動実装プロパティ
    public int Age { get; set; }
    // ★get/setを自動生成（フィールド不要）
}
```

---

## まとめ: 実装の流れ全体像

```
1. アプリケーション起動
   └─> Program.Main() → DIコンテナ設定 → AndonHostedService起動

2. Step1: 初期化（1回のみ）
   └─> 設定ファイル読み込み
       → PlcCommunicationManagerインスタンス作成
       → _plcManagers, _plcConfigsに保存

3. 継続実行モード開始
   └─> TimerService.StartPeriodicExecution()
       → MonitoringIntervalMs間隔でStep2-7を繰り返し実行

4. Step2-7: データ処理サイクル（繰り返し）
   ├─> Step2: フレーム構築
   │   └─> SlmpFrameBuilder.BuildReadRandomRequest()
   │       → byte[] frame
   │
   ├─> Step3: 接続
   │   └─> PlcCommunicationManager.ConnectAsync()
   │       → Socket作成・接続 → ConnectionResponse
   │
   ├─> Step4: 送受信
   │   ├─> SendFrameAsync(frame) → 送信
   │   └─> ReceiveResponseAsync() → RawResponseData
   │
   ├─> Step6: データ解析
   │   ├─> Step6-1: ProcessReceivedRawData()
   │   │   → BasicProcessedResponseData
   │   ├─> Step6-2: データ変換
   │   │   → ProcessedResponseData
   │   └─> Step6-3: 構造化
   │       → StructuredData
   │
   ├─> Step5: 切断
   │   └─> DisconnectAsync() → Socket破棄
   │
   └─> Step7: データ出力
       └─> DataOutputManager.OutputToJson()
           → JSONファイル出力

5. エラー時も継続実行
   └─> 1つのPLCの失敗が他のPLCに影響しない
       → 次のサイクルで自動回復
```

---

**最終更新:** 2025-12-01
**対象読者:** C#初学者
**推奨学習順序:**
1. C#の基本文法（変数、型、制御構文）
2. オブジェクト指向（クラス、継承、インターフェース）
3. 非同期処理（async/await）
4. LINQ
5. 本ドキュメントの理解
