# PLC接続時の通信プロトコル自動切り替え実装計画

**最終更新**: 2025-11-28

**重要**: 本実装計画は**Excel設定ファイル形式**を前提としています。Phase4_JSON廃止計画に従い、JSON形式の設定ファイルは廃止されました。

## 概要

PLC接続時に、Excel設定ファイルで指定されたプロトコル（TCP/UDP）での接続が失敗した場合、自動的に代替プロトコルで再試行する機能を実装する。

## 目的

- PLC接続の信頼性向上
- ネットワーク環境に応じた柔軟な接続方式の選択
- オペレーターの手動設定変更作業を削減

## 実装対象

### 主要実装箇所

**1. PlcCommunicationManager.ConnectAsync()**
- 場所: `andon/Core/Managers/PlcCommunicationManager.cs`
- 役割: PLC接続処理の中核メソッド

### 関連する既存コンポーネント

**2. PlcConfiguration**
- 場所: `andon/Core/Models/ConfigModels/PlcConfiguration.cs`
- 役割: Excel設定ファイルから読み込まれた接続設定（IP、ポート、プロトコル、タイムアウト等）

**3. ConfigurationLoaderExcel**
- 場所: `andon/Infrastructure/Configuration/ConfigurationLoaderExcel.cs`
- 役割: Excel設定ファイル（*.xlsx）の読み込み

**4. ConnectionConfig**
- 場所: `andon/Core/Models/ConfigModels/ConnectionConfig.cs`
- 役割: PLC通信時に使用する接続設定
- プロパティ:
  - `IpAddress`: IPアドレス
  - `Port`: ポート番号
  - `UseTcp`: TCP使用フラグ（false=UDP）
  - `ConnectionType`: 計算プロパティ（"TCP" または "UDP"）
  - `IsBinary`: バイナリ形式フラグ
  - `FrameVersion`: フレームバージョン（列挙型）

**5. TimeoutConfig**
- 場所: `andon/Core/Models/ConfigModels/TimeoutConfig.cs`
- 役割: タイムアウト設定
- プロパティ:
  - `ConnectTimeoutMs`: 接続タイムアウト（ミリ秒）
  - `SendTimeoutMs`: 送信タイムアウト（ミリ秒）
  - `ReceiveTimeoutMs`: 受信タイムアウト（ミリ秒）

**6. ConnectionResponse**
- 場所: `andon/Core/Models/ConnectionResponse.cs`
- 役割: ConnectAsync()の戻り値モデル

**7. ErrorHandler**
- 場所: `andon/Core/Managers/ErrorHandler.cs`
- 役割: エラー処理・ログ記録

**8. LoggingManager**
- 場所: `andon/Core/Managers/LoggingManager.cs`
- 役割: 接続試行履歴のログ出力

## 実装仕様

### 1. 接続試行フロー

```
開始
  ↓
Excel設定ファイルから初期プロトコルを取得
  ↓
初期プロトコルで接続試行（タイムアウト設定に従う）
  ↓
成功? ─YES→ 接続成功を返却 → 終了
  ↓NO
代替プロトコルで接続試行（タイムアウト設定に従う）
  ↓
成功? ─YES→ 接続成功を返却（代替プロトコル使用を記録） → 終了
  ↓NO
接続失敗を返却（両プロトコル失敗を記録） → 終了
```

### 2. 詳細仕様

#### 2.1 接続試行ロジック

**前提: 設定情報の変換**
- Excel設定ファイル → `PlcConfiguration` → **変換処理** → `ConnectionConfig`
- `PlcCommunicationManager`は`ConnectionConfig`を使用
- 変換処理で`PlcConfiguration.ConnectionMethod` ("TCP"/"UDP") → `ConnectionConfig.UseTcp` (bool)に変換

**初期プロトコル試行:**
- `ConnectionConfig.UseTcp`に基づいてプロトコル（TCP/UDP）を決定
- `TimeoutConfig.ConnectTimeoutMs`で指定されたタイムアウト時間内に接続を試行
- 接続失敗時は例外をキャッチし、次のステップへ

**代替プロトコル試行:**
- 初期プロトコルがTCPの場合 → UDPで再試行
- 初期プロトコルがUDPの場合 → TCPで再試行
- 同じタイムアウト設定を使用
- 接続失敗時は例外をキャッチし、最終的な失敗として処理

#### 2.2 戻り値仕様

**現在のConnectionResponseモデル（実装済み）:**
```csharp
public class ConnectionResponse
{
    public required ConnectionStatus Status { get; init; }  // 接続状態（Connected/Failed/Timeout）
    public Socket? Socket { get; init; }                    // ソケットインスタンス
    public DateTime? ConnectedAt { get; init; }             // 接続完了時刻
    public double? ConnectionTime { get; init; }            // 接続所要時間（ミリ秒）
    public string? ErrorMessage { get; init; }              // エラーメッセージ
}
```

**通信プロトコル自動切り替え機能実装時に追加予定:**
```csharp
// ★以下のプロパティを追加予定
public string? UsedProtocol { get; init; }          // 実際に使用されたプロトコル（"TCP"/"UDP"）
public bool IsFallbackConnection { get; init; }     // 代替プロトコルで接続したか
public string? FallbackErrorDetails { get; init; }  // 初期プロトコル失敗時のエラー詳細
```

**成功パターン:**
1. 初期プロトコルで成功
   - `Status = ConnectionStatus.Connected`
   - `UsedProtocol = 設定で指定されたプロトコル（"TCP"または"UDP"）`
   - `IsFallbackConnection = false`
   - `Socket = 接続済みSocketインスタンス`
   - `ConnectedAt = 接続完了時刻`
   - `ConnectionTime = 接続所要時間（ミリ秒）`

2. 代替プロトコルで成功
   - `Status = ConnectionStatus.Connected`
   - `UsedProtocol = 代替プロトコル（"TCP"または"UDP"）`
   - `IsFallbackConnection = true`
   - `FallbackErrorDetails = "初期プロトコル({初期})で接続失敗: {エラー詳細}"`
   - `Socket = 接続済みSocketインスタンス`
   - `ConnectedAt = 接続完了時刻`
   - `ConnectionTime = 接続所要時間（ミリ秒）`

**失敗パターン:**
- `Status = ConnectionStatus.Failed` または `ConnectionStatus.Timeout`
- `ErrorMessage = "TCP/UDP両プロトコルでの接続に失敗しました。\n- TCP接続エラー: {詳細}\n- UDP接続エラー: {詳細}"`
- `Socket = null`

#### 2.3 ログ出力仕様

**接続試行開始時:**
```
[INFO] PLC接続試行開始: {IP}:{Port}, プロトコル: {初期プロトコル}
```

**初期プロトコル失敗時:**
```
[WARN] {初期プロトコル}接続失敗: {エラー内容}. 代替プロトコル({代替})で再試行します。
```

**代替プロトコル成功時:**
```
[INFO] 代替プロトコル({代替})で接続成功: {IP}:{Port}
```

**両プロトコル失敗時:**
```
[ERROR] PLC接続失敗: {IP}:{Port}. TCP/UDP両プロトコルで接続に失敗しました。
  - TCP接続エラー: {TCPエラー詳細}
  - UDP接続エラー: {UDPエラー詳細}
```

#### 2.4 タイムアウト設定

- 各プロトコルの接続試行には独立したタイムアウトを適用
- `TimeoutConfig.ConnectTimeoutMs`を使用（単位: ミリ秒）
- 合計最大接続時間 = `ConnectTimeoutMs × 2`（初期 + 代替）

**注意**:
- Excel設定ファイルの`PlcConfiguration.Timeout`は`TimeoutConfig.ConnectTimeoutMs`に変換して使用
- `TimeoutConfig`には他に`SendTimeoutMs`、`ReceiveTimeoutMs`も存在するが、接続試行には`ConnectTimeoutMs`のみを使用

#### 2.5 エラーハンドリング

**対象とする例外:**
- `SocketException`: ネットワーク接続エラー
- `TimeoutException`: タイムアウトエラー
- `InvalidOperationException`: 無効な操作（ソケット状態エラー等）

**例外発生時の処理:**
1. エラー内容をログに記録
2. 初回試行の場合 → 代替プロトコルで再試行
3. 再試行後の場合 → ConnectionResponseに詳細を含めて失敗を返却

### 3. 設定ファイル仕様

既存のExcel設定ファイル（*.xlsx）の"settings"シートに変更なし。`ConnectionMethod`フィールドは初期接続試行プロトコルを指定する意味となる。

**Excel設定ファイル "settings"シート（抜粋）:**

| 項目名 | セル | 値の例 | 備考 |
|--------|------|--------|------|
| IPAddress | B8 | 192.168.1.100 | PLC IPアドレス（必須） |
| Port | B9 | 5000 | PLC ポート番号（必須） |
| ConnectionMethod | B10 | TCP | 初期試行プロトコル（TCP/UDP、既定値: UDP） |
| Timeout | B11 | 5000 | タイムアウト値（ミリ秒、既定値: 1000） |
| FrameVersion | B14 | 4E | SLMPフレームバージョン（3E/4E、既定値: 4E） |
| IsBinary | B15 | true | Binary/ASCII形式（既定値: true） |

**注意**: Phase4_JSON廃止計画に従い、JSON形式の設定ファイルは廃止されました。全ての設定はExcel形式（*.xlsx）から読み込まれます。

### 4. 既存機能への影響

**変更が必要な箇所:**
- `PlcCommunicationManager.ConnectAsync()`: 実装の追加・修正
- `ConnectionResponse`: 新規プロパティの追加

**変更不要な箇所:**
- `PlcConfiguration`: 既存のまま使用（Excel読み込み専用モデル）
- `ConfigurationLoaderExcel`: 既存のまま使用（Excel読み込み機能）
- `ConnectionConfig`: 既存のまま使用（PLC通信専用設定）
- `TimeoutConfig`: 既存のまま使用（タイムアウト設定）
- `ConnectionStatus`: 既存のまま使用（接続状態列挙型）
- その他のManagerクラス: 影響なし

**注意:**
- `ConnectionType`列挙型（Ethernet/Serial/USB）は本機能では使用しません
- プロトコル判定は`ConnectionConfig.UseTcp` (bool)と`ConnectionConfig.ConnectionType` (string計算プロパティ)を使用

## 実装手順（TDD: Red-Green-Refactor）

このプロジェクトはTDD（テスト駆動開発）手法に従います。各Phaseで**Red（失敗するテストを書く）→ Green（テストを通す最小実装）→ Refactor（改善）**のサイクルを実施します。

### Phase 1: ConnectionResponseモデル拡張

#### Step 1-Red: 失敗するテストを作成

**作業内容:**
1. `ConnectionResponseTests.cs`に以下のテストケースを追加（全て失敗する状態）:
   ```csharp
   [Fact]
   public void UsedProtocol_初期TCP成功時_TCPを返す()
   {
       var response = new ConnectionResponse
       {
           Status = ConnectionStatus.Connected,
           UsedProtocol = "TCP",  // ← まだ存在しないプロパティ
           IsFallbackConnection = false
       };
       Assert.Equal("TCP", response.UsedProtocol);
   }

   [Fact]
   public void IsFallbackConnection_代替プロトコル使用時_Trueを返す()
   {
       var response = new ConnectionResponse
       {
           Status = ConnectionStatus.Connected,
           UsedProtocol = "UDP",
           IsFallbackConnection = true,  // ← まだ存在しないプロパティ
           FallbackErrorDetails = "TCP接続失敗"
       };
       Assert.True(response.IsFallbackConnection);
   }

   [Fact]
   public void FallbackErrorDetails_初期プロトコル失敗時_エラー詳細を保持()
   {
       var response = new ConnectionResponse
       {
           Status = ConnectionStatus.Connected,
           UsedProtocol = "UDP",
           IsFallbackConnection = true,
           FallbackErrorDetails = "TCP接続タイムアウト"  // ← まだ存在しないプロパティ
       };
       Assert.Equal("TCP接続タイムアウト", response.FallbackErrorDetails);
   }
   ```

2. テスト実行 → **コンパイルエラー（Red状態）**を確認

#### Step 1-Green: テストを通す最小実装

**作業内容:**
1. `ConnectionResponse.cs`に新規プロパティを追加:
   ```csharp
   public class ConnectionResponse
   {
       // 既存プロパティ（変更なし）
       public required ConnectionStatus Status { get; init; }
       public Socket? Socket { get; init; }
       public DateTime? ConnectedAt { get; init; }
       public double? ConnectionTime { get; init; }
       public string? ErrorMessage { get; init; }

       // 新規プロパティ
       public string? UsedProtocol { get; init; }          // 実際に使用されたプロトコル（"TCP"/"UDP"）
       public bool IsFallbackConnection { get; init; }     // 代替プロトコルで接続したか
       public string? FallbackErrorDetails { get; init; }  // 初期プロトコル失敗時のエラー詳細
   }
   ```

2. テスト実行 → **全テスト成功（Green状態）**を確認

#### Step 1-Refactor: コード改善

**作業内容:**
1. XMLドキュメントコメントを追加
2. プロパティの妥当性確認（nullable設定が適切か等）
3. テスト実行 → **全テスト成功を維持**

---

### Phase 2: 接続ロジック実装（代替プロトコル試行）

#### Step 2-Red: 失敗するテストを作成

**作業内容:**
1. `PlcCommunicationManagerTests.cs`に以下のテストケースを追加（全て失敗する状態）:
   ```csharp
   [Fact]
   public async Task ConnectAsync_初期TCP成功_TCPで接続しIsFallbackConnectionがFalse()
   {
       // Arrange: TCP接続が成功するモック設定
       var mockSocket = CreateMockTcpSocket(success: true);

       // Act
       var result = await _manager.ConnectAsync();

       // Assert
       Assert.Equal(ConnectionStatus.Connected, result.Status);
       Assert.Equal("TCP", result.UsedProtocol);  // ← 現在の実装では設定されない
       Assert.False(result.IsFallbackConnection);  // ← 現在の実装では設定されない
   }

   [Fact]
   public async Task ConnectAsync_TCP失敗UDP成功_UDPで接続しIsFallbackConnectionがTrue()
   {
       // Arrange: TCP失敗、UDP成功するモック設定
       var mockTcpSocket = CreateMockTcpSocket(success: false);
       var mockUdpSocket = CreateMockUdpSocket(success: true);

       // Act
       var result = await _manager.ConnectAsync();

       // Assert
       Assert.Equal(ConnectionStatus.Connected, result.Status);
       Assert.Equal("UDP", result.UsedProtocol);  // ← 現在の実装では代替試行なし
       Assert.True(result.IsFallbackConnection);   // ← 現在の実装では代替試行なし
       Assert.NotNull(result.FallbackErrorDetails); // ← TCP失敗のエラー詳細
   }

   [Fact]
   public async Task ConnectAsync_両プロトコル失敗_失敗ステータスと詳細エラー()
   {
       // Arrange: TCP/UDP両方失敗するモック設定
       var mockTcpSocket = CreateMockTcpSocket(success: false);
       var mockUdpSocket = CreateMockUdpSocket(success: false);

       // Act
       var result = await _manager.ConnectAsync();

       // Assert
       Assert.NotEqual(ConnectionStatus.Connected, result.Status);
       Assert.Contains("TCP", result.ErrorMessage);  // ← 両エラーの詳細が必要
       Assert.Contains("UDP", result.ErrorMessage);  // ← 両エラーの詳細が必要
   }
   ```

2. テスト実行 → **失敗（Red状態）**を確認

#### Step 2-Green: テストを通す最小実装

**作業内容:**
1. `PlcCommunicationManager.cs`に内部ヘルパーメソッドを追加（privateメソッド）:
   ```csharp
   private string GetAlternativeProtocol(bool useTcp)
   {
       return useTcp ? "UDP" : "TCP";
   }

   private async Task<(bool success, Socket? socket, string? error)>
       TryConnectWithProtocolAsync(bool useTcp, int timeoutMs)
   {
       // 最小実装: 指定プロトコルでの接続試行
       // 成功/失敗とエラー詳細を返却
   }
   ```

2. `ConnectAsync()`メソッドを拡張:
   ```csharp
   public async Task<ConnectionResponse> ConnectAsync()
   {
       var startTime = DateTime.UtcNow;
       var initialProtocol = _connectionConfig.UseTcp;

       // 1. 初期プロトコルで試行
       var (success, socket, error) = await TryConnectWithProtocolAsync(
           initialProtocol,
           _timeoutConfig.ConnectTimeoutMs);

       if (success)
       {
           return new ConnectionResponse
           {
               Status = ConnectionStatus.Connected,
               Socket = socket,
               UsedProtocol = initialProtocol ? "TCP" : "UDP",
               IsFallbackConnection = false,
               ConnectedAt = DateTime.UtcNow,
               ConnectionTime = (DateTime.UtcNow - startTime).TotalMilliseconds
           };
       }

       // 2. 代替プロトコルで試行
       var alternativeProtocol = !initialProtocol;
       var (altSuccess, altSocket, altError) = await TryConnectWithProtocolAsync(
           alternativeProtocol,
           _timeoutConfig.ConnectTimeoutMs);

       if (altSuccess)
       {
           return new ConnectionResponse
           {
               Status = ConnectionStatus.Connected,
               Socket = altSocket,
               UsedProtocol = alternativeProtocol ? "TCP" : "UDP",
               IsFallbackConnection = true,
               FallbackErrorDetails = $"初期プロトコル({(initialProtocol ? "TCP" : "UDP")})失敗: {error}",
               ConnectedAt = DateTime.UtcNow,
               ConnectionTime = (DateTime.UtcNow - startTime).TotalMilliseconds
           };
       }

       // 3. 両プロトコル失敗
       return new ConnectionResponse
       {
           Status = ConnectionStatus.Failed,
           ErrorMessage = $"TCP/UDP両プロトコルで接続失敗\n- TCP: {(initialProtocol ? error : altError)}\n- UDP: {(!initialProtocol ? error : altError)}"
       };
   }
   ```

3. テスト実行 → **全テスト成功（Green状態）**を確認

#### Step 2-Refactor: コード改善

**作業内容:**
1. 重複コードの削除（プロトコル判定処理を共通化）
2. マジックナンバーの定数化
3. エラーメッセージの統一（ErrorMessages.csへの移動）
4. テスト実行 → **全テスト成功を維持**

---

### Phase 3: ログ出力実装

#### Step 3-Red: 失敗するテストを作成

**作業内容:**
1. `PlcCommunicationManagerTests.cs`にログ検証テストを追加:
   ```csharp
   [Fact]
   public async Task ConnectAsync_初期プロトコル成功_接続開始ログのみ出力()
   {
       // Arrange: ログ出力をキャプチャするモック
       var mockLogger = new Mock<ILoggingManager>();

       // Act
       var result = await _manager.ConnectAsync();

       // Assert
       mockLogger.Verify(x => x.LogInfo(
           It.Is<string>(s => s.Contains("PLC接続試行開始"))),
           Times.Once);  // ← 現在の実装ではログ出力なし（Red状態）
   }

   [Fact]
   public async Task ConnectAsync_代替プロトコル成功_警告ログと成功ログ出力()
   {
       // Arrange: TCP失敗→UDP成功のモック
       var mockLogger = new Mock<ILoggingManager>();

       // Act
       var result = await _manager.ConnectAsync();

       // Assert
       mockLogger.Verify(x => x.LogWarning(
           It.Is<string>(s => s.Contains("TCP接続失敗") && s.Contains("UDP再試行"))),
           Times.Once);  // ← 現在の実装ではログ出力なし
       mockLogger.Verify(x => x.LogInfo(
           It.Is<string>(s => s.Contains("代替プロトコル(UDP)で接続成功"))),
           Times.Once);
   }

   [Fact]
   public async Task ConnectAsync_両プロトコル失敗_詳細エラーログ出力()
   {
       // Arrange: 両プロトコル失敗のモック
       var mockLogger = new Mock<ILoggingManager>();

       // Act
       var result = await _manager.ConnectAsync();

       // Assert
       mockLogger.Verify(x => x.LogError(
           It.Is<string>(s => s.Contains("TCP/UDP両プロトコルで接続失敗"))),
           Times.Once);  // ← 現在の実装ではログ出力なし
   }
   ```

2. テスト実行 → **失敗（Red状態）**を確認

#### Step 3-Green: テストを通す最小実装

**作業内容:**
1. `ConnectAsync()`内にログ出力を追加:
   ```csharp
   public async Task<ConnectionResponse> ConnectAsync()
   {
       // 接続開始ログ
       _loggingManager.LogInfo(
           $"PLC接続試行開始: {_connectionConfig.IpAddress}:{_connectionConfig.Port}, " +
           $"プロトコル: {(_connectionConfig.UseTcp ? "TCP" : "UDP")}");

       // ... 初期プロトコル試行 ...

       if (!success)
       {
           // 初期プロトコル失敗時の警告ログ
           _loggingManager.LogWarning(
               $"{(_connectionConfig.UseTcp ? "TCP" : "UDP")}接続失敗: {error}. " +
               $"代替プロトコル({GetAlternativeProtocol(_connectionConfig.UseTcp)})で再試行します。");
       }

       if (altSuccess)
       {
           // 代替プロトコル成功ログ
           _loggingManager.LogInfo(
               $"代替プロトコル({GetAlternativeProtocol(_connectionConfig.UseTcp)})で接続成功: " +
               $"{_connectionConfig.IpAddress}:{_connectionConfig.Port}");
       }
       else
       {
           // 両プロトコル失敗時のエラーログ
           _loggingManager.LogError(
               $"PLC接続失敗: {_connectionConfig.IpAddress}:{_connectionConfig.Port}. " +
               $"TCP/UDP両プロトコルで接続に失敗しました。\n" +
               $"  - TCP接続エラー: {(initialProtocol ? error : altError)}\n" +
               $"  - UDP接続エラー: {(!initialProtocol ? error : altError)}");
       }

       // ... 戻り値生成 ...
   }
   ```

2. テスト実行 → **全テスト成功（Green状態）**を確認

#### Step 3-Refactor: コード改善

**作業内容:**
1. ログメッセージを`ErrorMessages.cs`に集約
2. ログ出力処理を内部メソッドに分離（可読性向上）
3. テスト実行 → **全テスト成功を維持**

---

### Phase 4: 統合テスト

#### Step 4-Red: 失敗する統合テストを作成

**作業内容:**
1. `Step3_6_IntegrationTests.cs`に統合テストを追加（初期状態では失敗）:
   ```csharp
   [Fact]
   public async Task Integration_TCPからUDPへの自動切り替え_正常にデータ送受信()
   {
       // Arrange: TCP接続不可、UDP接続可能な環境を模擬
       var mockTcpSocket = CreateFailingTcpSocket();
       var mockUdpSocket = CreateSuccessfulUdpSocket();

       // Act: 接続→データ送信→データ受信の一連の流れ
       var connectResult = await _manager.ConnectAsync();
       var sendResult = await _manager.SendFrameAsync(testFrame);
       var receiveResult = await _manager.ReceiveResponseAsync();

       // Assert
       Assert.True(connectResult.IsFallbackConnection);
       Assert.Equal("UDP", connectResult.UsedProtocol);
       Assert.True(sendResult.Success);  // ← 統合動作確認（初期は失敗）
       Assert.NotNull(receiveResult.Data);
   }
   ```

2. テスト実行 → **失敗（Red状態）**を確認

#### Step 4-Green: テストを通す実装

**作業内容:**
1. 既存の`SendFrameAsync()`, `ReceiveResponseAsync()`が代替プロトコルで接続したソケットでも正常動作することを確認
2. 必要に応じて修正
3. テスト実行 → **全テスト成功（Green状態）**

#### Step 4-Refactor: 統合テストの改善

**作業内容:**
1. テストケースの追加（UDP→TCP切替、両プロトコル失敗等）
2. モックの共通化・テストユーティリティ化
3. テスト実行 → **全テスト成功を維持**

---

### Phase 5: 実機検証とドキュメント更新

#### Step 5-Red: 実機テストシナリオ作成

**作業内容:**
1. 実機環境でのテストシナリオ文書作成:
   - TCP接続のみ許可する環境でのテスト手順
   - UDP接続のみ許可する環境でのテスト手順
   - ネットワーク遮断環境でのテスト手順

2. 期待結果の明確化（失敗基準の定義）

#### Step 5-Green: 実機検証実施

**作業内容:**
1. 実PLC環境でテストシナリオを実行
2. 問題があれば修正→テスト（Red-Greenサイクル繰り返し）
3. 全シナリオ成功を確認

#### Step 5-Refactor: ドキュメント整備

**作業内容:**
1. README更新: 自動プロトコル切り替え機能の説明追加
2. 運用ガイド更新: トラブルシューティング情報追加
3. コード内XMLコメント: 各メソッドのドキュメントコメント追加
4. 実装完了レビュー

## テストケース一覧（TDD順）

### Phase 1: ConnectionResponseモデル拡張テスト

| テストID | テスト名 | Red状態 | Green状態 | 検証内容 |
|---------|---------|---------|----------|---------|
| TC_P1_001 | UsedProtocol_初期TCP成功時_TCPを返す | コンパイルエラー | テスト成功 | UsedProtocolプロパティの存在と値 |
| TC_P1_002 | IsFallbackConnection_代替プロトコル使用時_Trueを返す | コンパイルエラー | テスト成功 | IsFallbackConnectionプロパティの存在と値 |
| TC_P1_003 | FallbackErrorDetails_初期プロトコル失敗時_エラー詳細を保持 | コンパイルエラー | テスト成功 | FallbackErrorDetailsプロパティの存在と値 |

### Phase 2: 接続ロジック実装テスト（PlcCommunicationManagerTests.cs）

| テストID | テスト名 | Red状態 | Green状態 | 検証内容 |
|---------|---------|---------|----------|---------|
| TC_P2_001 | ConnectAsync_初期TCP成功_TCPで接続しIsFallbackConnectionがFalse | Assert失敗 | テスト成功 | 初期プロトコル成功時の動作 |
| TC_P2_002 | ConnectAsync_初期UDP成功_UDPで接続しIsFallbackConnectionがFalse | Assert失敗 | テスト成功 | UDP初期プロトコル成功時の動作 |
| TC_P2_003 | ConnectAsync_TCP失敗UDP成功_UDPで接続しIsFallbackConnectionがTrue | Assert失敗 | テスト成功 | TCP→UDP代替プロトコル切替 |
| TC_P2_004 | ConnectAsync_UDP失敗TCP成功_TCPで接続しIsFallbackConnectionがTrue | Assert失敗 | テスト成功 | UDP→TCP代替プロトコル切替 |
| TC_P2_005 | ConnectAsync_両プロトコル失敗_失敗ステータスと詳細エラー | Assert失敗 | テスト成功 | 両プロトコル失敗時のエラー情報 |
| TC_P2_006 | ConnectAsync_タイムアウト処理_指定時間内に完了 | Assert失敗 | テスト成功 | タイムアウト設定の適用 |

### Phase 3: ログ出力実装テスト（PlcCommunicationManagerTests.cs）

| テストID | テスト名 | Red状態 | Green状態 | 検証内容 |
|---------|---------|---------|----------|---------|
| TC_P3_001 | ConnectAsync_初期プロトコル成功_接続開始ログのみ出力 | Verify失敗 | テスト成功 | 初期成功時のログ出力 |
| TC_P3_002 | ConnectAsync_代替プロトコル成功_警告ログと成功ログ出力 | Verify失敗 | テスト成功 | 代替成功時のログ出力 |
| TC_P3_003 | ConnectAsync_両プロトコル失敗_詳細エラーログ出力 | Verify失敗 | テスト成功 | 失敗時のログ出力 |

### Phase 4: 統合テスト（Step3_6_IntegrationTests.cs）

| テストID | テスト名 | Red状態 | Green状態 | 検証内容 |
|---------|---------|---------|----------|---------|
| TC_P4_001 | Integration_TCPからUDPへの自動切り替え_正常にデータ送受信 | Assert失敗 | テスト成功 | TCP→UDP切替での送受信動作 |
| TC_P4_002 | Integration_UDPからTCPへの自動切り替え_正常にデータ送受信 | Assert失敗 | テスト成功 | UDP→TCP切替での送受信動作 |
| TC_P4_003 | Integration_両プロトコル失敗_適切なエラーハンドリング | Assert失敗 | テスト成功 | 完全失敗時の統合動作 |

### Phase 5: 実機テスト

| テストID | テスト名 | テスト環境 | 期待結果 |
|---------|---------|----------|---------|
| TC_P5_001 | 実機_TCP接続のみ許可環境 | TCP許可/UDP拒否 | 初期TCPで接続成功 |
| TC_P5_002 | 実機_UDP接続のみ許可環境 | TCP拒否/UDP許可 | TCP失敗→UDP切替成功 |
| TC_P5_003 | 実機_ネットワーク遮断環境 | 全プロトコル拒否 | 両プロトコル失敗、適切なエラーメッセージ |

## リスクと対策

### リスク1: タイムアウト時間の倍増
**内容:** 両プロトコル試行により、接続確立までの最大時間が2倍になる

**対策:**
- 初期プロトコルの選択を適切に行う（環境に応じた推奨設定のドキュメント化）
- タイムアウト値を適切に設定（デフォルト5秒 = 最大10秒）
- 将来的に並行試行の検討（オプション機能として）

### リスク2: ログの増加
**内容:** 代替プロトコルでの接続が常態化した場合、警告ログが大量に出力される

**対策:**
- 初回警告後は定期的な警告のみ出力（例: 1時間ごと）
- 設定ファイルの修正を促すメッセージを出力
- ログレベルによる出力制御

### リスク3: PLC側の負荷
**内容:** 複数プロトコルでの接続試行がPLCに負荷をかける可能性

**対策:**
- 接続試行間に適切な待機時間を設ける（オプション）
- PLC側の接続ログを確認し、問題がないことを検証

## 今後の拡張案

### 拡張1: 並行試行モード（オプション）
両プロトコルを同時に試行し、先に成功した方を使用する。接続時間を短縮できるが、実装複雑度が増加する。

### 拡張2: 成功プロトコルの記憶
前回成功したプロトコルを記憶し、次回接続時に優先的に使用する。設定ファイルへの自動反映も検討。

### 拡張3: プロトコル切り替え通知
代替プロトコルで接続した場合、外部システムへの通知機能（メール、Slack等）。

## 実装スケジュール（TDD順、想定工数）

| Phase | ステップ | 作業内容 | 想定工数 | 備考 |
|-------|---------|---------|---------|------|
| **Phase 1** | **Red** | ConnectionResponseテスト作成（失敗状態） | 0.5h | コンパイルエラー確認 |
|  | **Green** | ConnectionResponseに新規プロパティ追加 | 0.3h | テスト成功確認 |
|  | **Refactor** | XMLコメント追加・妥当性確認 | 0.2h | テスト成功維持 |
| | **小計** | | **1h** | |
| **Phase 2** | **Red** | ConnectAsyncテスト作成（失敗状態） | 1h | Assert失敗確認 |
|  | **Green** | 代替プロトコル試行ロジック実装 | 1.5h | テスト成功確認 |
|  | **Refactor** | 重複コード削除・メッセージ統一 | 0.5h | テスト成功維持 |
| | **小計** | | **3h** | |
| **Phase 3** | **Red** | ログ出力検証テスト作成（失敗状態） | 0.5h | Verify失敗確認 |
|  | **Green** | ログ出力実装 | 0.3h | テスト成功確認 |
|  | **Refactor** | ログメッセージ集約・メソッド分離 | 0.2h | テスト成功維持 |
| | **小計** | | **1h** | |
| **Phase 4** | **Red** | 統合テスト作成（失敗状態） | 0.5h | Assert失敗確認 |
|  | **Green** | 統合動作確認・必要に応じて修正 | 1h | テスト成功確認 |
|  | **Refactor** | テストケース追加・モック共通化 | 0.5h | テスト成功維持 |
| | **小計** | | **2h** | |
| **Phase 5** | **Red** | 実機テストシナリオ作成 | 0.3h | 失敗基準明確化 |
|  | **Green** | 実機検証実施・修正 | 0.5h | 全シナリオ成功 |
|  | **Refactor** | ドキュメント整備 | 0.2h | 実装完了レビュー |
| | **小計** | | **1h** | |
| **合計** | | | **8h** | 各Phase後にテスト成功を確認 |

**注意事項:**
- 各PhaseでRed→Green→Refactorサイクルを厳守
- Greenステップ完了時点でテスト成功を必ず確認
- Refactorステップでテスト成功が維持されることを確認
- 次のPhaseに進む前に、現在のPhaseの全テストが成功していることを確認

## 参考情報

### 関連ドキュメント
- `documents/design/クラス設計.md`: PlcCommunicationManagerの詳細設計
- `documents/design/エラーハンドリング.md`: エラー処理方針
- `documents/design/ログ機能設計.md`: ログ出力仕様
- `documents/design/step1-3テスト/実装計画/Phase4_JSON廃止計画.md`: JSON廃止・Excel専用システム移行計画
- `documents/design/Step1_設定ファイル読み込み実装/実装計画/00_実装フェーズ概要.md`: Step1実装フェーズ概要
- `documents/design/ハードコード実装置き換え対応/ハードコード状況確認.md`: ハードコード値の調査結果

### 関連テストケース
- `Tests/Unit/Core/Managers/PlcCommunicationManagerTests.cs`
- `Tests/Integration/Step3_6_IntegrationTests.cs`

## 承認・レビュー

| 項目 | 担当者 | 日付 | ステータス |
|-----|-------|------|----------|
| 設計レビュー | - | - | 未実施 |
| 実装レビュー | - | - | 未実施 |
| テストレビュー | - | - | 未実施 |
| 最終承認 | - | - | 未実施 |

---

## 📊 現在の実装状況（2025-11-28確認）

### ❌ **実装状況サマリー: 未実装（Phase 0）**

本実装計画に記載されている通信プロトコル自動切り替え機能は、**現時点で実装されていません**。

**TDD進行状況:**
- **現在のPhase**: Phase 0（実装開始前）
- **次のステップ**: Phase 1-Red（ConnectionResponseモデルの失敗テストを作成）
- **次に書くべきテスト**:
  1. `UsedProtocol_初期TCP成功時_TCPを返す()` テスト
  2. `IsFallbackConnection_代替プロトコル使用時_Trueを返す()` テスト
  3. `FallbackErrorDetails_初期プロトコル失敗時_エラー詳細を保持()` テスト

### ⚠️ **重要な前提条件の変更（2025-11-28）**

**設定ファイル形式の変更:**
- **JSON形式**: Phase4_JSON廃止計画により廃止
- **Excel形式**: 現在の標準設定ファイル形式
- 本実装計画はExcel形式を前提として更新されています

**関連実装状況:**
- ✅ PlcConfiguration（Excel専用モデル）: 実装済み
- ✅ ConfigurationLoaderExcel（Excel読み込み機能）: 実装済み
- ✅ Excel設定ファイルからの基本接続設定読み込み: 実装済み

---

### 🔍 **詳細確認結果**

#### 1. ConnectionResponseモデルの実装状況

**ファイル:** `andon/Core/Models/ConnectionResponse.cs`

**本文書で計画されている仕様 (行82-90):**
```csharp
public class ConnectionResponse
{
    public bool Success { get; set; }
    public ConnectionType UsedConnectionType { get; set; }  // ★実際に使用されたプロトコル
    public bool IsFallbackConnection { get; set; }          // ★代替プロトコルで接続したか
    public string Message { get; set; }
    public DateTime ConnectedAt { get; set; }
    public string ErrorDetails { get; set; }                // ★エラー詳細（両方失敗時）
}
```

**注意事項:**
1. **設定情報の変換フロー**:
   - Excel設定ファイル → `PlcConfiguration` → **変換処理** → `ConnectionConfig`
   - `PlcConfiguration.ConnectionMethod` (string: "TCP"/"UDP") → `ConnectionConfig.UseTcp` (bool)
   - 変換処理は別途実装が必要

2. **タイムアウト設定の変換**:
   - `PlcConfiguration.Timeout` (int: ミリ秒) → `TimeoutConfig.ConnectTimeoutMs` (int)
   - `TimeoutConfig`には他に`SendTimeoutMs`, `ReceiveTimeoutMs`も存在

**実際の実装状況:**
```csharp
// 現在実装されているConnectionResponse
public class ConnectionResponse
{
    public required ConnectionStatus Status { get; init; }
    public Socket? Socket { get; init; }
    public DateTime? ConnectedAt { get; init; }
    public double? ConnectionTime { get; init; }
    public string? ErrorMessage { get; init; }
}
```

**不足プロパティ（通信プロトコル自動切り替え機能実装時に追加予定）:**
- ❌ `UsedProtocol` (string? - 実際に使用されたプロトコル: "TCP"/"UDP") - **未実装**
- ❌ `IsFallbackConnection` (bool - 代替プロトコルで接続したか) - **未実装**
- ❌ `FallbackErrorDetails` (string? - 初期プロトコル失敗時のエラー詳細) - **未実装**

**既存プロパティ（実装済み）:**
- ✅ `Status` (ConnectionStatus列挙型 - Connected/Failed/Timeout)
- ✅ `Socket` (Socket? - ソケットインスタンス)
- ✅ `ConnectedAt` (DateTime? - 接続完了時刻)
- ✅ `ConnectionTime` (double? - 接続所要時間ミリ秒)
- ✅ `ErrorMessage` (string? - エラーメッセージ)

---

#### 2. ConnectAsyncメソッドの実装状況

**ファイル:** `andon/Core/Managers/PlcCommunicationManager.cs` (行82-377)

**本文書で計画されている機能 (行46-61):**
```
初期プロトコルで接続試行
  ↓ 失敗
代替プロトコルで接続試行
  ↓ 失敗
両プロトコル失敗を記録して返却
```

**実際の実装状況:**
- ✅ 初期プロトコル（TCP/UDP）での接続試行は実装済み
- ✅ タイムアウト処理は実装済み
- ✅ 例外処理（SocketException, TimeoutException等）は実装済み
- ❌ **代替プロトコルでの再試行ロジックは未実装**
- ❌ **両プロトコル失敗時のエラー詳細記録は未実装**

**実装されている処理フロー（現状）:**
```
初期プロトコル（ConnectionConfig.UseTcpフラグに基づく）で接続試行
  ↓ 成功
ConnectionResponse返却（Status=ConnectionStatus.Connected, Socket設定済み）
  ↓ 失敗
例外スロー（TimeoutException/SocketException/PlcConnectionException等）
→ 処理終了
```

→ **代替プロトコルへのフォールバック処理が存在しない**

**注意**:
- 現在の実装は`ConnectionConfig`を使用（`PlcConfiguration`は直接使用していない）
- `ConnectionConfig`は`PlcConfiguration`から変換して作成される

---

#### 3. 内部ヘルパーメソッドの実装状況

**本文書で計画されている内部メソッド (行257-258):**
- `GetAlternativeProtocol(bool useTcp)` - ❌ **未実装**
  - 引数: bool型（true=TCP, false=UDP）
  - 戻り値: string型（"TCP"または"UDP"）
- `TryConnectWithProtocolAsync(bool useTcp, int timeoutMs)` - ❌ **未実装**
  - 引数: プロトコル指定（bool）とタイムアウト（ミリ秒）
  - 戻り値: Task<ConnectionResponse>

**確認結果:**
- `PlcCommunicationManager.cs` 内に該当メソッドは存在しない
- 現在の`ConnectAsync()`メソッドは初期プロトコルでの接続試行のみ実装

---

#### 4. ログ出力の実装状況

**本文書で計画されているログ出力 (行113-133):**
- 接続試行開始ログ
- 初期プロトコル失敗時の警告ログ
- 代替プロトコル成功時の情報ログ
- 両プロトコル失敗時のエラーログ

**実際の実装状況:**
```csharp
// [TODO: ログ出力] 接続開始
// LoggingManager: $"PLC接続開始 - IP:{_connectionConfig.IpAddress}, ..."

// [TODO: ログ出力] タイムアウト設定
// LoggingManager: $"Socketタイムアウト設定 - ..."

// [TODO: ログ出力] 接続完了
// LoggingManager: $"PLC接続完了 - 接続時間:{connectionTime:F2}ms, ..."
```

→ **全てTODOコメントのみで、実際のログ出力実装なし**

---

### 🔧 **設定情報の変換について**

**重要: PlcConfigurationとConnectionConfigの役割分担**

**PlcConfiguration** (Excel読み込み専用):
- Excel設定ファイルから読み込んだ全設定情報を保持
- プロパティ例:
  - `IpAddress` (string)
  - `Port` (int)
  - `ConnectionMethod` (string: "TCP"/"UDP")
  - `Timeout` (int: ミリ秒)
  - `FrameVersion` (string: "3E"/"4E")
  - `IsBinary` (bool)
  - `MonitoringIntervalMs` (int)
  - `Devices` (List<DeviceSpecification>)

**ConnectionConfig** (PLC通信専用):
- PLC通信時に使用する接続設定のみを保持
- プロパティ例:
  - `IpAddress` (string)
  - `Port` (int)
  - `UseTcp` (bool: TCP使用フラグ)
  - `ConnectionType` (string計算プロパティ: "TCP"/"UDP")
  - `IsBinary` (bool)
  - `FrameVersion` (FrameVersion列挙型: Frame3E/Frame4E)

**TimeoutConfig** (タイムアウト設定専用):
- プロパティ例:
  - `ConnectTimeoutMs` (int)
  - `SendTimeoutMs` (int)
  - `ReceiveTimeoutMs` (int)

**変換フロー:**
```
Excel設定ファイル (*.xlsx)
  ↓ ConfigurationLoaderExcel.LoadFromExcel()
PlcConfiguration
  ↓ ★変換処理（未実装）
ConnectionConfig + TimeoutConfig
  ↓ PlcCommunicationManagerコンストラクタ
PlcCommunicationManager
```

→ **PlcConfigurationからConnectionConfig/TimeoutConfigへの変換処理が必要**

---

### 📋 **実装に必要な作業**

**Phase 1: ConnectionResponseモデル拡張**

1. `ConnectionResponse`クラスに以下のプロパティを追加:
   ```csharp
   public string? UsedProtocol { get; init; }          // "TCP"/"UDP"
   public bool IsFallbackConnection { get; init; }     // 代替プロトコルで接続したか
   public string? FallbackErrorDetails { get; init; }  // 初期プロトコル失敗時のエラー詳細
   ```

2. 既存プロパティは変更せず維持:
   - `Status`, `Socket`, `ConnectedAt`, `ConnectionTime`, `ErrorMessage`

**Phase 2: PlcCommunicationManager拡張**

1. 内部ヘルパーメソッド実装（privateメソッド）:
   ```csharp
   private string GetAlternativeProtocol(bool useTcp)
   private async Task<ConnectionResponse> TryConnectWithProtocolAsync(bool useTcp, int timeoutMs)
   ```

2. `ConnectAsync()`メソッドを拡張:
   - 初期プロトコル（`ConnectionConfig.UseTcp`）で接続試行
   - 失敗時に代替プロトコルで再試行
   - 新規プロパティ（`UsedProtocol`, `IsFallbackConnection`, `FallbackErrorDetails`）を適切に設定

**Phase 3: ログ出力実装**

- 現在TODOコメントになっている箇所を実装:
  - 接続開始ログ
  - 初期プロトコル失敗時の警告ログ
  - 代替プロトコル成功時の情報ログ
  - 両プロトコル失敗時のエラーログ

---

### ⚠️ **実装前の確認事項**

1. **PlcConfiguration → ConnectionConfig変換処理の確認**
   - 変換処理が実装されているか確認
   - 未実装の場合は先に実装が必要

2. **既存テストへの影響確認**
   - `ConnectionResponse`に新規プロパティを追加するため、既存テストの修正が必要
   - `PlcCommunicationManagerTests.cs`の更新

3. **呼び出し側への影響確認**
   - `ExecutionOrchestrator`等、`ConnectAsync()`を呼び出している箇所の確認
   - 新規プロパティ（`UsedProtocol`, `IsFallbackConnection`）の利用方法を検討

---

### 📝 **次のアクション（TDD手順）**

#### ステップ1: Phase 1-Red開始
1. `ConnectionResponseTests.cs`を開く
2. 以下の3つの**失敗するテスト**を作成:
   - `UsedProtocol_初期TCP成功時_TCPを返す()`
   - `IsFallbackConnection_代替プロトコル使用時_Trueを返す()`
   - `FallbackErrorDetails_初期プロトコル失敗時_エラー詳細を保持()`
3. テスト実行 → **コンパイルエラー（Red状態）を確認**

#### ステップ2: Phase 1-Green
1. `ConnectionResponse.cs`に新規プロパティを追加
2. テスト実行 → **全テスト成功（Green状態）を確認**

#### ステップ3: Phase 1-Refactor
1. XMLコメント追加・妥当性確認
2. テスト実行 → **全テスト成功を維持**

#### ステップ4: Phase 2以降
Phase 1完了後、Phase 2-Redに進む（実装手順セクション参照）

**注意事項:**
- **テストファースト原則を厳守**: 実装前に必ず失敗するテストを書く
- **小さなステップ**: 各Phaseを完了してから次に進む
- **常にテスト成功を維持**: Refactorステップでテストが壊れていないことを確認
- PlcConfiguration → ConnectionConfig/TimeoutConfigの変換処理が未実装の場合は先に対応が必要
- 既存の`ConnectionResponse`を使用しているコードへの影響を確認
