ここに記載されているステップNo.はC:\Users\1010821\Desktop\python\andon\documents\design\データ取得動作流れ\アプリケーション動作フロー.mdのステップと紐づく

---

# 📋 実装優先順位

実装は以下の優先順位で進めます。各クラスの詳細仕様は後続のセクションを参照してください。

1. **PlcCommunicationManager** (Step3-6) - 最優先
   - PLC通信・データ送受信機能
   - Random READ(0x0403)コマンド対応
   - レスポンス処理・データ解析

2. **LoggingManager** (ログ機能)
   - SLMP通信可視化
   - デバッグ・トラブルシューティング支援
   - パフォーマンス分析

3. **ErrorHandler** (エラーハンドリング)
   - エラー分類判定・記録
   - リトライ方針適用
   - バランス型例外設計

4. **ResourceManager** (メモリ・リソース管理)
   - メモリ使用量監視
   - リソース最適化実行
   - レベル判定・ポリシー適用

5. **ConfigToFrameManager** (Step1-2)
   - 設定ファイル読み込み
   - フレーム構築（3E/4E、Binary/ASCII）
   - 複数設定ファイル対応

6. **DataOutputManager** (Step7)
   - 解析後データ出力
   - データ保存機能

---

# 🔄 最新仕様（2025-11-20更新）

## Random READコマンドによる全デバイス一括取得

### 重要な発見
SLMP仕様書（pdf2img/page_53-55）の詳細確認により、**Random READコマンド（0403）が1回の送信でビット・ワード・ダブルワード全てを混在指定可能**であることが判明しました。

### 新しい通信方式

```
【送信1】全デバイス一括取得（M000-M999、D000-D999）
  コマンド: Random READ（0403）
  サブコマンド: 0000（ビット・ワード・ダブルワード全対応）
  デバイス指定: 各デバイスごとにワード数を個別指定
    例: M000（ビット）、M001（ビット）、...、M999（ビット）
        D000（1ワード）、D001（1ワード）、D002（2ワード=DWord）、D004（1ワード）...

  → PLCが自動的に指定通りのビット/ワード数で読み取って返す
  → 送受信1回のみで全デバイスデータ取得完了
  → アプリケーション側でのDWord分割・結合処理が不要
  → 応答データの統合処理も不要
```

### 設計への影響

#### ✅ 簡素化される処理

1. **Step3（旧：DWord分割処理）→ 削除**
   - `SplitDwordToWord()`メソッドは不要
   - Random READ用のデバイス指定リスト生成のみ

2. **Step4-5（旧：2回送受信）→ 1回送受信**
   - READコマンド(0401)廃止
   - Random READコマンド(0403)のみ使用
   - 送受信回数: 2回 → 1回

3. **Step6-2（旧：応答統合処理）→ 削除**
   - 複数応答の統合処理が不要
   - ProcessReceivedRawData()の結果をそのまま使用

4. **ProcessedDeviceRequestInfo構造変更**
   - DWord分割情報（SplitRanges等）不要
   - Random READ用デバイス指定情報に変更
   - ビット/ワード機器の区別が不要

#### 📋 実装方針

```
Step2: フレーム生成
  └─ フレーム1: Random READコマンド（全デバイス指定）
                ↑ 各デバイスのビット/ワード数を設定ファイルで指定

Step4-5: 1回送受信
  └─ 送信1: 全デバイスフレーム → 応答1（全デバイスデータ）

Step6: データ処理
  ├─ Step6-1: 応答1パース（ビット・ワード・ダブルワード混在データ）← 既にDWord形式
  └─ Step6-2: 構造化変換（統合処理不要）
```

---

◆クラス・メソッド設計（最新仕様）
- Step1,Step2
機能概要：設定ファイル読み込み/フレーム作成（複数設定ファイル対応）
詳細機能：
    ・複数設定ファイル(xlsx形式)読み込み/共有データ管理機能
        - データ取得元：外部設定ファイル群（*_settings.xlsx, UTF-8形式）
        - アーキテクチャ：共有データ + 軽量インスタンス
    ・単一設定ファイル読み込み/読み込み内容保持機能（既存機能保持）
        - データ取得元：外部設定ファイル（appsettings.xlsx, UTF-8形式）
    ・設定値to各種フレーム作成機能(3E/4E,ASCII/binary)
        - データ取得元：ConfigToFrameManager.LoadConfigAsync()（接続設定・デバイス設定）
クラス：ConfigToFrameManager, MultiConfigManager
メソッド：
    ・LoadConfigAsync（Step1: 単一設定ファイル読み込み - 既存機能保持）
        - Input:
            - configFileName（string型、デフォルト："appsettings.xlsx"）
            - 設定ソース（appsettings.xlsx, UTF-8：外部設定ファイルから取得）
        - Output:
            - ConnectionConfig（IpAddress, Port, UseTcp, ConnectionType, IsBinary, FrameVersion）
            - TimeoutConfig（ConnectTimeoutMs, SendTimeoutMs, ReceiveTimeoutMs, RetryTimeoutMs）
            - TargetDeviceConfig（MDeviceRange, DDeviceRange）
            - MonitoringIntervalMs（データ収集周期）
            - SystemResourcesConfig（MemoryLimitKB, MaxBufferSize, MemoryThresholdKB, LowMemoryMode）
            - DataProcessingConfig（TargetName, ContinuousDataMode, DataRetentionDays）
            - LoggingConfig（ConsoleOutput, DetailedLog）
            - DataTransferConfig（EnableTransfer, DestinationIpAddress, DestinationPort）
            - ActualConfigPath（string型、実際に読み込んだファイルパス）
        - データ取得元：外部設定ファイル（configFileName指定, UTF-8形式）
        - パス解決順序：./config/[fileName] → ./[fileName] → 環境変数ANDON_CONFIG_PATH

    ・LoadAllConfigsAsync（複数設定ファイル読み込み）
        - Input:
            - configDirectory（string型、デフォルト："./config/"）
            - filePattern（string型、デフォルト："*_settings.xlsx"）
        - Output:
            - Dictionary<string, ConfigData>（ファイル名キーの設定データ辞書）
            - LoadedConfigPaths（string[]型、実際に読み込んだファイルパス一覧）
        - データ取得元：指定ディレクトリ内の複数設定ファイル（*_settings.xlsx, UTF-8形式）
        - 処理方式：共有データ領域への一括読み込み

    ・GetConfig（設定内容取得 - 単一インスタンス用）
        - Input:
            - 設定タイプ指定（ジェネリック型パラメータT、または設定種別指定）
            - configFileName（string型、オプション：軽量インスタンス用）
        - Output:
            - 指定設定オブジェクト（LoadConfigAsync/共有データから取得）
                - ConnectionConfig（IpAddress, Port, UseTcp, ConnectionType, IsBinary, FrameVersion）
                - TimeoutConfig（ConnectTimeoutMs, SendTimeoutMs, ReceiveTimeoutMs, RetryTimeoutMs）
                - TargetDeviceConfig（MDeviceRange, DDeviceRange）
                - MonitoringIntervalMs（データ収集周期）
                - SystemResourcesConfig（MemoryLimitKB, MaxBufferSize, MemoryThresholdKB, LowMemoryMode）
                - DataProcessingConfig（TargetName, ContinuousDataMode, DataRetentionDays）
                - LoggingConfig（ConsoleOutput, DetailedLog）
                - DataTransferConfig（EnableTransfer, DestinationIpAddress, DestinationPort）
        - データ取得元：ConfigToFrameManager.LoadConfigAsync()（単一）/ SharedConfigData（複数）

    ・PrepareDeviceRequestInfo（Step2-1: デバイス要求情報準備・Random READ用デバイスリスト生成）
        - Input:
            - TargetDeviceConfig（MDeviceRange, DDeviceRange, DataType：ConfigToFrameManager.LoadConfigAsync()から取得）
        - Output:
            - デバイス要求情報（Random READ用デバイス指定リスト）
            - ProcessedDeviceRequestInfo（RandomReadDeviceList）
        - 処理内容:
            【全デバイスをRandom READ用リストに統合】
            - 設定ファイルから各デバイスのビット/ワード数情報を取得
            - 全デバイス（ビット・ワード・ダブルワード）を単一リストに統合
            - Random READフレーム用のデバイス指定リストを作成
        - 処理例:
            - M000-999（ビット機器）+ D000-999（ワード機器）→ RandomReadDeviceList: [
                {DeviceCode: "90", DeviceNumber: 0, WordCount: 0},     // M000（ビット）
                {DeviceCode: "90", DeviceNumber: 1, WordCount: 0},     // M001（ビット）
                ...
                {DeviceCode: "90", DeviceNumber: 999, WordCount: 0},   // M999（ビット）
                {DeviceCode: "A8", DeviceNumber: 0, WordCount: 1},     // D000（1ワード）
                {DeviceCode: "A8", DeviceNumber: 1, WordCount: 1},     // D001（1ワード）
                {DeviceCode: "A8", DeviceNumber: 2, WordCount: 2},     // D002（2ワード=DWord）
                {DeviceCode: "A8", DeviceNumber: 4, WordCount: 1},     // D004（1ワード）
                ...
              ]
            ※ WordCount=0はビットデバイスを示す
        - データ取得元：ConfigToFrameManager.LoadConfigAsync()（デバイス設定）、SLMP仕様書（Random READ仕様）

    ・BuildFrames（Step2-2: 通信フレーム構築・Random READ専用）
        - Input:
            - ConnectionConfig（IpAddress, Port, UseTcp, ConnectionType, IsBinary, FrameVersion：ConfigToFrameManager.LoadConfigAsync()から取得）
            - ProcessedDeviceRequestInfo（デバイス要求情報：ConfigToFrameManager.PrepareDeviceRequestInfo()から取得）
                - RandomReadDeviceList（Random READ用デバイス指定リスト：全デバイス統合済み）
        - Output:
            - 生成したSLMPフレーム（16進数文字列、1つのフレーム）
            - **🔧 実機テスト設定フレーム例（4Eフレーム/ASCII、M000-M999/D000-D999一括取得）**:
                - **フレーム1: 全デバイス一括読み出し（Random READ）**:
                  - コマンド: Random READ（0403）
                  - サブコマンド: 0000（ビット・ワード・ダブルワード全対応）
                  - バイナリ形式（参考）: `54 00 12 34 00 00 00 [データ長]  04 03 00 00  [ビット点数] [ワード点数] [ダブルワード点数] [デバイス指定リスト]`
                  - デバイス指定例:
                    ```
                    ビットアクセス点数: 03E8（1000点 = M000-M999）
                    ワードアクセス点数: 0003（3点）
                    ダブルワードアクセス点数: 0001（1点）
                    ビットデバイス1: 90 00 00 00 00（M000）
                    ビットデバイス2: 90 00 01 00 00（M001）
                    ... (M000-M999まで)
                    ワードデバイス1: A8 00 00 00 00（D000、1ワード）
                    ワードデバイス2: A8 00 01 00 00（D001、1ワード）
                    ワードデバイス3: A8 00 04 00 00（D004、1ワード）
                    ダブルワードデバイス1: A8 00 02 00 00（D002、2ワード=DWord）
                    ```
                  - 構成: サブヘッダ(4E) + Random READコマンド(0403) + サブコマンド(0000) + ビット点数 + ワード点数 + ダブルワード点数 + 各デバイス指定（デバイスコード + デバイス番号 + ワード数）
        - 構築コマンド：
            - Random READコマンド(0403)のみ: 全デバイス（ビット・ワード・ダブルワード）一括取得
        - 対象機器：全機器をRandom READで処理
            - ビット機器（M, X, Y, L, F, V, B, TS, TC）: WordCount=0で指定
            - ワード機器（D, W, SD, TN）: WordCount=1または2で指定
        - 最適化効果：
            - **DWord分割・結合処理完全削除**（Random READが自動処理）
            - **応答データ統合処理不要**（1回の受信で全デバイス取得完了）
            - 設定ファイルから直接Random READフレーム生成
            - 通信回数最小化（1回のみ）
            - 処理ステップ大幅簡素化
        - **ASCII変換規則（実機テスト設定）**:
            - 各バイトを2文字の16進数ASCII文字列に変換
            - 例: `54H` → `"35"(5) + "34"(4)` → `"3534"`
            - データ量: バイナリの2倍（通信時間・帯域幅に注意）
        - **データ長計算方式の設計選択**:
            - **送信時**: 設定ファイルから取得したデバイス点数を使用してフレームを構築
                - 方式: 事前設定方式（設定ファイルのデバイス範囲情報を使用）
                - 例: MDeviceRange="M000-M999" → 1000点として要求フレーム生成
            - **受信時**: 受信フレームのヘッダーから`length`フィールドを動的に読み取る（**推奨方式**）
                - 方式: フレーム解析方式（PySLMPClient準拠の真の動的計算）
                - Binary形式: 9バイト目から2バイトのlengthフィールド（リトルエンディアン）
                  ```
                  レスポンスフレーム構造:
                  [サブヘッダ(2B)] [シーケンス(2B)] [予約(2B)] [ネットワーク情報(5B)] [Length(2B)] [終了コード(2B)] [データ部(Length-2B)]
                                                                                          ^^^^^^^^
                                                                                    ここから長さを読み取る
                  ```
                - ASCII形式: 10-13文字目の4文字の16進数文字列
                  ```
                  レスポンスフレーム構造（ASCII）:
                  "D400" [8文字] [18文字] [4文字(Length)] [4文字(終了コード)] [データ部]
                                          ^^^^^^^^^^^^^^
                                      ここから長さを読み取る（16進数4桁）
                  ```
                - **実装メリット**:
                  1. 設定不要: フレーム自体に含まれる長さ情報を使用
                  2. 可変長対応: PLCが返す実際のデータ長に自動対応
                  3. 堅牢性: 設定ミスによるデータ切り捨て/読み過ぎを防止
                  4. 汎用性: 様々なPLC機種・設定に柔軟に対応
            - **参考: 他方式との比較**:
                - 事前設定方式（ConMoni等）: 設定ファイルの点数情報を受信時にも使用
                  - 問題点: 設定と実際の応答が異なる場合にエラーが発生
                  - 柔軟性: 低（設定変更が必要）
                - **本実装採用方式**: フレームヘッダーのlengthフィールドを使用（PySLMPClient準拠）
                  - 利点: 堅牢性・保守性が高い、設定ミスの影響を受けにくい
                  - 柔軟性: 高（自動対応）
        - データ取得元：ConfigToFrameManager.LoadConfigAsync()（接続設定）、ConfigToFrameManager.PrepareDeviceRequestInfo()（デバイス要求情報）、SLMP仕様書（Random READ仕様：pdf2img/page_53-55、レスポンスフレーム構造：pdf2img/page_20-23）

クラス：MultiConfigManager
機能概要：複数設定ファイルの統合管理、共有データ + 軽量インスタンス アーキテクチャ実装
メソッド：
    ・LoadAllFromDirectoryAsync（複数設定ファイル一括読み込み）
        - Input:
            - configDirectory（string型、デフォルト："./config/"）
            - filePattern（string型、デフォルト："*_settings.xlsx"）
            - allowPartialSuccess（bool型、デフォルト：true）
        - Output:
            - Dictionary<string, ConfigToFrameManager>（ファイル名キーの軽量インスタンス辞書）
            - LoadResult（LoadedFiles, FailedFiles, TotalLoadTime）
        - データ取得元：指定ディレクトリ内の複数設定ファイル（*_settings.xlsx, UTF-8形式）
        - 処理方式：設定データを静的共有領域に保存、各ファイル用の軽量インスタンス生成

    ・CreateManagersAsync（軽量インスタンス生成）
        - Input:
            - configFileNames（string[]型：対象設定ファイル名一覧）
        - Output:
            - ConfigToFrameManager[]（軽量インスタンス配列）
        - データ取得元：SharedConfigData（静的共有領域）
        - 動作：共有データを参照する軽量インスタンスを効率的に生成

    ・GetSharedConfigData（共有データアクセス）
        - Input:
            - configFileName（string型：対象設定ファイル名）
        - Output:
            - ConfigDataSet（指定ファイルの設定データ）
        - データ取得元：SharedConfigData（静的共有領域）
        - メモリ効率：設定データ実体の共有によりメモリ使用量最小化

    ・ReleaseSharedData（共有データ解放）
        - Input:
            - configFileName（string型、オプション：特定ファイル or 全体）
        - Output:
            - ReleasedMemoryKB（解放されたメモリ量）
        - 動作：明示的なメモリ解放（長時間稼働時の最適化）


- Step3-6
機能概要：PLCとの通信接続,切断/データ送受信/データ解析
詳細機能：
    ・PLC通信機能(非同期, 接続/切断)
        - データ取得元：ConfigToFrameManager.LoadConfigAsync()（接続設定）、PlcCommunicationManager.ConnectAsync()（接続状態）
    ・フレーム情報送信機能（1回送信）
        - データ取得元：ConfigToFrameManager.BuildFrames()（送信フレーム）、PlcCommunicationManager.ConnectAsync()（接続状態）
        - 送信コマンド：
            - フレーム1: Random READコマンド(0403)による全デバイス（ビット・ワード・ダブルワード）一括取得
    ・レスポンス受信機能（1回受信）
        - データ取得元：PlcCommunicationManager.SendFrameAsync()（送信完了状態）、ConfigToFrameManager.LoadConfigAsync()（タイムアウト設定）
        - 受信データ：
            - 応答1: 全デバイスデータ（ビット・ワード・ダブルワード混在、Random READ応答、既にDWord形式）
    ・生データ(16進数)to構造化データ変換機能（2段階処理）
        - Step6-1 基本後処理：PlcCommunicationManager.ProcessReceivedRawData()（16進数パース・基本型変換、1回実行）
        - Step6-2 構造化変換：PlcCommunicationManager.ParseRawToStructuredData()（SLMP構造化解析）
        - データ取得元：PlcCommunicationManager.ReceiveResponseAsync()（受信生データ）、ConfigToFrameManager.PrepareDeviceRequestInfo()（デバイス要求情報）
        - 変換対象：Random READレスポンス（ビット・ワード・ダブルワード混在データ）の段階的構造化
        - **応答統合処理不要**：1回の受信で全デバイスデータ取得完了のため
クラス：PlcCommunicationManager
メソッド：
    ・ConnectAsync（Step3: PLC接続処理）
        - Input:
            - ConnectionConfig（IpAddress, Port, UseTcp, ConnectionType：ConfigToFrameManager.LoadConfigAsync()から取得）
                - ConnectionType：string型計算プロパティ、ログ出力・可読性用の文字列表現（"TCP", "UDP"）、実際の接続判定はUseTcp（bool型）を使用
            - TimeoutConfig（ConnectTimeoutMs, SendTimeoutMs, ReceiveTimeoutMs：ConfigToFrameManager.LoadConfigAsync()から取得）
        - Output:
            - 成功時：ConnectionResponse（接続処理結果オブジェクト）
                - Status（ConnectionStatus型、必須）: Connected
                - Socket（System.Net.Sockets.Socket型、null許容）: 実際の通信用ソケット（成功時のみ）
                - RemoteEndPoint（System.Net.EndPoint型、null許容）: 接続先情報（成功時のみ）
                - ConnectedAt（DateTime型、null許容）: 接続完了時刻（成功時のみ）
                - ConnectionTime（TimeSpan型、null許容）: 接続処理にかかった時間（成功時のみ）
                - ErrorMessage=null（成功時はnull）
                - UsedProtocol（string型、null許容）: 実際に使用されたプロトコル（"TCP"/"UDP"、通信形式スイッチトライ機能で追加予定）
                - IsFallbackConnection（bool型、必須）: 代替プロトコルで接続したか（通信形式スイッチトライ機能で追加予定）
                - FallbackErrorDetails（string型、null許容）: 初期プロトコル失敗時のエラー詳細（通信形式スイッチトライ機能で追加予定）
            - 失敗時：例外スロー
                - TimeoutException：接続タイムアウト時
                - SocketException：接続拒否、ネットワークエラー時
                - ArgumentException：不正なIPアドレス・ポート番号時
                - InvalidOperationException：既に接続済み状態での再接続試行時
        - 処理フロー:
            1. 接続状態チェック（既接続時はInvalidOperationExceptionスロー）
            2. ソケット作成（Socket インスタンス生成、UDP/TCP選択）
            3. 接続実行:
                - TCP：Socket.ConnectAsync、ConnectTimeoutMs適用
                - UDP：Socket.Connect（送信先設定）+ TC021フレーム疎通確認（TDD・オフライン対応）
                    - M000-M999読み込みフレーム（"54001234000000010401006400000090E8030000"）を送信
                      または D000-D999読み込みフレーム（"54001234000000010400A800000090E8030000"）を送信
                    - ConnectTimeoutMs内に応答受信確認（本番：実PLC、テスト：モック応答）
                    - 応答なし→TimeoutExceptionスロー
            4. 接続成功判定:
                - 成功 → 5へ進む
                - 失敗/タイムアウト → 例外スロー（TimeoutException, SocketException等）
            5. ソケットタイムアウト設定:
                - Socket.SendTimeout = SendTimeoutMs（送信タイムアウト設定）
                - Socket.ReceiveTimeout = ReceiveTimeoutMs（受信タイムアウト設定）
            6. 接続情報記録:
                - ConnectedAt（接続時刻記録）
                - ConnectionTime（接続所要時間計算）
                - RemoteEndPoint（接続先情報保存）
            7. ConnectionResponse返却:
                - Status = Connected
                - Socket（設定済みソケットインスタンス）
                - その他接続情報
        - 設計方針:
            - **エラーハンドリング**：例外スロー方式採用（.NET標準、エラー処理の強制力が高い）
            - **UDP疎通確認**：TC021の既知SLMPフレームを使用した疎通確認（本番環境：実PLC動作確認、テスト環境：モック応答による完全オフライン実施）
            - ソケットレベルでのタイムアウト設定により、Step4（送受信処理）で個別にタイムアウト制御を実装する必要がなくなる
            - Socket.SendTimeout/ReceiveTimeoutは接続後のみ有効なため、接続成功確認後に設定する
            - これにより送受信処理の実装が簡潔になり、保守性が向上する

    ・SendFrameAsync（Step4: PLCへのリクエスト送信）
        - Input:
            - 設定値から生成したインスタンス（SLMPフレーム、16進数文字列：ConfigToFrameManager.BuildFrames()から取得）
            - 全デバイス一括読み込みフレーム例（Random READ）：540012340000000104030000...（ビット・ワード・ダブルワード混在指定）
            - （タイムアウトはStep3のConnectAsync内でSocket.SendTimeoutに既設定済み）
        - Output:
            - void（戻り値なし）
            - 成功時：送信完了状態
            - 失敗時：例外スロー（SocketException, TimeoutException等）
        - 使用コマンド：Random READコマンド(0403)のみ
        - 取得対象：全デバイス（ビット・ワード・ダブルワード）を1回の送信で一括取得
        - 処理フロー（フローチャート準拠）:
            1. 接続情報確認（接続情報 == True?）
                - False → Throw error（例外スロー）
                - True → 次へ
            2. 構築済みフレーム送信
                - Socket.Send()またはSocket.SendAsync()でフレームデータ送信
                - SendTimeoutMs内に送信完了確認
            3. 送信完了判定（送信完了?）
                - False → Throw error（TimeoutException等）
                - True → 次へ
            4. 送信統計記録
                - 送信フレーム数 +1（TotalFramesSent++）
                - 送信バイト数加算（TotalBytesSent += sentBytes）
                - 送信時刻記録（LastSendTime = DateTime.UtcNow）
            5. void返却（正常完了）
        - 統計情報更新（ConnectionStatsへの記録）:
            - TotalFramesSent（送信フレーム総数）のインクリメント
            - TotalBytesSent（送信バイト総数）の加算
            - 送信時刻の記録（応答時間計算用）
        - 参考資料：C:\Users\1010821\Desktop\python\andon\pdf2img（SLMP仕様書）

    ・ReceiveResponseAsync（Step4: PLCからのデータ受信）
        - Input:
            - （タイムアウトはStep3のConnectAsync内でSocket.ReceiveTimeoutに既設定済み）
        - Output:
            - 各種PLCの状態/生データ(16進数)
            - Random READコマンド(0403)レスポンス：全デバイスデータ（ビット・ワード・ダブルワード混在、既にDWord形式）
            - 受信データ形式：SLMPレスポンスフレーム（ヘッダー + データ部）
            - **1回の受信で全デバイスデータ取得完了**
        - 処理フロー（フローチャート準拠）:
            1. PLCレスポンス待機
                - Socket.Receive()またはSocket.ReceiveAsync()でデータ受信待機
                - ReceiveTimeoutMs内に受信確認
            2. タイムアウト内で受信判定（タイムアウト内で受信?）
                - False → 時間内に受信無しのメッセージ出力（TimeoutException）
                - True → 次へ
            3. 受信統計記録
                - 受信フレーム数 +1（TotalFramesReceived++）
                - 受信バイト数加算（TotalBytesReceived += receivedBytes）
                - 受信時刻記録（LastReceiveTime = DateTime.UtcNow）
            4. 生データ（16進数）返却
        - 統計情報更新（ConnectionStatsへの記録）:
            - TotalFramesReceived（受信フレーム総数）のインクリメント
            - TotalBytesReceived（受信バイト総数）の加算
            - 応答時間記録（ResponseTimes.Add(receiveTime - sendTime)）
                - 送信時刻と受信時刻の差分を計算
                - ConnectionStats.AddResponseTime()で統計更新

    ・DisconnectAsync（Step5: PLC切断処理）
        - Input:
            - 切断/リソース管理情報（PlcCommunicationManager.ConnectAsync()からの接続状態、通信統計情報）
        - Output:
            - ConnectionStats（通信統計情報オブジェクト）
                - 基本統計: 接続時間、送受信フレーム数・バイト数、切断時刻
                - 応答時間統計: 履歴・平均・最大・最小応答時間
                - エラー・品質統計: エラー回数、リトライ回数、通信成功率
        - 処理フロー（フローチャート準拠）:
            1. 切断要求受付
            2. 接続状態確認（接続中?）
                - False → 切断完了済メッセージ出力
                    - ログ出力（"既に切断済み"）
                    - 空のConnectionStats返却
                    - 処理終了
                - True → 次へ
            3. 通信全体の統計情報収集
                - 接続時間計算（DisconnectedAt - ConnectedAt）
                - 送信フレーム数記録（TotalFramesSent）
                - 受信フレーム数記録（TotalFramesReceived）
                - 送信バイト数記録（TotalBytesSent）
                - 受信バイト数記録（TotalBytesReceived）
                - 応答時間統計計算
                    - 応答時間履歴（ResponseTimes）
                    - 平均応答時間（AverageResponseTime）
                    - 最大応答時間（MaxResponseTime）
                    - 最小応答時間（MinResponseTime）
                - エラー回数記録（TotalErrors）
                - 通信成功率計算（SuccessRate = (TotalFramesSent - TotalErrors) / TotalFramesSent）
            4. ソケットシャットダウン実行
                - Socket.Shutdown(SocketShutdown.Both)
                    - 送受信両方向の通信を優雅に終了
                    - TCP FINパケット送信（TCP接続時）
                    - 相手側への切断通知
                - 例外処理：既に切断済みソケットの安全な処理
            5. ソケットクローズ実行
                - Socket.Close()
                    - ソケットリソース解放
                    - OSレベルのソケット破棄
                - タイムアウト設定：LingerOption設定（適切な切断待機時間）
            6. ソケット破棄実行
                - Socket.Dispose()
                    - .NETマネージドリソース解放
                    - メモリ解放
            7. 内部状態初期化
                - _socket = null（ソケット参照クリア）
                - _isConnected = false（接続状態フラグリセット）
                - その他内部状態変数の初期化
            8. ConnectionStats返却
                - 収集した統計情報オブジェクト返却
                - 処理完了ログ出力
        - 設計方針:
            - **エラーハンドリング**：既切断ソケットへの安全な処理（例外スロー回避）
            - **統計情報完全性**：切断前に全統計情報を確実に収集
            - **リソース解放順序厳守**：Shutdown→Close→Dispose の順序遵守
            - **状態整合性保証**：切断処理完了後の確実な状態リセット

    ・Disconnect（PLC切断処理 - 同期版）
        - Input:
            - なし（内部状態を基に処理実行）
        - Output:
            - void（戻り値なし）
            - 処理内容：ソケット適切切断、リソース解放、接続状態リセット
        - 処理詳細:
            - ソケット接続状態確認・適切な切断手順実行（Socket.Shutdown()）
            - リソース解放（Socket.Close(), Socket.Dispose()）
            - 内部状態初期化（_socket = null, _isConnected = false）
            - 例外処理：既切断ソケットに対する安全な処理
        - 用途：IDisposableパターン実装の補助メソッド、緊急時同期切断
        - データ取得元：内部フィールド（_socket, _isConnected, _disposed）

    ・Dispose（IDisposable実装 - リソース管理）
        - Input:
            - なし（IDisposableインターフェース準拠）
        - Output:
            - void（戻り値なし）
            - 処理内容：標準.NETリソース管理パターン実装
        - 処理詳細:
            - 重複実行防止（_disposedフィールドチェック）
            - Disconnect()メソッド呼び出し（実際のリソース解放処理）
            - GC.SuppressFinalize(this)実行（ファイナライザー抑制）
            - _disposedフラグ設定（再実行防止）
        - 設計方針：
            - C#標準Disposableパターン準拠（重複実行防止、ファイナライザー最適化）
            - Disconnect()への処理委譲（責任分離、同期処理保証）
            - using文対応（自動リソース管理対応）
        - データ取得元：内部フィールド（_disposed）、Disconnect()メソッド

    ・ProcessReceivedRawData（Step6-1: 受信データ基本後処理）
        - Input:
            - Step4で受信した生データ(16進数：PlcCommunicationManager.ReceiveResponseAsync()から取得)
            - ProcessedDeviceRequestInfo（デバイス要求情報：ConfigToFrameManager.PrepareDeviceRequestInfo()から取得）
        - Output:
            - ProcessedResponseData（基本後処理結果オブジェクト）
                - 基本結果: 元生データ、処理済みデータ（デバイス名キー構造）、処理時刻
                - エラー情報: エラーフラグ、エラー・警告メッセージリスト
                - 統計情報: 処理デバイス数（ビット・ワード・ダブルワード別）
        - 処理対象：
            - Random READコマンド(0403)レスポンスデータ（ビット・ワード・ダブルワード混在データ）
        - 責任範囲：
            - 生データの16進数パース
            - デバイス別データ抽出（ビット・ワード・ダブルワード混在）
            - 基本的な型変換（ビット/ワード/ダブルワード）
            - エラー検証・記録
        - 処理内容：
            - Random READコマンド応答パース（全デバイスデータ、既にDWord形式）
            - 1回の処理で全デバイス（M000-M999、D000-D999）のデータを抽出
            - デバイス名キー構造の辞書に変換（例: {"M000": true, "D000": 0x1234, "D002": 0x56781234}）
        - データ取得元：PlcCommunicationManager.ReceiveResponseAsync()（受信生データ）、ConfigToFrameManager.PrepareDeviceRequestInfo()（デバイス要求情報）
        - **旧MergeResponseDataの機能を統合**：応答統合処理が不要なため、ProcessReceivedRawDataで完結

    ・ParseRawToStructuredData（Step6-2: 構造化データ変換）
        - Input:
            - 処理済み受信データ（ProcessedResponseData：PlcCommunicationManager.ProcessReceivedRawData()から取得）
        - Output:
            - StructuredData（SLMP構造化解析結果オブジェクト）
                - 基本構造化データ: SLMPヘッダー（全標準情報）、終了コード、デバイスデータ、受信時刻、エラーフラグ
                - 解析詳細情報: 解析手順記録、解釈情報、処理時間、デバイス解釈、ステータス判定
                - エラー詳細情報: 詳細エラーコード、エラー説明、影響デバイス（エラー時のみ）
        - データ取得元：PlcCommunicationManager.ProcessReceivedRawData()（処理済みデータ）
        - **旧Step6-3から繰り上げ**：応答統合処理（旧Step6-2）が不要なため

---

◆補助ユーティリティクラス

クラス：SlmpDataParser（データ変換ユーティリティ）
実装場所：Andon.Utilities.SlmpDataParser（静的クラス）
設計目的：
    ・PlcCommunicationManagerの肥大化防止（現在2340行）
    ・単一責務原則の遵守（通信管理とデータ変換の分離）
    ・他クラスでの再利用可能性確保
    ・独立したテスト実施の容易性
データ取得元：Python PySLMPClientのutil.py相当機能

メソッド：
    ・DecodeBcd(byte[] data)（4bit BCD配列のデコード）
        - Input: BCDエンコードされたバイト配列
        - Output: デコード後のバイト配列
        - 処理例: [0x12, 0x34] → [1, 2, 3, 4]

    ・UnpackBits(byte[] data)（ビット配列の展開、LSBから順）
        - Input: ビットパックされたバイト配列
        - Output: 展開後のbool配列
        - 処理例: [0x85] → [true, false, true, false, false, false, false, true]

    ・HexStringToBytes(string hexString)（16進数文字列からバイト列への変換）
        - Input: 16進数文字列（偶数長）
        - Output: バイト配列
        - 処理例: "1A2B" → [0x1A, 0x2B]

    ・BytesToHexString(byte[] data)（バイト配列から16進数文字列への変換）
        - Input: バイト配列
        - Output: 16進数文字列（大文字）
        - 処理例: [0x1A, 0x2B] → "1A2B"

    ・ExtractWordDwordData(byte[] buffer, int splitPos)（Word/Dwordデータの分離抽出）
        - Input: 入力バイト配列、分割位置（Wordデータの終了位置）
        - Output: (Dwordデータリスト, Wordデータリスト)のタプル
        - 処理内容: バイナリデータを2バイトデータ（Word）と4バイトデータ（Dword）に分離

    ・ParseAsciiHex(string asciiData, int startIndex, int length)（ASCII形式の応答データから数値を抽出）
        - Input: ASCII形式データ文字列、開始インデックス、抽出する文字数
        - Output: 16進数として解釈した整数値

    ・ParseAsciiBitData(string asciiData)（ASCIIビットデータのパース）
        - Input: ASCIIビットデータ文字列（'0'/'1'）
        - Output: bool配列
        - 処理例: "0110" → [false, true, true, false]

    ・ParseAsciiWordData(string asciiData)（ASCIIワードデータのパース）
        - Input: ASCIIワードデータ文字列（4文字単位）
        - Output: ushort配列
        - 処理例: "12AB34CD" → [0x12AB, 0x34CD]

    ・ParseBinaryBitData(byte[] binaryData, int count)（Binaryビットデータのパース）
        - Input: バイナリビットデータ、ビット数
        - Output: bool配列
        - 処理内容: BCDデコード後、ビット値に変換（奇数個の場合、最後の余分なビットを削除）

    ・ParseBinaryWordData(byte[] binaryData)（Binaryワードデータのパース）
        - Input: バイナリワードデータ
        - Output: ushort配列
        - 処理内容: バイナリデータを直接ushort配列として解釈（リトルエンディアン）

使用箇所：
    ・PlcCommunicationManager.ProcessReceivedRawData()（Step6-1: 受信データ基本後処理）
        - ASCII/Binary形式のパース処理
        - 3E/4Eフレーム対応
        - ビット/ワード/ダブルワード各データ型のパース処理
    ・実装参考: C:\Users\1010821\Desktop\python\andon\documents\design\フレーム構築関係\受信データパース処理仕様.md
    ・フレーム構造参考: C:\Users\1010821\Desktop\python\andon\documents\design\フレーム構築関係\フレーム構築方法.md
        - **重要**: 4Eフレーム応答には監視タイマフィールドが存在しない
        - 終了コード位置: オフセット13-14（監視タイマなし）
        - デバイスデータ開始位置: オフセット15

---

クラス：MultiPlcCoordinator
機能概要：複数PLC並列実行調整ヘルパー、Task.WhenAll/順次処理の切り替え
配置：Core/Managers/MultiPlcCoordinator.cs
クラス種別：静的ヘルパークラス（約50行）
メソッド：
    ・ExecuteParallelAsync（並列実行）
        - Input:
            - List<PlcConnectionConfig>（PLC設定リスト）
            - ParallelProcessingConfig（並列処理設定）
            - CancellationToken（実行制御）
        - Output:
            - List<PlcExecutionResult>（各PLC実行結果リスト）
        - 処理内容：
            - 優先度順でタスク生成（OrderByDescending(p => p.Priority)）
            - Task.WhenAllで並列実行
            - 全体タイムアウト制御（OverallTimeoutMs）
        - データ取得元：PlcCommunicationManager.ExecuteStep3to5CycleAsync()（既存メソッド活用）

    ・ExecuteSequentialAsync（順次実行）
        - Input:
            - List<PlcConnectionConfig>（PLC設定リスト）
            - CancellationToken（実行制御）
        - Output:
            - List<PlcExecutionResult>（各PLC実行結果リスト）
        - 処理内容：
            - foreach順次処理（ConMoni3互換）
            - 各PLC処理後に10msスロットリング
        - データ取得元：PlcCommunicationManager.ExecuteStep3to5CycleAsync()（既存メソッド活用）

    ・ExecuteSinglePlcAsync（単一PLC処理、private）
        - Input:
            - PlcConnectionConfig（PLC設定）
            - CancellationToken（実行制御）
        - Output:
            - PlcExecutionResult（単一PLC実行結果）
        - 処理内容：
            - PlcCommunicationManagerインスタンス生成
            - ConnectionConfig, TimeoutConfig変換
            - SlmpFrameBuilder.BuildReadRandomRequest()でフレーム構築
            - ExecuteStep3to5CycleAsync()で通信実行
            - 例外処理とエラーログ記録
        - データ取得元：既存の全通信インフラを再利用

---

- Step7
機能概要：解析後データの出力
詳細機能：
    ・解析したデータを任意の場所/形式に出力/保存
        - データ取得元：PlcCommunicationManager.ParseRawToStructuredData()（構造化解析結果）
クラス：DataOutputManager
メソッド：
    ・OutputDataAsync（解析後データ出力）
        - Input:
            - 構造化データ（PlcCommunicationManager.ParseRawToStructuredData()の出力）
            - 出力設定（FilePath, Format）
        - Output:
            - データが指定場所/形式で出力/保存される
        - 動作フロー成功条件：解析したデータを任意の場所/形式に出力/保存できる
        - データ取得元：PlcCommunicationManager.ParseRawToStructuredData()（構造化解析結果）

- ログ出力機能
機能概要：SLMP通信の可視化、デバッグ/トラブルシューティング支援、パフォーマンス分析と最適化、運用監視/メンテナンスの効率化
基本方針：
    ・全Step（Step1〜Step7）の処理状況を把握
    ・2つの出力先への対応：ファイル、コンソール
    ・ミリ秒精度の時系列情報で高精度な追跡を実現
詳細機能：
    ・SLMPフレーム生バイナリデータ出力
        - 送信/受信フレーム（完全な16進数表現）
        - 16進数ダンプ（アドレス付き、ASCII表現付き）
        - フレーム解析（ヘッダー、終了コード、データ部詳細）
        - データ取得元：Step2（通信フレーム構築：ConfigToFrameManager.BuildFrames()）、Step4（PLCリクエスト送受信：PlcCommunicationManager.SendFrameAsync(), PlcCommunicationManager.ReceiveResponseAsync()）
    ・詳細SLMPフレーム解析出力
        - サブヘッダー解析（3E/4Eフレーム判定）
        - ネットワーク情報（ネットワーク番号、PC番号、ユニット情報）
        - 終了コード詳細（エラー原因の具体的説明）
        - データ部解析（ワード/ビット別の詳細解析）
        - データ取得元：Step2（通信フレーム構築：ConfigToFrameManager.BuildFrames()）、Step4（PLCリクエスト送受信：PlcCommunicationManager.SendFrameAsync(), PlcCommunicationManager.ReceiveResponseAsync()）、Step6（受信データ解析：PlcCommunicationManager.ParseRawToStructuredData()）
    ・アプリケーション状態情報出力
        - セッション情報（開始/終了、プロセスID、実行時間）
        - 設定情報詳細（SLMP設定、継続モード、タイムアウト等）
        - サイクル情報（サイクル番号、フェーズ、間隔）
        - 処理状況（リアルタイムメッセージ、状態変化）
        - データ取得元：全Step（設定情報はStep1：ConfigToFrameManager.LoadConfigAsync()、その他は全Step実行中に取得：LoggingManager各メソッド）
    ・統計/パフォーマンス情報出力
        - 実行統計（サイクル数、成功率、失敗率）
        - 応答時間分析（平均、最大、最小、分布）
        - エラー統計（エラー種別、頻度、回復状況）
        - システム稼働状況（リソース使用量、パフォーマンス）
        - データ取得元：全Step（通信応答時間はStep3〜Step5：PlcCommunicationManager.ConnectAsync(), PlcCommunicationManager.SendFrameAsync(), PlcCommunicationManager.ReceiveResponseAsync(), PlcCommunicationManager.DisconnectAsync()、その他は全Stepの実行状況から算出：LoggingManager各メソッド）
    ・設定情報の詳細出力
        - SLMP接続設定（IpAddress, Port, ConnectionType, UseTcp, IsBinary, FrameVersion等）
        - 継続動作設定（エラーハンドリング、デフォルト値）
        - タイムアウト・リトライ設定（ConnectTimeoutMs, SendTimeoutMs, ReceiveTimeoutMs, RetryTimeoutMs）
        - データ処理設定（TargetName, ContinuousDataMode, DataRetentionDays, MonitoringIntervalMs）
        - システムリソース設定（MemoryLimitKB, MaxBufferSize, MemoryThresholdKB, LowMemoryMode）
        - ログ設定（出力先、レベル、ローテーション）
        - データ取得元：Step1（設定ファイル条件の読み込み：ConfigToFrameManager.LoadConfigAsync()）
    ・エラー/例外情報の詳細出力
        - エラー分類（通信エラー、タイムアウト、設定エラー等）
        - 継続機能動作（エラー処理、デフォルト値返却）
        - リトライ処理（試行回数、間隔、結果）
        - 回復処理（自動回復、状態復旧）
        - データ取得元：全Step（設定エラー（Step1：ConfigToFrameManager.LoadConfigAsync()）、通信エラー（Step3・Step4・Step5：PlcCommunicationManager各メソッド）、データ解析エラー（Step6：PlcCommunicationManager.ParseRawToStructuredData()）、出力エラー（Step7：DataOutputManager）、エラー処理（ErrorHandler各メソッド））
    ・時系列・関連情報出力
        - SessionId（関連ログのグループ化）
        - CycleNumber（サイクル内の処理順序）
        - タイムスタンプ（ミリ秒精度の時刻情報）
        - 処理間隔（フェーズ間、サイクル間の時間）
        - データ取得元：全Step（SessionIdはアプリケーション開始時生成：LoggingManager.SetCorrelationId()、CycleNumber・タイムスタンプ・処理間隔は各Step実行時に取得：LoggingManager各メソッド）
    ・デバイス解釈情報出力
        - 生データ（バイナリ、16進数、数値表現）
        - 解釈結果（人間が読める形式への変換）
        - ステータス判定（ON/OFF、正常/異常等）
        - データ取得元：Step6（受信データ解析：PlcCommunicationManager.ParseRawToStructuredData()）、Step7（解析後データ出力：DataOutputManager）

出力先設定：
    ・ファイル出力
        - ConsoleOutput:
            - FilePath: "logs/terminal_output.txt" (コンソール出力ログファイルパス)
            - MaxFileSizeMB: 10 (最大ファイルサイズ)
            - MaxFileCount: 5 (最大ファイル数)
            - FlushIntervalMs: 1000 (フラッシュ間隔)
        - DetailedLog:
            - FilePath: "logs/rawdata_analysis.json" (詳細ログファイルパス)
            - MaxFileSizeMB: 50 (最大ファイルサイズ)
            - RetentionDays: 14 (保持期間)
    ・コンソール出力
        - リアルタイム表示（ConsoleOutput設定による）

クラス：LoggingManager
メソッド：
    ・InitializeAsync（ログシステム初期化）
        - Input:
            - LoggingConfig（ConsoleOutput, DetailedLog設定）
        - Output:
            - 初期化状態（ファイル作成等）

    ・SetCorrelationId（セッション関連付けID設定）
        - Input:
            - SessionId（処理セッション識別子）
        - Output:
            - 関連付け設定完了状態

    ・SetLogLevel（ログレベル設定）
        - Input:
            - LogLevel（出力レベル指定）
        - Output:
            - レベル設定完了状態

    ・IsLogLevelEnabled（ログレベル有効性確認）
        - Input:
            - LogLevel（確認対象レベル）
        - Output:
            - 有効性判定結果（true/false）

    ・LogConfigAsync（設定情報詳細出力）
        - Input:
            - 全設定オブジェクト（ConnectionConfig, TimeoutConfig, TargetDeviceConfig, SystemResourcesConfig, DataProcessingConfig等）
        - Output:
            - 設定情報ログ出力完了状態
        - 出力先：ファイル、コンソール

    ・LogCommunicationAsync（通信/送受信データ情報出力）
        - Input:
            - SLMPフレーム（送信/受信）
            - フレーム解析結果（ヘッダー、終了コード、データ部）
            - 通信統計（応答時間、成功/失敗）
        - Output:
            - 通信ログ出力完了状態
        - 出力先：ファイル、コンソール

    ・LogStateAsync（アプリケーション状態出力）
        - Input:
            - セッション情報（開始/終了、プロセスID、実行時間）
            - サイクル情報（サイクル番号、フェーズ、間隔）
            - 処理状況（リアルタイムメッセージ、状態変化）
        - Output:
            - 状態ログ出力完了状態
        - 出力先：ファイル、コンソール

    ・LogMetricAsync（統計/パフォーマンス情報出力）
        - Input:
            - 実行統計（サイクル数、成功率、失敗率）
            - 応答時間分析（平均、最大、最小、分布）
            - システム稼働状況（リソース使用量、パフォーマンス）
        - Output:
            - 統計ログ出力完了状態
        - 出力先：ファイル、コンソール

    ・LogErrorAsync（エラー/例外情報詳細出力）
        - Input:
            - エラー分類（通信エラー、タイムアウト、設定エラー等）
            - エラー詳細（例外オブジェクト、スタックトレース）
            - 回復処理結果（リトライ結果、自動回復状況）
        - Output:
            - エラーログ出力完了状態
        - 出力先：ファイル、コンソール

    ・LogDeviceDataAsync（デバイス解釈情報出力）
        - Input:
            - 生データ（バイナリ、16進数、数値表現）
            - 解釈結果（人間が読める形式への変換）
            - ステータス判定（ON/OFF、正常/異常等）
        - Output:
            - デバイスデータログ出力完了状態
        - 出力先：ファイル、コンソール

    ・BeginTransaction（トランザクション開始）
        - Input:
            - TransactionId（トランザクション識別子）
        - Output:
            - トランザクション開始状態

    ・EndTransaction（トランザクション終了）
        - Input:
            - TransactionId（トランザクション識別子）
            - TransactionResult（成功/失敗結果）
        - Output:
            - トランザクション終了状態

    ・FlushAsync（バッファフラッシュ）
        - Input:
            - FlushTarget（ファイル指定）
        - Output:
            - フラッシュ完了状態



- エラーハンドリング
機能概要：エラー分類判定/記録、エラー処理/リトライ方針適用（バランス型例外設計採用）
基本方針：
    ・例外設計：混在型（重要例外のみカスタム、他は標準例外）
        - カスタム例外：MultiConfigLoadException（複数設定ファイル専用）
        - 標準例外：FileNotFoundException, IOException, UnauthorizedAccessException等
    ・メッセージ管理：定数クラス（ErrorMessages.cs）で統一管理
    ・権限チェック：単純ファイル作成テストで確実性重視
詳細機能：
    ・エラー分類判定
        - データ取得元：実行中のクラス/メソッド（ConfigToFrameManager, PlcCommunicationManager, DataOutputManager各メソッド）、発生した例外オブジェクト
    ・エラー記録
        - データ取得元：ErrorHandler.DetermineErrorCategory()（エラー分類結果）、LoggingManager.LogErrorAsync()（ログ出力）
    ・エラー処理方針適用
        - データ取得元：ConfigToFrameManager.LoadConfigAsync()（設定情報）、ErrorHandler.DetermineErrorCategory()（エラー分類結果）
    ・リトライ方針適用
        - データ取得元：ConfigToFrameManager.LoadConfigAsync()（リトライ設定）、ErrorHandler.RecordError()（エラー履歴）
    ・統一エラーメッセージ管理
        - データ取得元：ErrorMessages.cs（定数クラス）、各種例外発生箇所

クラス：ErrorHandler
メソッド：
    ・DetermineErrorCategory（エラー分類判定）
        - Input:
            - Exception（発生したエラー・例外オブジェクト）
            - StepNumber（Step1-7のステップ番号：実行中のクラス/メソッドから推定 - Step1:ConfigToFrameManager.LoadConfigAsync(), Step2:ConfigToFrameManager.BuildFrames(), Step3:PlcCommunicationManager.ConnectAsync(), Step4:PlcCommunicationManager.SendFrameAsync()/ReceiveResponseAsync(), Step5:PlcCommunicationManager.DisconnectAsync(), Step6:PlcCommunicationManager.ParseRawToStructuredData(), Step7:DataOutputManager）
        - Output:
            - ErrorCategory（ConfigurationError, CommunicationError, DataProcessingError, ResourceError, SystemError）
            - Severity（Info, Warning, Error, Fatal）

    ・RecordError（エラー記録）
        - Input:
            - ErrorCategory（エラー分類）
            - Severity（重要度）
            - ErrorMessage（エラーメッセージ）
            - Exception（例外オブジェクト）
            - StepNumber（ステップ番号：実行中のクラス/メソッドから推定 - Step1:ConfigToFrameManager.LoadConfigAsync(), Step2:ConfigToFrameManager.BuildFrames(), Step3:PlcCommunicationManager.ConnectAsync(), Step4:PlcCommunicationManager.SendFrameAsync()/ReceiveResponseAsync(), Step5:PlcCommunicationManager.DisconnectAsync(), Step6:PlcCommunicationManager.ParseRawToStructuredData(), Step7:DataOutputManager）
        - Output:
            - 記録完了状態

    ・ApplyErrorPolicy（エラー処理方針適用）
        - Input:
            - ErrorCategory（エラー分類）
            - StepNumber（ステップ番号：実行中のクラス/メソッドから推定 - Step1:ConfigToFrameManager.LoadConfigAsync(), Step2:ConfigToFrameManager.BuildFrames(), Step3:PlcCommunicationManager.ConnectAsync(), Step4:PlcCommunicationManager.SendFrameAsync()/ReceiveResponseAsync(), Step5:PlcCommunicationManager.DisconnectAsync(), Step6:PlcCommunicationManager.ParseRawToStructuredData(), Step7:DataOutputManager）
        - Output:
            - ErrorAction（継続/終了の判定結果）

    ・ApplyRetryPolicy（リトライ方針適用）
        - Input:
            - ErrorCategory（エラー分類）
            - StepNumber（ステップ番号：実行中のクラス/メソッドから推定 - Step1:ConfigToFrameManager.LoadConfigAsync(), Step2:ConfigToFrameManager.BuildFrames(), Step3:PlcCommunicationManager.ConnectAsync(), Step4:PlcCommunicationManager.SendFrameAsync()/ReceiveResponseAsync(), Step5:PlcCommunicationManager.DisconnectAsync(), Step6:PlcCommunicationManager.ParseRawToStructuredData(), Step7:DataOutputManager）
            - CurrentRetryCount（現在のリトライ回数）
        - Output:
            - ShouldRetry（リトライするかどうかの判定）
            - MaxRetryCount（最大リトライ回数）

クラス：ErrorMessages（統一エラーメッセージ管理）
機能概要：全システムで使用するエラーメッセージの一元管理、国際化対応基盤、メッセージ品質統一
実装方針：
    ・定数クラス：static readonlyによる変更不可メッセージ定義
    ・カテゴリ分類：機能別・重要度別メッセージグループ化
    ・パラメータ化：動的情報（ファイル名、パス等）の埋め込み対応
    ・日本語優先：運用現場での理解しやすさ重視、英語併記
メソッド・プロパティ：
    ・設定ファイル関連メッセージ
        - CONFIG_FILE_NOT_FOUND（"設定ファイルが見つかりません: {0}"）
        - CONFIG_DIRECTORY_NOT_FOUND（"設定ディレクトリが見つかりません: {0}"）
        - CONFIG_FILE_INVALID_FORMAT（"設定ファイルの形式が不正です: {0}"）
        - CONFIG_MISSING_REQUIRED_FIELD（"必須設定項目が不足しています: {0}"）
    ・複数設定ファイル関連メッセージ
        - MULTI_CONFIG_LOAD_FAILED（"複数設定ファイル読み込みに失敗しました。成功: {0}件、失敗: {1}件"）
        - MULTI_CONFIG_PARTIAL_SUCCESS（"一部の設定ファイル読み込みに失敗しました: {0}"）
        - MULTI_CONFIG_NO_FILES_FOUND（"指定パターンに一致する設定ファイルが見つかりません: {0}"）
    ・通信関連メッセージ
        - CONNECTION_FAILED（"PLC接続に失敗しました: {0}:{1}"）
        - CONNECTION_TIMEOUT（"PLC接続がタイムアウトしました: {0}ms"）
        - COMMUNICATION_ERROR（"PLC通信エラーが発生しました: {0}"）
        - FRAME_SEND_FAILED（"フレーム送信に失敗しました: {0}"）
        - RESPONSE_TIMEOUT（"応答受信がタイムアウトしました: {0}ms"）
    ・権限・ファイルシステム関連メッセージ
        - FILE_ACCESS_DENIED（"ファイルアクセスが拒否されました: {0}"）
        - DIRECTORY_CREATE_FAILED（"ディレクトリ作成に失敗しました: {0}"）
        - WRITE_PERMISSION_CHECK_FAILED（"書き込み権限チェックに失敗しました: {0}"）
        - LOG_FILE_WRITE_FAILED（"ログファイル書き込みに失敗しました: {0}"）
    ・メモリ・リソース関連メッセージ
        - MEMORY_LIMIT_EXCEEDED（"メモリ使用量が制限を超過しました: {0}KB/{1}KB"）
        - MEMORY_THRESHOLD_WARNING（"メモリ使用量が警告閾値を超過しました: {0}KB/{1}KB"）
        - RESOURCE_OPTIMIZATION_REQUIRED（"リソース最適化が必要です: {0}"）
    ・汎用システムメッセージ
        - UNEXPECTED_ERROR（"予期しないエラーが発生しました: {0}"）
        - OPERATION_CANCELLED（"操作がキャンセルされました: {0}"）
        - INITIALIZATION_FAILED（"初期化に失敗しました: {0}"）

クラス：MultiConfigLoadException（複数設定ファイル専用例外）
機能概要：複数設定ファイル読み込み時の詳細なエラー情報保持、部分成功・失敗の状況管理
継承関係：Exception（標準.NET例外）を継承
実装方針：
    ・詳細エラー情報：成功・失敗ファイル一覧の保持
    ・部分成功対応：一部失敗でも継続可能な情報構造
    ・標準例外互換：.NET例外処理パターンとの整合性
    ・デバッグ支援：トラブルシューティング用詳細情報
プロパティ：
    ・LoadedFiles（List<string>型、必須）: 読み込み成功したファイル一覧
    ・FailedFiles（Dictionary<string, Exception>型、必須）: 失敗ファイルと対応する例外
    ・AttemptedDirectory（string型、必須）: 読み込み試行ディレクトリパス
    ・FilePattern（string型、必須）: 使用したファイルパターン（例：\"*_settings.xlsx\"）
    ・TotalAttempted（int型、必須）: 読み込み試行総数（自動計算）
    ・SuccessCount（int型、必須）: 成功数（LoadedFiles.Count）
    ・FailureCount（int型、必須）: 失敗数（FailedFiles.Count）
    ・IsPartialSuccess（bool型、必須）: 部分成功フラグ（SuccessCount > 0 && FailureCount > 0）
コンストラクタ：
    ・完全失敗用：MultiConfigLoadException(string directory, string pattern, Dictionary<string, Exception> failures)
    ・部分成功用：MultiConfigLoadException(string directory, string pattern, List<string> loaded, Dictionary<string, Exception> failures)
    ・標準形式：MultiConfigLoadException(string message, Exception innerException)
メソッド：
    ・GetDetailedErrorReport(): 詳細エラーレポート文字列生成
    ・GetFailedFileNames(): 失敗ファイル名一覧取得
    ・HasSpecificFailure(Type exceptionType): 特定例外タイプの失敗有無確認


- メモリ・リソース管理
機能概要：メモリ使用量/閾値情報取得、各レベル毎の動作管理
詳細機能：
    ・メモリ使用量取得/管理
        - データ取得元：システムAPI（GC.GetTotalMemory()等）、各クラスの内部状態（PlcCommunicationManager, ConfigToFrameManager, LoggingManager）
    ・レベル判定
        - データ取得元：ConfigToFrameManager.LoadConfigAsync()（閾値設定）、ResourceManager.GetMemoryUsage()（現在使用量）
    ・データ/ログポリシー適用
        - データ取得元：ConfigToFrameManager.LoadConfigAsync()（ポリシー設定）、ResourceManager.EvaluateLevel()（レベル判定結果）
    ・メモリ削減/ログ出力処理
        - データ取得元：PlcCommunicationManager, ConfigToFrameManager, LoggingManager各メソッド（メモリ使用状況）、LoggingManager.WriteLogAsync()（ログ出力）
    ・監視タイミング管理
        - データ取得元：ConfigToFrameManager.LoadConfigAsync()（監視間隔設定）、ResourceManager.RunMonitoringLoopAsync()（監視ループ）
クラス：ResourceManager
メソッド：
    ・GetMemoryUsage（メモリ使用量取得）
        - Input:
            - システム状態（現在のメモリ使用状況）
        - Output:
            - 現在のメモリ使用量（KB単位）
            - 各コンポーネント別使用量
        - データ取得元：システムAPI（GC.GetTotalMemory(), Process.GetCurrentProcess().WorkingSet64等）、各クラスの内部状態（PlcCommunicationManager, ConfigToFrameManager, LoggingManager）

    ・EvaluateLevel（メモリレベル判定）
        - Input:
            - 現在メモリ使用量（ResourceManager.GetMemoryUsage()）
            - 閾値設定（ConfigToFrameManager.LoadConfigAsync()）
        - Output:
            - メモリレベル（Normal, Warning, Critical）
            - 推奨アクション
        - データ取得元：ResourceManager.GetMemoryUsage()（現在使用量）、ConfigToFrameManager.LoadConfigAsync()（閾値設定：MemoryLimitKB, MemoryThresholdKB, LowMemoryMode）

    ・ApplyDataAndLoggingPolicy（データ/ログポリシー適用）
        - Input:
            - メモリレベル（ResourceManager.EvaluateLevel()）
            - ポリシー設定（ConfigToFrameManager.LoadConfigAsync()）
        - Output:
            - 適用されたポリシー内容
            - データ処理制限設定
        - データ取得元：ResourceManager.EvaluateLevel()（レベル判定結果）、ConfigToFrameManager.LoadConfigAsync()（システムリソース設定：MaxBufferSize, LowMemoryMode）

    ・OptimizeMemory（メモリ最適化実行）
        - Input:
            - 最適化対象（各クラスインスタンス）
            - 最適化レベル（ResourceManager.EvaluateLevel()）
        - Output:
            - 最適化実行結果
            - 削減されたメモリ量
        - データ取得元：PlcCommunicationManager, ConfigToFrameManager, LoggingManager各メソッド（メモリ解放対象）、ResourceManager.ApplyDataAndLoggingPolicy()（最適化方針）

    ・WriteLogAsync（メモリ状況ログ出力）
        - Input:
            - メモリ使用状況（ResourceManager.GetMemoryUsage()）
            - メモリレベル（ResourceManager.EvaluateLevel()）
            - 最適化結果（ResourceManager.OptimizeMemory()）
        - Output:
            - ログ出力完了状態
        - データ取得元：ResourceManager各メソッド（メモリ状況）、LoggingManager.LogStateAsync()（ログ出力機能）

    ・RunMonitoringLoopAsync（メモリ監視ループ実行）
        - Input:
            - 監視間隔設定（ConfigToFrameManager.LoadConfigAsync()）
            - 継続監視フラグ
        - Output:
            - 監視ループ実行状態
        - データ取得元：ConfigToFrameManager.LoadConfigAsync()（監視設定：MonitoringIntervalMs）、ResourceManager各メソッド（監視対象メソッド）


- インターフェース設計
機能概要：テスタビリティ確保、TDD手法サポート、モック・スタブ対応
基本方針：
    ・全主要クラスのインターフェース分離によるテスタビリティ確保
    ・2つの出力先への対応：実装クラス、モック・スタブ
    ・51個のテストケース（TC001-TC051）実行支援
詳細機能：
    ・設定管理・フレーム構築インターフェース分離
        - 対象：ConfigToFrameManager（Step1-2処理）
        - データ取得元：IConfigToFrameManager契約による抽象化
    ・PLC通信インターフェース分離（最重要）
        - 対象：PlcCommunicationManager（Step3-6処理）
        - データ取得元：IPlcCommunicationManager契約による抽象化
    ・データ出力インターフェース分離
        - 対象：DataOutputManager（Step7処理）
        - データ取得元：IDataOutputManager契約による抽象化
    ・ログシステムインターフェース分離
        - 対象：LoggingManager（全Step横断ログ処理）
        - データ取得元：ILoggingManager契約による抽象化
    ・エラーハンドリングインターフェース分離
        - 対象：ErrorHandler（全Step横断エラー処理）
        - データ取得元：IErrorHandler契約による抽象化
    ・リソース管理インターフェース分離
        - 対象：ResourceManager（メモリ・リソース管理）
        - データ取得元：IResourceManager契約による抽象化

実装優先順位：
    ・Phase1: IPlcCommunicationManager実装（Step3-6最優先）
        - テストケース：TC012-TC030（PlcCommunicationManager単体テスト）
        - データ取得元：三菱電機公式仕様書（pdf2img/sh080931q.pdf準拠テストデータ）
    ・Phase2: Infrastructure系インターフェース実装
        - 対象：ILoggingManager, IErrorHandler, IResourceManager
        - テストケース：TC031-TC041（支援システムテスト）
    ・Phase3: IConfigToFrameManager実装（Step1-2）
        - テストケース：TC001-TC016（設定・フレーム構築テスト）
        - 設定ファイル形式：appsettings.xlsx使用（ClosedXMLライブラリでExcel読み込み）
    ・Phase4: IDataOutputManager実装（Step7）
        - テストケース：TC042-TC046（データ出力テスト）
    ・Phase5: 統合テスト実行
        - テストケース：TC047-TC051（統合・パフォーマンステスト）

TDD実装サイクル適用：
    ・Red-Green-Refactorサイクル実行
        - データ取得元：テスト内容.mdのTC001-TC051テストケース定義
    ・段階的機能追加方針
        - 単一ブロック毎のテスト→パス確認→複合時の動作テスト
        - データ取得元：CLAUDE.mdの基本実装方針
    ・実装記録・学習資料作成
        - 実装判断根拠記録（documents/implementation_records/method_records/）
        - C#学習資料作成（documents/implementation_records/learning_materials/）
        - データ取得元：各メソッド実装中の判断過程


◆Modelsクラス詳細設計

- Core/Models/ConfigModels（設定関連モデル）
機能概要：LoadConfigAsyncメソッドで読み込まれる各種設定情報の構造化、型安全性確保、デフォルト値管理
詳細機能：
    ・PLC接続設定保持
    ・タイムアウト設定保持
    ・デバイス設定保持
    ・システムリソース設定保持
    ・データ処理設定保持
    ・ログ設定保持
    ・データ転送設定保持
クラス・列挙型：

    ・ConnectionType（列挙型）
        - 目的：接続タイプの型安全な表現
        - 値：
            - Ethernet: イーサネット接続（既定）
            - Serial: シリアル接続
            - USB: USB接続
        - 使用箇所：ConnectionConfig.ConnectionType

    ・FrameVersion（列挙型）
        - 目的：SLMPフレームバージョンの型安全な表現
        - 値：
            - Frame3E: 3Eフレーム
            - Frame4E: 4Eフレーム（既定）
        - 使用箇所：ConnectionConfig.FrameVersion

    ・ConnectionConfig（PLC接続設定）
        - 目的：PLC接続に必要な全設定情報の構造化保持
        - プロパティ：
            - IpAddress（System.Net.IPAddress型、必須）: PLC接続先IPアドレス
            - Port（int型、必須）: PLC接続ポート番号（設定ファイルで必須指定）
            - UseTcp（bool型、必須）: TCP/UDP選択フラグ（デフォルト：false = UDP優先）
            - ConnectionType（string型計算プロパティ、読み取り専用）: 接続プロトコル文字列表現（"TCP"または"UDP"、UseTcpから自動計算、ログ出力・可読性用）
            - IsBinary（bool型、必須）: バイナリ/ASCII形式選択（デフォルト：false = ASCII形式）
            - FrameVersion（FrameVersion型、必須）: 3E/4Eフレーム選択（デフォルト：Frame4E）
        - コンストラクタ：
            - デフォルト：初期状態（UDP・ASCII・4Eフレーム・Ethernet）
            - 完全指定：ConnectionConfig(IPAddress, int, bool, ConnectionType, bool, FrameVersion)
        - 設計方針：
            - 全プロパティnull不許容（設定情報の確実存在）
            - UDP・ASCII優先（高速通信・可読性重視）
            - 列挙型使用（タイプミス防止・型安全性確保）

    ・TimeoutConfig（タイムアウト設定）
        - 目的：PLC通信タイムアウト値の構造化保持
        - プロパティ：
            - ConnectTimeoutMs（int型、必須）: PLC接続タイムアウト（デフォルト：5000ms = 5秒）
            - SendTimeoutMs（int型、必須）: データ送信タイムアウト（デフォルト：500ms = 0.5秒）
            - ReceiveTimeoutMs（int型、必須）: データ受信タイムアウト（デフォルト：500ms = 0.5秒）
            - RetryTimeoutMs（int型、必須）: エラー時リトライ間隔（デフォルト：1000ms = 1秒）
        - コンストラクタ：
            - デフォルト：初期状態（接続5秒・送信0.5秒・受信0.5秒・リトライ1秒）
            - 完全指定：TimeoutConfig(int, int, int, int)
        - 設計方針：
            - 全プロパティnull不許容（タイムアウト値の確実設定）
            - 実用的デフォルト値（接続5秒、送受信0.5秒の高速応答性）
            - ミリ秒単位（精密なタイミング制御）

    ・TargetDeviceConfig（対象デバイス設定）
        - 目的：Random READ用デバイス指定情報の構造化保持
        - 配置：Core/Models/ConfigModels/TargetDeviceConfig.cs
        - プロパティ：
            - Devices（List<DeviceSpecification>型、必須）: デバイス指定リスト
            - FrameType（string型、必須）: フレームタイプ（"3E"/"4E"、デフォルト："4E"）
            - Timeout（ushort型、必須）: 監視タイマ（250ms単位、デフォルト：32=8秒）
        - 用途：
            - Random READ(0x0403)コマンドでのデバイス一括取得
            - 飛び飛びのデバイス指定に対応
            - ビット・ワード・ダブルワード混在対応
        - 使用箇所：ConfigToFrameManager.BuildReadRandomFrameFromConfig()（フレーム構築）
        - コンストラクタ：
            - デフォルト：初期状態（空のDevicesリスト、FrameType="4E", Timeout=32）
            - 完全指定：TargetDeviceConfig(List<DeviceSpecification> devices, string frameType = "4E", ushort timeout = 32)
        - 設計方針：
            - 全プロパティnull不許容（デバイス指定・フレーム設定の確実設定）
            - リスト形式（飛び飛びのデバイス指定を容易に）
            - Phase6(2025-11-21)でMDeviceRange/DDeviceRange形式から変更
            - Random READ全デバイス一括取得方式に対応
        - データ取得元：ConfigurationLoader.LoadPlcConnectionConfig()
        - 参照：Phase6_設定ファイル構造の変更.md（TargetDeviceConfig変更詳細）

    ・SystemResourcesConfig（システムリソース設定）
        - 目的：メモリ・システムリソース制限値の構造化保持
        - プロパティ：
            - MemoryLimitKB（int型、必須）: メモリ使用制限（デフォルト：102400KB = 100MB）
            - MaxBufferSize（int型、必須）: 最大バッファサイズ（デフォルト：8192B = 8KB）
            - MemoryThresholdKB（int型、必須）: メモリ警告閾値（デフォルト：81920KB = 80MB）
            - LowMemoryMode（bool型、必須）: 低メモリモード（デフォルト：false = 無効）
        - コンストラクタ：
            - デフォルト：初期状態（100MB制限、8KBバッファ、80MB閾値、低メモリモード無効）
            - 完全指定：SystemResourcesConfig(int, int, int, bool)
        - 設計方針：
            - 全プロパティnull不許容（リソース制限の確実設定）
            - 実用的制限値（100MB制限で本格運用対応）
            - KB単位（精密なメモリ管理）

    ・DataProcessingConfig（データ処理設定）
        - 目的：データ処理動作設定の構造化保持
        - プロパティ：
            - TargetName（string型、必須）: 処理対象名称（デフォルト："DefaultTarget"）
            - ContinuousDataMode（bool型、必須）: 継続データモード（デフォルト：true = 有効）
            - DataRetentionDays（int型、必須）: データ保持期間（デフォルト：30日）
        - コンストラクタ：
            - デフォルト：初期状態（DefaultTarget、継続モード有効、30日保持）
            - 完全指定：DataProcessingConfig(string, bool, int)
        - 設計方針：
            - 全プロパティnull不許容（処理設定の確実設定）
            - 継続モード優先（連続データ処理対応）
            - 適切な保持期間（30日で運用バランス）

    ・LoggingConfig（ログ設定）
        - 目的：ログ出力動作設定の構造化保持
        - プロパティ：
            - ConsoleOutput（bool型、必須）: コンソール出力有効性（デフォルト：true = 有効）
            - DetailedLog（bool型、必須）: 詳細ログ出力有効性（デフォルト：true = 有効）
        - コンストラクタ：
            - デフォルト：初期状態（コンソール出力有効、詳細ログ有効）
            - 完全指定：LoggingConfig(bool, bool)
        - 設計方針：
            - 全プロパティnull不許容（ログ設定の確実設定）
            - 開発・運用両対応（コンソール・詳細ログ両方有効）
            - シンプル構成（必要最小限のログ制御）

    ・DataTransferConfig（データ転送設定）
        - 目的：外部データ転送機能設定の構造化保持
        - プロパティ：
            - EnableTransfer（bool型、必須）: データ転送機能有効性（デフォルト：false = 無効）
            - DestinationIpAddress（string型、必須）: 転送先IPアドレス（デフォルト："" = 空文字）
            - DestinationPort（int型、必須）: 転送先ポート番号（デフォルト：0 = 未指定）
        - コンストラクタ：
            - デフォルト：初期状態（転送無効、IP・ポート未指定）
            - 完全指定：DataTransferConfig(bool, string, int)
        - 設計方針：
            - 全プロパティnull不許容（転送設定の確実設定）
            - セキュリティ優先（デフォルト無効、明示的設定必須）
            - 空値デフォルト（使用時の明示的設定強制）

    ・DeviceEntry（設定ファイル読み込み専用デバイスエントリ）
        - 目的：appsettings.json読み込み時の中間型として使用（ConfigurationLoader専用）
        - 配置：Core/Models/ConfigModels/DeviceEntry.cs
        - プロパティ：
            - DeviceType（string型、必須）: デバイス種別（"M", "D", "W", "X", "Y"等）
            - DeviceNumber（int型、必須）: デバイス番号（10進数または16進数）
            - IsHexAddress（bool型、必須）: 16進アドレス指定フラグ（デフォルト：false = 10進数）
            - Description（string型、null許容）: デバイスの説明（設定ファイル内の可読性向上用）
        - コンストラクタ：
            - デフォルト：初期状態（空値）
            - 完全指定：DeviceEntry(string deviceType, int deviceNumber, bool isHexAddress = false, string? description = null)
        - メソッド：
            - ToDeviceSpecification(): DeviceSpecificationに変換
              ```csharp
              public DeviceSpecification ToDeviceSpecification()
              {
                  // DeviceTypeからDeviceCodeへの変換
                  var deviceCode = DeviceType switch
                  {
                      "M" => DeviceCode.M,
                      "D" => DeviceCode.D,
                      "W" => DeviceCode.W,
                      "X" => DeviceCode.X,
                      "Y" => DeviceCode.Y,
                      // ... 他のデバイスタイプ
                      _ => throw new ArgumentException($"不正なDeviceType: {DeviceType}")
                  };
                  return new DeviceSpecification(deviceCode, DeviceNumber);
              }
              ```
        - 使用箇所：ConfigurationLoader.LoadPlcConnectionConfig()
        - 設計方針：
            - **アプリケーション内部ではDeviceSpecificationのみ使用**（DeviceEntryは設定読み込み時のみ）
            - ConfigurationLoaderで即座にDeviceSpecificationに変換
            - TargetDeviceConfig.DevicesはList<DeviceSpecification>型（変換済み）
            - 16進数アドレス対応（W0x11AA等）
            - 飛び飛びのデバイス指定を容易にする構造
        - データ取得元：appsettings.json（PlcCommunication.TargetDevices.Devices配列）
        - 参照：Phase6_設定ファイル構造の変更.md（DeviceEntry実装詳細）

    ・RandomReadDeviceSpec（Random READデバイス指定情報）
        - 目的：Random READコマンドの個別デバイス指定情報保持
        - プロパティ：
            - DeviceCode（string型、必須）: デバイスコード（例: "A8" = Dデバイス、"90" = Mデバイス）
            - DeviceNumber（int型、必須）: デバイス番号（例: 0 = D0、100 = D100）
            - WordCount（int型、必須）: ワード数（1 = ワード、2 = ダブルワード）
        - コンストラクタ：
            - 完全指定：RandomReadDeviceSpec(string deviceCode, int deviceNumber, int wordCount)
        - 設計方針：
            - SLMP Random READ仕様準拠（pdf2img/page_53-55）
            - シンプル構造（必要最小限のプロパティ）
            - バイナリフレーム生成に直接利用可能

    ・ProcessedDeviceRequestInfo（**テスト専用**デバイス要求情報）
        - **⚠️ 重要：本クラスはテスト専用です。本番実装ではReadRandomRequestInfoを使用してください**
        - 目的：TC029/TC037テスト用のデバイス要求情報保持
        - 配置：Core/Models/ProcessedDeviceRequestInfo.cs
        - プロパティ：
            - DeviceType（string型、必須）: デバイス型（"D", "M", "X", "Y"等）
            - StartAddress（int型、必須）: 開始アドレス
            - Count（int型、必須）: 要求デバイス数
            - FrameType（FrameType型、必須）: フレーム型
        - コンストラクタ：
            - デフォルト：初期状態（空値）
            - 完全指定：ProcessedDeviceRequestInfo(string deviceType, int startAddress, int count, FrameType frameType)
        - 使用箇所：
            - **テストのみ**: TC029テスト実装、TC037構造化処理
            - **本番実装では使用禁止**: ExecutionOrchestratorではReadRandomRequestInfoを使用
        - 設計方針：
            - Phase4仕様変更(2025-11-20)により構造を簡素化
            - Random READ一括取得方式に対応
            - 旧設計のRandomReadDeviceList/BitDeviceRanges/DeviceTypeClassificationプロパティは廃止
            - **Phase12対応(2025-12-02)**: テスト専用位置づけ明確化
        - 参照：Phase4_通信マネージャーの修正.md、Phase12_ProcessedDeviceRequestInfo恒久対策.md

    ・ReadRandomRequestInfo（**本番実装用**ReadRandom専用リクエスト情報）
        - **⚠️ Phase12追加**: ReadRandom(0x0403)専用の本番実装用クラス
        - 目的：ReadRandom実行時のリクエスト情報を明確に表現
        - 配置：Core/Models/ReadRandomRequestInfo.cs
        - プロパティ：
            - DeviceSpecifications（List<DeviceSpecification>型、必須）: 読み取り対象デバイスリスト
            - FrameType（FrameType型、必須）: SLMPフレーム型（3E/4E）
            - RequestedAt（DateTime型、必須）: リクエスト生成日時（UTC）
        - コンストラクタ：
            - デフォルト：空リスト初期化、現在時刻自動設定
        - 使用箇所：
            - ExecutionOrchestrator.ExecuteSinglePlcCycleAsync_Internal() → ReadRandomRequestInfo生成
            - PlcCommunicationManager.ExecuteFullCycleAsync() → 引数として受け取り
        - 設計方針：
            - ReadRandom(0x0403)の仕様に完全準拠（複数デバイス型混在、不連続アドレス対応）
            - ProcessedDeviceRequestInfoとの責務分離（テスト用 vs 本番用）
            - Phase8.5暫定対策の恒久化（DeviceSpecifications再導入の根本解決）
        - 参照：Phase12_ProcessedDeviceRequestInfo恒久対策.md

    ・MultiPlcConfig（複数PLC設定のルート）
        - 目的：複数台のPLC設定を統合管理
        - プロパティ：
            - PlcConnections（List<PlcConnectionConfig>型、必須）: 各PLC接続設定リスト（デフォルト：new()）
            - ParallelConfig（ParallelProcessingConfig型、必須）: 並列処理設定（デフォルト：new()）
        - コンストラクタ：
            - デフォルト：初期状態（空のPLCリスト、デフォルト並列設定）
        - 設計方針：
            - 複数PLC設定の一元管理
            - 並列/順次実行モードの柔軟な切り替え
            - ExecutionOrchestrator.ExecuteMultiPlcCycleAsync()への入力

    ・ParallelProcessingConfig（並列処理設定）
        - 目的：複数PLC並列実行の制御設定
        - プロパティ：
            - EnableParallel（bool型、必須）: 並列実行有効性（デフォルト：true）
            - MaxDegreeOfParallelism（int型、必須）: 最大並列度（デフォルト：0 = 無制限）
            - OverallTimeoutMs（int型、必須）: 全体タイムアウト（デフォルト：30000ms = 30秒）
        - コンストラクタ：
            - デフォルト：初期状態（並列有効、無制限並列度、30秒タイムアウト）
            - 完全指定：ParallelProcessingConfig(bool, int, int)
        - 設計方針：
            - Task.WhenAll並列実行制御
            - タイムアウトによる全体実行時間保証
            - ConMoni3互換の順次実行モードサポート（EnableParallel=false）

    ・PlcConnectionConfig（個別PLC接続設定、既存ConnectionConfig拡張）
        - 目的：個別PLC識別・優先度管理
        - 追加プロパティ（既存ConnectionConfigプロパティに加えて）：
            - PlcId（string型、必須）: PLC識別子（例："PLC_A", "PLC_B"）
            - PlcName（string型、必須）: PLC名称（例："生産ライン1号機"）
            - Priority（int型、必須）: 実行優先度（数値が大きいほど優先、デフォルト：0）
            - Devices（List<DeviceSpecification>型、必須）: 読み出しデバイスリスト
            - FrameVersion（FrameVersion型、必須）: 3E/4Eフレーム選択（デフォルト：Frame4E）
            - Timeout（int型、必須）: 監視タイマ（250ms単位、デフォルト：32 = 8秒）
        - 継承関係：ConnectionConfigのプロパティ（IpAddress, Port, UseTcp等）を全て含む
        - コンストラクタ：
            - デフォルト：初期状態（Priority=0、デフォルト接続設定）
            - 完全指定：PlcConnectionConfig(string plcId, string plcName, int priority, ConnectionConfig baseConfig, List<DeviceSpecification> devices)
        - 設計方針：
            - 既存ConnectionConfigとの互換性維持
            - 優先度順実行（OrderByDescending(p => p.Priority)）
            - 複数PLC環境での識別性確保
            - MultiPlcCoordinator.ExecuteParallelAsync()での使用

- Core/Models（PlcCommunicationManager用データ転送オブジェクト）
機能概要：PLC通信メソッドの入出力データ構造化、型安全性確保、null安全性管理
詳細機能：
    ・接続処理結果データ保持
    ・通信統計データ保持
    ・データ処理結果保持
    ・構造化データ保持

- Core/Models（ApplicationController用データ転送オブジェクト）
機能概要：アプリケーション制御メソッドの入出力データ構造化、実行結果保持、ライフサイクル状態管理
詳細機能：
    ・初期化処理結果データ保持
    ・サイクル実行結果データ保持
    ・終了処理結果データ保持
クラス・列挙型：

    ・InitializationResult（ApplicationController.ExecuteStep1InitializationAsync戻り値）
        - 目的：Step1初期化フェーズの実行結果保持
        - プロパティ：
            - Success（bool型、必須）: 初期化成功フラグ
            - PlcCount（int型、必須）: 初期化対象PLC数
            - ErrorMessage（string型、null許容）: エラーメッセージ（失敗時のみ設定、成功時はnull）
        - 設計方針：
            - シンプルな成功/失敗判定（Successフラグ）
            - PLC数のみを保持（PlcCount）
            - エラー時のメッセージ記録（ErrorMessage）

    ・CycleExecutionResult（ExecutionOrchestrator.ExecuteSingleCycleAsync戻り値）
        - 目的：Step2-7単一サイクル実行結果保持
        - プロパティ：
            - IsSuccess（bool型、必須）: サイクル実行成功フラグ
            - ExecutedSteps（List<string>型、必須）: 実行完了したステップ一覧（例：["Step2", "Step3", "Step4", "Step5", "Step6", "Step7"]）
            - ExecutionTime（TimeSpan型、必須）: サイクル全体の実行時間
            - DataCount（int型、必須）: 処理されたデバイスデータ数
            - PlcIdentifier（string型、必須）: 対象PLCの識別子
            - ErrorDetails（string型、null許容）: エラー詳細（失敗時のみ設定、成功時はnull）
            - StepResults（Dictionary<string, object>型、必須）: 各ステップの実行結果詳細
                構造例: { "Step2": { "FrameCount": 3, "ExecutionTime": "00:00:00.1" }, "Step3": { "ConnectionTime": "00:00:01.2" } }
            - WarningMessages（List<string>型、必須）: 警告メッセージ一覧（成功だが注意が必要な事項）
        - コンストラクタ：
            - 成功時用：CycleExecutionResult(List<string> steps, TimeSpan time, int dataCount, string plcId, Dictionary<string, object> stepResults)
            - 失敗時用：CycleExecutionResult(string plcId, string errorDetails, List<string> completedSteps)
        - メソッド：
            - AddStepResult(string stepName, object result): ステップ結果追加
            - AddWarning(string message): 警告メッセージ追加
            - GetStepResult<T>(string stepName): 指定ステップ結果取得
        - 設計方針：
            - 部分成功対応（一部ステップ失敗でも完了ステップ情報保持）
            - ステップ別詳細情報（デバッグ・最適化支援）
            - PLC識別情報（並行実行時の追跡可能性）

    ・ShutdownResult（GracefulShutdownHandler.ExecuteGracefulShutdown戻り値）
        - 目的：アプリケーション終了処理結果保持
        - プロパティ：
            - IsGraceful（bool型、必須）: 適切な終了処理完了フラグ
            - ShutdownTime（TimeSpan型、必須）: 終了処理にかかった時間
            - CompletedTasks（List<string>型、必須）: 完了した終了タスク一覧
                例：["ApplicationController.StopAsync", "PlcConnections.Disconnect", "LogFiles.Flush", "Resources.Release"]
            - IncompleteTaskCount（int型、必須）: 未完了タスク数（タイムアウト時）
            - IncompleteTaskDetails（List<string>型、必須）: 未完了タスク詳細一覧
            - FinalResourceState（Dictionary<string, string>型、必須）: 最終リソース状態
                構造例: { "PlcConnections": "Disconnected", "LogFiles": "Flushed", "Memory": "Released" }
            - ShutdownTrigger（string型、必須）: 終了契機（例："Ctrl+C", "ProcessExit", "Manual"）
        - コンストラクタ：
            - 正常終了用：ShutdownResult(TimeSpan time, List<string> completed, Dictionary<string, string> state, string trigger)
            - タイムアウト終了用：ShutdownResult(TimeSpan time, List<string> completed, int incomplete, List<string> details, string trigger)
        - 設計方針：
            - 終了処理の透明性確保（何が完了し、何が未完了かの明確化）
            - タイムアウト対応（強制終了時の状況把握）
            - リソース状態追跡（メモリリーク防止・デバッグ支援）

    ・ResponseType（列挙型）
        - 目的：応答データタイプの型安全な表現
        - 値：
            - BitDevice: ビットデバイス応答（READコマンド(0401)レスポンス）
            - WordDevice: ワードデバイス応答（Random READコマンド(0403)レスポンス）
        - 使用箇所：PlcCommunicationManager.ProcessReceivedRawData()

    ・ConnectionStatus（列挙型）
        - 目的：PLC接続状態の型安全な表現
        - 値：
            - Connected: 接続成功
            - Failed: 接続失敗（一般的な失敗）
            - Timeout: 接続タイムアウト
        - 使用箇所：ConnectionResponse.Status

    ・ConnectionResponse（PlcCommunicationManager.ConnectAsync戻り値）
        - 目的：PLC接続処理結果の構造化保持
        - プロパティ：
            - Status（ConnectionStatus型、必須）: 接続状態（Connected/Failed/Timeout）
            - Socket（System.Net.Sockets.Socket型、null許容）: 通信用ソケット（接続成功時のみ設定、失敗時はnull）
            - RemoteEndPoint（System.Net.EndPoint型、null許容）: 接続先エンドポイント（接続成功時のみ設定、失敗時はnull）
            - ConnectedAt（DateTime型、null許容）: 接続完了時刻（接続成功時のみ設定、失敗時はnull）
            - ConnectionTime（TimeSpan型、null許容）: 接続処理時間（接続成功時のみ設定、失敗時はnull）
            - ErrorMessage（string型、null許容）: エラーメッセージ（接続失敗時のみ設定、成功時はnull）
            - UsedProtocol（string型、null許容）: 実際に使用されたプロトコル（"TCP"/"UDP"、通信形式スイッチトライ機能で追加予定）
            - IsFallbackConnection（bool型、必須、デフォルト：false）: 代替プロトコルで接続したか（通信形式スイッチトライ機能で追加予定）
            - FallbackErrorDetails（string型、null許容）: 初期プロトコル失敗時のエラー詳細（通信形式スイッチトライ機能で追加予定）
        - コンストラクタ：
            - デフォルト：初期状態（Status=Failed）
            - 成功時用：ConnectionResponse(Socket, EndPoint, TimeSpan)
            - 失敗時用：ConnectionResponse(ConnectionStatus, string)
        - 設計方針：
            - 接続成功/失敗で異なるプロパティのnull許容性管理
            - 論理的整合性（成功時はErrorMessage=null、失敗時はSocket=null等）
            - 型安全性（ConnectionStatus列挙型使用）

    ・ConnectionStats（PlcCommunicationManager.DisconnectAsync戻り値）
        - 目的：PLC切断時の通信統計情報保持
        - プロパティ：
            【基本通信統計】
            - TotalConnectionTime（TimeSpan型、必須）: 総接続時間（接続開始から切断までの合計時間）
            - TotalFramesSent（int型、必須）: 送信フレーム総数（PLCに送信したメッセージの回数）
            - TotalFramesReceived（int型、必須）: 受信フレーム総数（PLCから受信したメッセージの回数）
            - TotalBytesSent（long型、必須）: 送信バイト総数（PLCに送信したデータの総サイズ）
            - TotalBytesReceived（long型、必須）: 受信バイト総数（PLCから受信したデータの総サイズ）
            - DisconnectedAt（DateTime型、必須）: 切断時刻（切断処理を実行した時刻）
            【応答時間統計】
            - ResponseTimes（List<TimeSpan>型、必須）: 応答時間履歴（各通信の応答時間の記録リスト）
            - AverageResponseTime（TimeSpan型、必須）: 平均応答時間（ResponseTimesから自動計算）
            - MaxResponseTime（TimeSpan型、必須）: 最大応答時間（ResponseTimesから自動計算）
            - MinResponseTime（TimeSpan型、必須）: 最小応答時間（ResponseTimesから自動計算）
            【エラー・品質統計】
            - TotalErrors（int型、必須）: エラー発生回数（通信エラー、タイムアウト等の総数）
            - TotalRetries（int型、必須）: リトライ実行回数（エラー後の再試行回数）
            - SuccessRate（double型、必須）: 通信成功率（0.0-1.0の範囲、自動計算）
        - コンストラクタ：
            - デフォルト：初期状態（全統計値0）
            - 統計計算用：ConnectionStats(DateTime, List<TimeSpan>, int, int, long, long, int, int)
        - メソッド：
            - AddResponseTime(TimeSpan): 応答時間追加・統計再計算
            - IncremetError(): エラー発生時の統計更新
            - IncrementRetry(): リトライ実行時の統計更新
        - 設計方針：
            - 全プロパティnull不許容（切断処理時の確実なデータ存在）
            - 統計自動計算機能（応答時間統計、成功率の自動算出）
            - リアルタイム統計更新（AddResponseTime等での動的更新）

    ・ProcessedResponseData（PlcCommunicationManager.ProcessReceivedRawData戻り値）
        - 目的：受信生データの処理結果保持（最終データ）
        - プロパティ：
            【基本処理結果】
            - OriginalRawData（string型、必須）: 元の受信生データ（16進数文字列）
            - ProcessedData（Dictionary<string, DeviceData>型、必須）: 処理済みデータ（デバイス名キー + 型情報構造）
                構造例: { "M000": DeviceData(true, "Bit"), "D000": DeviceData(0x1234, "Word"), "D002": DeviceData(0x56781234, "DWord") }
            - OriginalRequest（ProcessedDeviceRequestInfo型、必須）: 元のリクエスト情報
            - ProcessedAt（DateTime型、必須）: 処理実行時刻
            【エラー情報】
            - HasErrors（bool型、必須）: エラー発生フラグ
            - Errors（List<string>型、必須）: エラーメッセージリスト
            - Warnings（List<string>型、必須）: 警告メッセージリスト
            【統計情報（自動計算）】
            - ProcessedDeviceCount（int型、必須）: 処理されたデバイス数（= ProcessedData.Count）
            - BitDeviceCount（int型、必須）: ビットデバイス数（ProcessedDataから算出）
            - WordDeviceCount（int型、必須）: ワードデバイス数（ProcessedDataから算出）
            - DWordDeviceCount（int型、必須）: ダブルワードデバイス数（OriginalRequest.RandomReadDeviceListから算出）
        - コンストラクタ：
            - デフォルト：初期状態（空のデータ構造）
            - 基本情報指定：ProcessedResponseData(string, ProcessedDeviceRequestInfo)
            - 完全指定：ProcessedResponseData(string, ProcessedDeviceRequestInfo, Dictionary<string, DeviceData>)
        - メソッド：
            【データ操作】
            - AddProcessedDevice(string, object, string): デバイスデータ追加
            - AddError(string): エラーメッセージ追加
            - AddWarning(string): 警告メッセージ追加
            【データ取得】
            - GetDeviceValue(string): 指定デバイスの値取得
            - GetDeviceType(string): 指定デバイスのデータ型取得
            - GetBitDevices(): ビットデバイス一覧取得
            - GetWordDevices(): ワードデバイス一覧取得
            - GetDWordDevices(): ダブルワードデバイス一覧取得（OriginalRequest.RandomReadDeviceListから取得）
        - 設計方針：
            - 全プロパティnull不許容（処理確実実行によるデータ存在保証）
            - デバイス名キー構造（PLC技術者にとって直感的アクセス）
            - 型情報保持（DeviceDataクラスで明示的に保持）
            - **Random READ応答は既にDWord形式**（結合処理不要）
            - **応答統合処理不要**（1回の受信で全デバイス取得完了）
            - DWordDeviceCountはOriginalRequest.RandomReadDeviceListから算出（応答からは判別不可）

    ・DeviceData（デバイスデータ専用クラス）
        - 目的：Random READレスポンスの個別デバイスデータと型情報の保持
        - 配置：Core/Models/DeviceData.cs
        - プロパティ：
            - DeviceName（string型、必須）: デバイス名（"M000", "D000", "W0x11AA"等）
            - Code（DeviceCode型、必須）: デバイスコード
            - Address（int型、必須）: デバイス番号（アドレス）
            - Value（uint型、必須）: デバイス値（16bit: ワードデバイス、32bit: ダブルワードデバイス）
            - IsDWord（bool型、必須）: ダブルワードデバイスフラグ
            - IsHexAddress（bool型、必須）: 16進アドレス表記フラグ
        - コンストラクタ：
            - デフォルト：初期状態（空値）
            - 完全指定：DeviceData(string deviceName, DeviceCode code, int address, uint value, bool isDWord, bool isHexAddress)
        - 静的メソッド：
            - FromDeviceSpecification(DeviceSpecification device, ushort value): ワードデバイスから生成
            - FromDWordDevice(DeviceSpecification device, ushort lowerWord, ushort upperWord): ダブルワードデバイスから生成（2ワード結合）
        - 使用箇所：
            - ProcessedResponseData.ProcessedData（Dictionary<string, DeviceData>型）
            - StructuredData.DeviceData（Dictionary<string, DeviceData>型）
        - 設計方針：
            - 全プロパティnull不許容（型安全性確保）
            - デバイス名キー構造（"M000", "D000", "D002"）による直感的アクセス
            - ビット・ワード・ダブルワード混在対応
            - Phase5(2025-11-21)実装
            - Random READ全デバイス一括取得方式の核心的なデータ構造
        - 参照：Phase5_レスポンス処理の修正.md（DeviceData実装詳細）

    ・SlmpHeader（SLMPヘッダー情報専用クラス）
        - 目的：SLMP通信プロトコルの標準ヘッダー情報を完全保持
        - プロパティ：
            【標準SLMP情報】
            - SubHeader（string型、必須）: サブヘッダー（通信形式識別、例："5400"）
            - NetworkNumber（string型、必須）: ネットワーク番号（ネットワーク識別、例："01"）
            - StationNumber（string型、必須）: 局番号（機器識別、例："00"）
            - ModuleIONumber（string型、必須）: モジュールI/O番号（例："03FF"）
            - MultidropNumber（string型、必須）: マルチドロップ局番号（例："00"）
            - RequestDataLength（string型、必須）: 要求データ長（例："001B"）
            【解析情報】
            - ParsedAt（DateTime型、必須）: ヘッダー解析時刻
            - FrameType（string型、必須）: フレームタイプ（"3E" or "4E"）
            - IsBinary（bool型、必須）: バイナリ形式フラグ
        - コンストラクタ：
            - デフォルト：基本値設定（3Eフレーム、バイナリ形式）
            - 基本情報指定：SlmpHeader(string, string, string, string, string, bool)
        - 設計方針：全プロパティnull不許容（SLMP標準情報の完全保持）

    ・StructuredData（PlcCommunicationManager.ParseRawToStructuredData戻り値）
        - 目的：SLMPレスポンスの構造化解析結果保持
        - プロパティ：
            【基本構造化データ】
            - Header（SlmpHeader型、必須）: SLMPヘッダー情報（全標準情報含む）
            - EndCode（string型、必須）: 終了コード（正常:"0000", エラー:エラーコード）
            - DeviceData（Dictionary<string, DeviceData>型、必須）: デバイスデータ（デバイス名キー構造）
                構造例: { "M000": DeviceData(...), "D000": DeviceData(...), "D002": DeviceData(...) }
            - ReceivedAt（DateTime型、必須）: 受信時刻
            - IsError（bool型、必須）: エラー応答フラグ
            - ErrorMessage（string型、null許容）: エラーメッセージ（エラー時のみ設定、正常時はnull）
            【解析詳細情報】
            - SourceData（ProcessedResponseData型、必須）: 元の後処理データ
            - ParseSteps（List<string>型、必須）: 解析手順の記録
            - InterpretationInfo（Dictionary<string, string>型、必須）: 解釈情報
            - ParsingTime（TimeSpan型、必須）: 解析にかかった時間
            - TotalDevices（int型、必須）: 解析されたデバイス総数
            - DeviceInterpretations（Dictionary<string, object>型、必須）: 人間が読める形式
            - StatusJudgments（Dictionary<string, string>型、必須）: ON/OFF、正常/異常判定
            【エラー詳細情報（null許容）】
            - DetailedErrorCode（string型、null許容）: 詳細エラーコード（エラー時のみ設定）
            - ErrorDescription（string型、null許容）: エラーの説明（エラー時のみ設定）
            - AffectedDevices（List<string>型、null許容）: 影響を受けたデバイス（エラー時のみ設定）
            - ErrorDetails（Dictionary<string, object>型、null許容）: エラーの詳細情報（エラー時のみ設定）
        - コンストラクタ：
            - デフォルト：初期状態（空のデータ構造）
            - 基本情報指定：StructuredData(SlmpHeader, string, ProcessedResponseData)
        - メソッド：
            【データ操作】
            - AddStructuredDevice(string, object, string, bool): 構造化デバイスデータ追加
            - AddParseStep(string): 解析手順追加
            - AddDeviceInterpretation(string, object): デバイス解釈情報追加
            - AddStatusJudgment(string, string): ステータス判定追加
            - SetErrorDetails(string, string, List<string>, Dictionary<string, object>): エラー詳細設定
            【データ取得】
            - GetDeviceValue(string): 指定デバイスの値取得
            - GetDeviceInterpretation(string): 指定デバイスの解釈情報取得
            - GetStatusJudgment(string): 指定デバイスのステータス判定取得
            - GetAllDeviceNames(): 全デバイス名取得
            - GetErrorDevices(): エラー発生デバイス一覧取得
        - 設計方針：
            - 基本・解析詳細情報はnull不許容（構造化データの確実存在）
            - エラー詳細情報はnull許容（エラー時のみ設定）
            - ProcessedResponseDataとの一貫性（DeviceData構造統一）
            - 包括的なSLMP情報保持（デバッグ・運用監視の完全支援）


- アプリケーション制御・継続実行モード
機能概要：アプリケーション全体のライフサイクル管理、Step1初期化フェーズ実行、Step2-7データ処理サイクルの継続実行制御
基本方針：
    ・実行モード：継続実行モードのみ（動作フロー準拠）
    ・制御方式：.NET HostedService使用
    ・複数PLC対応：並行実行（全PLC同時にStep2-7実行）
    ・エラー継続方針：1つのPLCでエラーが発生しても他のPLCは継続
    ・設定変更対応：後から実装予定（現時点では対応しない）
    ・MonitoringIntervalMs：設定ファイルで指定された方式に従う
詳細機能：
    ・アプリケーション全体統合制御
        - データ取得元：Program.cs（DIコンテナからのインスタンス取得）、IHostedService（.NETランタイム制御）
    ・Step1初期化フェーズ実行制御
        - データ取得元：MultiConfigManager.LoadAllFromDirectoryAsync()（複数設定ファイル読み込み）、各種Managerクラスのインスタンス作成
    ・Step2-7データ処理サイクル継続実行制御
        - データ取得元：ExecutionOrchestrator.RunContinuousDataCycleAsync()（サイクル実行）、AndonHostedService（バックグラウンド実行）
    ・複数PLC並行処理制御
        - データ取得元：MultiConfigManager.CreateManagersAsync()（軽量インスタンス配列）、Task.WhenAll()（並行実行制御）
    ・エラー発生時継続処理制御
        - データ取得元：ErrorHandler.ApplyErrorPolicy()（エラー処理方針）、各PLC個別の実行状態管理

クラス：ApplicationController
メソッド：
    ・StartAsync（アプリケーション開始処理）
        - Input:
            - CancellationToken（キャンセレーション制御：Program.cs、GracefulShutdownHandlerから取得）
        - Output:
            - Task（非同期実行完了状態）
        - 処理内容：
            - Step1初期化フェーズ実行（ExecuteStep1InitializationAsync()）
            - Step2-7継続実行開始（StartContinuousDataCycleAsync()）
        - データ取得元：IServiceProvider（DIコンテナ）、IHostedService（.NETランタイム）

    ・StopAsync（アプリケーション停止処理）
        - Input:
            - CancellationToken（停止制御：GracefulShutdownHandlerから取得）
        - Output:
            - Task（非同期停止完了状態）
        - 処理内容：
            - 実行中サイクルの適切な停止
            - 各Managerクラスのリソース解放
            - PLC接続の適切な切断
        - データ取得元：ExecutionOrchestrator（実行状態）、各Managerクラス（リソース状態）

    ・ExecuteStep1InitializationAsync（Step1初期化フェーズ実行）
        - Input:
            - 設定ディレクトリパス（string型：Program.csから取得、デフォルト："./config/"）
        - Output:
            - InitializationResult（初期化結果オブジェクト）
                - LoadedConfigCount（読み込み設定ファイル数）
                - CreatedManagersCount（作成されたManagerインスタンス数）
                - InitializationTime（初期化処理時間）
                - IsSuccess（初期化成功フラグ）
                - ErrorDetails（初期化エラー詳細：失敗時のみ）
        - 処理内容：
            - 複数設定ファイル読み込み（MultiConfigManager.LoadAllFromDirectoryAsync()）
            - 各種Managerクラスインスタンス作成
            - 初期化検証・ヘルスチェック
        - データ取得元：MultiConfigManager（複数設定ファイル管理）、DIコンテナ（各Managerインスタンス）

    ・StartContinuousDataCycleAsync（Step2-7継続実行開始）
        - Input:
            - InitializationResult（Step1初期化結果：ExecuteStep1InitializationAsync()から取得）
            - CancellationToken（実行制御：StartAsync()から取得）
        - Output:
            - Task（継続実行タスク）
        - 処理内容：
            - ExecutionOrchestratorインスタンス作成
            - 複数PLC並行実行開始（Task.WhenAll使用）
            - エラー発生時の継続処理制御
        - データ取得元：ExecutionOrchestrator（実行制御）、MultiConfigManager（PLC設定情報）

クラス：ExecutionOrchestrator
機能概要：Step2-7データ処理サイクルの詳細実行制御、MonitoringIntervalMs間隔制御、単一PLC用実行ロジック
メソッド：
    ・RunContinuousDataCycleAsync（継続データサイクル実行）
        - Input:
            - List<IPlcCommunicationManager>（PLC通信管理インスタンスリスト：ApplicationController.ExecuteStep1InitializationAsync()で初期化された_plcManagers）
            - CancellationToken（実行制御：ApplicationController.StartContinuousDataCycleAsync()から取得）
        - Output:
            - Task（継続実行タスク：エラー発生またはキャンセル時まで継続）
        - 処理内容：
            - TimerService使用によるMonitoringIntervalMs間隔制御
            - ExecuteMultiPlcCycleAsync_Internal()を周期的に呼び出し
            - 内部実装（ExecuteMultiPlcCycleAsync_Internal）で以下のStep2-7を繰り返し実行：
                - 各PlcCommunicationManagerに対して順次または並列実行
                - Step2: フレーム構築（ConfigToFrameManager経由）
                - Step3-6: ExecuteFullCycleAsync()またはStep3-5サイクル + データ処理
                - Step7: DataOutputManager.OutputToJson()
            - エラー発生時の継続判定・ログ出力
        - データ取得元：TimerService（間隔制御）、各PlcCommunicationManager（通信処理）
        - **重要**: Random READ(0x0403)コマンドでビット・ワード・ダブルワード全デバイスを1回で一括取得
        - **実装状況**: インターフェース実装済み、内部ロジック（ExecuteMultiPlcCycleAsync_Internal）は未実装

    ・GetMonitoringInterval（監視間隔取得）
        - Input:
            - なし（内部フィールド _dataProcessingConfig から取得）
        - Output:
            - TimeSpan（監視間隔：MonitoringIntervalMs設定値をTimeSpanに変換）
        - 処理内容：
            - _dataProcessingConfig.Value.MonitoringIntervalMs を TimeSpan に変換
        - データ取得元：IOptions<DataProcessingConfig>（DI注入された設定）

    ・ExecuteMultiPlcCycleAsync（複数PLC並列実行）
        - Input:
            - MultiPlcConfig（複数PLC設定：PlcConnections + ParallelConfig）
            - CancellationToken（実行制御）
        - Output:
            - MultiPlcExecutionResult（複数PLC実行結果）
                - PlcResults（Dictionary<PlcId, PlcExecutionResult>）
                - SuccessCount, FailureCount, TotalDuration
        - 処理内容:
            - ParallelConfig.EnableParallelによる並列/順次処理の振り分け
            - MultiPlcCoordinator.ExecuteParallelAsync()またはExecuteSequentialAsync()呼び出し
            - 結果集計（成功数、失敗数、全体実行時間）
        - データ取得元：MultiPlcCoordinator（並列実行調整）、PlcCommunicationManager（各PLC通信）

クラス：MultiPlcCoordinator
機能概要：複数PLC並列実行調整ヘルパー、Task.WhenAll/順次処理の切り替え
配置：Core/Managers/MultiPlcCoordinator.cs
クラス種別：静的ヘルパークラス（約50行）
メソッド：
    ・ExecuteParallelAsync（並列実行）
        - Input:
            - List<PlcConnectionConfig>（PLC設定リスト）
            - ParallelProcessingConfig（並列処理設定）
            - CancellationToken（実行制御）
        - Output:
            - List<PlcExecutionResult>（各PLC実行結果リスト）
        - 処理内容：
            - 優先度順でタスク生成（OrderByDescending(p => p.Priority)）
            - Task.WhenAllで並列実行
            - 全体タイムアウト制御（OverallTimeoutMs）
        - データ取得元：PlcCommunicationManager.ExecuteStep3to5CycleAsync()（既存メソッド活用）

    ・ExecuteSequentialAsync（順次実行）
        - Input:
            - List<PlcConnectionConfig>（PLC設定リスト）
            - CancellationToken（実行制御）
        - Output:
            - List<PlcExecutionResult>（各PLC実行結果リスト）
        - 処理内容：
            - foreach順次処理（ConMoni3互換）
            - 各PLC処理後に10msスロットリング
        - データ取得元：PlcCommunicationManager.ExecuteStep3to5CycleAsync()（既存メソッド活用）

    ・ExecuteSinglePlcAsync（単一PLC処理、private）
        - Input:
            - PlcConnectionConfig（PLC設定）
            - CancellationToken（実行制御）
        - Output:
            - PlcExecutionResult（単一PLC実行結果）
        - 処理内容：
            - PlcCommunicationManagerインスタンス生成
            - ConnectionConfig, TimeoutConfig変換
            - SlmpFrameBuilder.BuildReadRandomRequest()でフレーム構築
            - ExecuteStep3to5CycleAsync()で通信実行
            - 例外処理とエラーログ記録
        - データ取得元：既存の全通信インフラを再利用

クラス：AndonHostedService（.NET HostedService実装）
機能概要：.NET HostedServiceとしてのバックグラウンド実行、ApplicationControllerのライフサイクル管理
継承関係：BackgroundService（.NET標準）を継承
メソッド：
    ・ExecuteAsync（バックグラウンド実行メイン処理）
        - Input:
            - CancellationToken（.NETランタイムから取得）
        - Output:
            - Task（バックグラウンド実行タスク）
        - 処理内容：
            - ApplicationController.StartAsync()実行
            - CancellationToken監視による適切な終了制御
        - データ取得元：ApplicationController（DIで注入）、.NETランタイム（CancellationToken）

    ・StartAsync（HostedService開始処理）
        - Input:
            - CancellationToken（.NETランタイムから取得）
        - Output:
            - Task（開始処理完了状態）
        - 処理内容：
            - 起動ログ出力
            - ApplicationController初期化確認
        - データ取得元：LoggingManager（ログ出力）、ApplicationController（初期化状態）

    ・StopAsync（HostedService停止処理）
        - Input:
            - CancellationToken（.NETランタイムから取得）
        - Output:
            - Task（停止処理完了状態）
        - 処理内容：
            - ApplicationController.StopAsync()実行
            - 停止ログ出力
        - データ取得元：ApplicationController（停止処理）、LoggingManager（ログ出力）

クラス：TimerService
機能概要：MonitoringIntervalMs間隔でのタイマー制御、精密な間隔制御
メソッド：
    ・StartPeriodicExecution（周期実行開始）
        - Input:
            - Func<Task>（実行する非同期処理：Step2-7を1サイクル実行する処理）
            - TimeSpan（実行間隔：ExecutionOrchestrator.GetMonitoringInterval()から取得）
            - CancellationToken（実行制御）
        - Output:
            - Task（周期実行タスク）
        - 処理内容：
            - System.Threading.PeriodicTimer使用
            - 指定間隔での正確な実行制御
            - 前回処理未完了時の重複実行防止
        - データ取得元：PeriodicTimer（.NET標準）、実行対象メソッド

クラス：GracefulShutdownHandler
機能概要：Ctrl+C等のシグナル処理、適切な終了処理実行、リソース解放順序制御
メソッド：
    ・RegisterShutdownHandlers（終了ハンドラ登録）
        - Input:
            - ApplicationController（制御対象：DIで注入）
            - CancellationTokenSource（キャンセレーション制御）
        - Output:
            - 登録完了状態
        - 処理内容：
            - Console.CancelKeyPress登録
            - AppDomain.ProcessExit登録
            - キャンセレーショントークン発行
        - データ取得元：.NETランタイム（シグナル）、ApplicationController（停止処理）

    ・ExecuteGracefulShutdown（適切な終了処理実行）
        - Input:
            - ApplicationController（制御対象）
            - TimeSpan（タイムアウト時間：デフォルト30秒）
        - Output:
            - ShutdownResult（終了処理結果）
        - 処理内容：
            - ApplicationController.StopAsync()実行
            - 各Managerクラスのリソース解放確認
            - タイムアウト制御
        - データ取得元：ApplicationController（停止状態）、各Managerクラス（リソース状態）


- 非同期・並行処理アーキテクチャ
機能概要：.NET Task・async/awaitパターン活用、複数PLC並行処理制御、適切なキャンセレーション管理、共有リソース競合回避
基本方針：
    ・例外ハンドリング：混在型（重要処理は個別、一般処理は一括）
    ・CancellationToken：全非同期メソッドに必須パラメータとして伝達
    ・リソース競合対策：共有リソース（ログファイル等）にSemaphore使用
    ・進捗報告：IProgress<T>使用でリアルタイム進捗表示
    ・TaskScheduler：デフォルトTaskScheduler使用
詳細機能：
    ・階層的例外ハンドリング制御
        - データ取得元：重要処理（PlcCommunicationManager各メソッド）個別例外処理、一般処理（LoggingManager、DataOutputManager）一括例外処理
    ・全メソッドキャンセレーション制御
        - データ取得元：Program.cs（最上位CancellationTokenSource）、GracefulShutdownHandler（シグナル処理）、各非同期メソッド（CancellationToken.ThrowIfCancellationRequested()）
    ・複数PLC並行実行・リソース競合回避
        - データ取得元：Task.WhenAll()（並行実行制御）、Semaphore（共有リソース排他制御）、各PLC専用インスタンス（独立処理）
    ・リアルタイム進捗報告・運用監視支援
        - データ取得元：IProgress<T>（進捗報告）、LoggingManager（状況ログ）、CycleExecutionResult（実行結果）
    ・標準Task実行制御・安定動作保証
        - データ取得元：デフォルトTaskScheduler（.NET標準動作）、ThreadPool（効率的スレッド管理）

クラス：AsyncExceptionHandler
機能概要：階層的例外ハンドリング、重要処理の個別対応、一般処理の一括処理、統一エラーログ出力
メソッド：
    ・HandleCriticalOperationAsync<T>（重要処理用例外ハンドリング）
        - Input:
            - Func<Task<T>>（実行対象の重要処理：PlcCommunicationManager.ConnectAsync(), SendFrameAsync(), ReceiveResponseAsync()等）
            - string（処理名称：エラーログ識別用）
            - CancellationToken（キャンセル制御）
        - Output:
            - AsyncOperationResult<T>（実行結果オブジェクト）
                - IsSuccess（bool型、必須）: 実行成功フラグ
                - Result（T型、null許容）: 実行結果（成功時のみ設定）
                - Exception（Exception型、null許容）: 発生例外（失敗時のみ設定）
                - ExecutionTime（TimeSpan型、必須）: 実行時間
                - OperationName（string型、必須）: 処理名称
        - 処理内容：
            - 個別try-catch実行
            - 詳細例外ログ出力
            - コンテキスト情報保持
            - ErrorHandler.RecordError()連携
        - データ取得元：実行対象メソッド、LoggingManager.LogErrorAsync()（詳細ログ）、ErrorHandler（エラー分類・記録）

    ・HandleGeneralOperationsAsync（一般処理用一括例外ハンドリング）
        - Input:
            - IEnumerable<Func<Task>>（実行対象の一般処理群：LoggingManager.FlushAsync(), DataOutputManager各メソッド等）
            - string（処理グループ名称）
            - CancellationToken（キャンセル制御）
        - Output:
            - GeneralOperationResult（一括実行結果オブジェクト）
                - SuccessCount（int型、必須）: 成功処理数
                - FailureCount（int型、必須）: 失敗処理数
                - TotalExecutionTime（TimeSpan型、必須）: 全体実行時間
                - FailedOperations（List<string>型、必須）: 失敗した処理名一覧
                - Exceptions（List<Exception>型、必須）: 発生例外一覧
        - 処理内容：
            - Task.WhenAll()での一括実行
            - 失敗処理の継続実行
            - 統合例外ログ出力
        - データ取得元：実行対象メソッド群、LoggingManager.LogErrorAsync()（統合ログ）

クラス：CancellationCoordinator
機能概要：CancellationToken階層管理、適切なキャンセル伝達、グレースフル停止制御
メソッド：
    ・CreateHierarchicalToken（階層キャンセレーショントークン作成）
        - Input:
            - CancellationToken（親トークン：Program.cs、GracefulShutdownHandlerから取得）
            - TimeSpan（タイムアウト時間：オプション、処理別タイムアウト設定）
        - Output:
            - CancellationTokenSource（子トークンソース）
        - 処理内容：
            - 親トークンとタイムアウトの組み合わせ
            - 階層的キャンセル制御
        - データ取得元：親CancellationToken、ConfigToFrameManager（タイムアウト設定）

    ・RegisterCancellationCallback（キャンセル時コールバック登録）
        - Input:
            - CancellationToken（対象トークン）
            - Func<Task>（キャンセル時実行処理：リソース解放、接続切断等）
            - string（コールバック名称）
        - Output:
            - CancellationTokenRegistration（登録ハンドル）
        - 処理内容：
            - キャンセル時の適切な清掃処理登録
            - 非同期コールバック対応
        - データ取得元：PlcCommunicationManager.DisconnectAsync()、LoggingManager.FlushAsync()等

クラス：ResourceSemaphoreManager
機能概要：共有リソースの排他制御、ログファイル・設定ファイル競合回避、パフォーマンス最適化
プロパティ：
    ・LogFileSemaphore（SemaphoreSlim型、必須）: ログファイル書き込み用セマフォ（同時アクセス数：1）
    ・ConfigFileSemaphore（SemaphoreSlim型、必須）: 設定ファイル読み込み用セマフォ（同時アクセス数：3）
    ・OutputFileSemaphore（SemaphoreSlim型、必須）: データ出力ファイル用セマフォ（同時アクセス数：2）
メソッド：
    ・ExecuteWithSemaphoreAsync<T>（セマフォ制御付き実行）
        - Input:
            - SemaphoreSlim（対象セマフォ：LogFileSemaphore、ConfigFileSemaphore、OutputFileSemaphore）
            - Func<Task<T>>（実行対象処理）
            - CancellationToken（キャンセル制御）
            - TimeSpan（セマフォ取得タイムアウト：デフォルト30秒）
        - Output:
            - T（実行結果）
        - 処理内容：
            - セマフォ取得→処理実行→セマフォ解放の確実実行
            - タイムアウト制御
            - 例外発生時の確実なセマフォ解放
        - データ取得元：実行対象メソッド、SemaphoreSlim.WaitAsync()

    ・GetResourceSemaphore（リソース種別セマフォ取得）
        - Input:
            - ResourceType（リソース種別列挙型：LogFile, ConfigFile, OutputFile）
        - Output:
            - SemaphoreSlim（対応するセマフォ）
        - データ取得元：内部セマフォインスタンス

クラス：ProgressReporter<T>
機能概要：IProgress<T>実装、リアルタイム進捗報告、UI・コンソール出力対応
継承関係：IProgress<T>（.NET標準）を実装
メソッド：
    ・Report（進捗報告実行）
        - Input:
            - T（進捗情報：ProgressInfo型またはstring型）
        - Output:
            - void（進捗情報の出力・通知）
        - 処理内容：
            - コンソール出力（リアルタイム表示）
            - ログファイル記録
            - 進捗率計算・表示
        - データ取得元：LoggingManager.LogStateAsync()（ログ出力）、Console.WriteLine()（コンソール表示）

    ・CreateStepProgress（ステップ別進捗レポーター作成）
        - Input:
            - string（ステップ名：Step2, Step3, ...）
            - int（予想処理数：デバイス数等）
        - Output:
            - ProgressReporter<ProgressInfo>（ステップ専用進捗レポーター）
        - データ取得元：ステップ名、処理対象数

クラス：ParallelExecutionController
機能概要：複数PLC並行実行制御、Task.WhenAll活用、エラー発生時継続制御
メソッド：
    ・ExecuteParallelPlcOperationsAsync（複数PLC並行実行）
        - Input:
            - IEnumerable<ConfigToFrameManager>（PLC用設定管理インスタンス群：MultiConfigManager.CreateManagersAsync()から取得）
            - Func<ConfigToFrameManager, CancellationToken, Task<CycleExecutionResult>>（実行処理：ExecutionOrchestrator.RunContinuousDataCycleAsync()）
            - CancellationToken（実行制御）
        - Output:
            - ParallelExecutionResult（並行実行結果オブジェクト）
                - TotalPlcCount（int型、必須）: 対象PLC総数
                - SuccessfulPlcCount（int型、必須）: 成功PLC数
                - FailedPlcCount（int型、必須）: 失敗PLC数
                - PlcResults（Dictionary<string, CycleExecutionResult>型、必須）: PLC別実行結果
                - OverallExecutionTime（TimeSpan型、必須）: 全体実行時間
                - ContinuingPlcIds（List<string>型、必須）: 継続実行中PLC ID一覧
        - 処理内容：
            - Task.WhenAll()による真の並行実行
            - エラー発生PLC以外の継続実行制御
            - 並行実行統計・監視情報取得
        - データ取得元：各ConfigToFrameManager、ExecutionOrchestrator、Task.WhenAll()

    ・MonitorParallelExecution（並行実行監視）
        - Input:
            - IEnumerable<Task<CycleExecutionResult>>（実行中タスク群）
            - IProgress<ParallelProgressInfo>（進捗レポーター）
            - CancellationToken（監視制御）
        - Output:
            - Task（監視タスク）
        - 処理内容：
            - 実行中タスクの状態監視
            - 完了・エラー・継続状況のリアルタイム報告
            - 全体進捗率計算・表示
        - データ取得元：Task.IsCompleted、Task.IsFaulted、ProgressReporter


- Core/Models（非同期・並行処理用データ転送オブジェクト）
機能概要：非同期処理結果の構造化、並行実行状態管理、進捗情報保持、例外処理結果管理
詳細機能：
    ・非同期処理実行結果データ保持
    ・並行実行統計データ保持
    ・進捗報告情報データ保持
    ・例外処理結果データ保持
クラス・列挙型：

    ・ResourceType（列挙型）
        - 目的：共有リソース種別の型安全な表現
        - 値：
            - LogFile: ログファイルリソース
            - ConfigFile: 設定ファイルリソース
            - OutputFile: データ出力ファイルリソース
        - 使用箇所：ResourceSemaphoreManager.GetResourceSemaphore()

    ・AsyncOperationResult<T>（AsyncExceptionHandler.HandleCriticalOperationAsync戻り値）
        - 目的：重要処理の非同期実行結果保持
        - プロパティ：
            - IsSuccess（bool型、必須）: 実行成功フラグ
            - Result（T型、null許容）: 実行結果（成功時のみ設定、失敗時はnull）
            - Exception（Exception型、null許容）: 発生例外（失敗時のみ設定、成功時はnull）
            - ExecutionTime（TimeSpan型、必須）: 実行時間
            - OperationName（string型、必須）: 処理名称（デバッグ・ログ識別用）
            - StartTime（DateTime型、必須）: 実行開始時刻
            - EndTime（DateTime型、必須）: 実行終了時刻
        - コンストラクタ：
            - 成功時用：AsyncOperationResult(T result, TimeSpan executionTime, string operationName, DateTime startTime)
            - 失敗時用：AsyncOperationResult(Exception exception, TimeSpan executionTime, string operationName, DateTime startTime)
        - 設計方針：
            - 成功/失敗の論理的整合性（成功時はException=null、失敗時はResult=null）
            - 実行時間の正確な記録（パフォーマンス分析支援）
            - 処理名称による識別可能性（並行実行時の追跡）

    ・GeneralOperationResult（AsyncExceptionHandler.HandleGeneralOperationsAsync戻り値）
        - 目的：一般処理の一括実行結果保持
        - プロパティ：
            - SuccessCount（int型、必須）: 成功処理数
            - FailureCount（int型、必須）: 失敗処理数
            - TotalExecutionTime（TimeSpan型、必須）: 全体実行時間
            - FailedOperations（List<string>型、必須）: 失敗した処理名一覧
            - Exceptions（List<Exception>型、必須）: 発生例外一覧
            - OperationGroupName（string型、必須）: 処理グループ名称
            - ExecutedAt（DateTime型、必須）: 実行開始時刻
        - コンストラクタ：
            - 基本情報指定：GeneralOperationResult(string groupName, DateTime executedAt)
        - メソッド：
            - AddSuccess(string operationName): 成功処理追加
            - AddFailure(string operationName, Exception exception): 失敗処理・例外追加
            - GetSuccessRate(): 成功率計算（0.0-1.0）
        - 設計方針：
            - 一括処理の統計情報提供（成功率、実行時間等）
            - 失敗詳細の保持（個別例外情報・処理名）
            - グループ単位での管理（ログ・デバッグ支援）

    ・ParallelExecutionResult（ParallelExecutionController.ExecuteParallelPlcOperationsAsync戻り値）
        - 目的：複数PLC並行実行結果保持
        - プロパティ：
            - TotalPlcCount（int型、必須）: 対象PLC総数
            - SuccessfulPlcCount（int型、必須）: 成功PLC数
            - FailedPlcCount（int型、必須）: 失敗PLC数
            - PlcResults（Dictionary<string, CycleExecutionResult>型、必須）: PLC別実行結果（PlcId→実行結果）
            - OverallExecutionTime（TimeSpan型、必須）: 全体実行時間（最も遅いPLCの完了時間）
            - ContinuingPlcIds（List<string>型、必須）: 継続実行中PLC ID一覧
            - StartTime（DateTime型、必須）: 並行実行開始時刻
            - CompletionTime（DateTime型、null許容）: 全PLC完了時刻（全完了時のみ設定）
            - ParallelEfficiency（double型、必須）: 並行実行効率（0.0-1.0、理論最大時間/実際時間）
        - コンストラクタ：
            - 実行中用：ParallelExecutionResult(int totalCount, DateTime startTime)
        - メソッド：
            - AddPlcResult(string plcId, CycleExecutionResult result): PLC結果追加
            - UpdateContinuingPlcs(List<string> continuingIds): 継続PLC更新
            - CalculateEfficiency(): 並行実行効率計算
            - GetFailedPlcIds(): 失敗PLC ID一覧取得
        - 設計方針：
            - 並行実行の効果測定（効率性・パフォーマンス分析）
            - PLC別詳細結果保持（個別分析・デバッグ支援）
            - 継続実行状況の動的更新（リアルタイム監視）

    ・ProgressInfo（進捗報告用基底クラス）
        - 目的：進捗情報の統一表現
        - プロパティ：
            - CurrentStep（string型、必須）: 現在実行ステップ（例："Step3", "PLC接続中"）
            - Progress（double型、必須）: 進捗率（0.0-1.0）
            - Message（string型、必須）: 進捗メッセージ（人間向け表示用）
            - EstimatedTimeRemaining（TimeSpan型、null許容）: 推定残り時間
            - ElapsedTime（TimeSpan型、必須）: 経過時間
            - ReportedAt（DateTime型、必須）: 報告時刻
        - コンストラクタ：
            - 基本情報指定：ProgressInfo(string step, double progress, string message, TimeSpan elapsed)
        - 設計方針：
            - 統一された進捗表現（ステップ・率・メッセージ）
            - 時間情報の充実（経過・残り時間）
            - コンソール・ログ両対応の表示形式

    ・ParallelProgressInfo（並行実行進捗報告専用）
        - 目的：複数PLC並行実行の進捗情報保持
        - 継承関係：ProgressInfo（基底クラス）を継承
        - プロパティ：
            - ActivePlcCount（int型、必須）: 実行中PLC数
            - CompletedPlcCount（int型、必須）: 完了PLC数
            - FailedPlcCount（int型、必須）: 失敗PLC数
            - PlcProgresses（Dictionary<string, double>型、必須）: PLC別進捗率（PlcId→進捗率）
            - OverallProgress（double型、必須）: 全体進捗率（全PLC平均進捗）
        - コンストラクタ：
            - 並行実行用：ParallelProgressInfo(string step, Dictionary<string, double> plcProgresses, TimeSpan elapsed)
        - メソッド：
            - UpdatePlcProgress(string plcId, double progress): PLC進捗更新
            - CalculateOverallProgress(): 全体進捗率計算
        - 設計方針：
            - PLC別詳細進捗（個別監視・デバッグ支援）
            - 全体進捗の統合表示（運用者向け情報）
            - 動的進捗更新（リアルタイム表示）


- DI（依存性注入）コンテナ設計
機能概要：Microsoft.Extensions.DependencyInjection活用、用途別ライフタイム管理、全主要クラスインターフェース登録、Optionsパターン設定注入
基本方針：
    ・DIライブラリ：Microsoft.Extensions.DependencyInjection（.NET標準）
    ・ライフタイム設計：用途別設計（重要クラスSingleton、軽量クラスTransient）
    ・インターフェース登録：全主要クラスをインターフェース経由登録
    ・設定値注入：Optionsパターン使用（型安全性・バリデーション対応）
    ・複数設定ファイル：MultiConfigManager経由で管理
詳細機能：
    ・サービス登録・ライフタイム管理
        - データ取得元：Program.cs（ServiceCollection）、各クラスインスタンス（依存関係）、IServiceProvider（実行時解決）
    ・インターフェースベース依存関係管理
        - データ取得元：各Interfaceクラス（契約定義）、各Implementationクラス（実装）、DIコンテナ（インスタンス管理）
    ・設定値型安全注入・バリデーション
        - データ取得元：IOptions<T>（設定値注入）、ConfigToFrameManager.LoadConfigAsync()（設定読み込み）、ValidationAttributes（検証）
    ・複数設定ファイル統合管理
        - データ取得元：MultiConfigManager（複数設定ファイル管理）、DIコンテナ（軽量インスタンス注入）
    ・テスタビリティ確保・モック対応
        - データ取得元：インターフェース分離（抽象化）、DIコンテナ（テスト用登録）、各Mockクラス（テスト実装）

クラス：DependencyInjectionConfigurator
機能概要：DIコンテナ設定、サービス登録、ライフタイム管理、インターフェースマッピング
メソッド：
    ・ConfigureServices（サービス登録・設定）
        - Input:
            - IServiceCollection（DIコンテナ：Program.csから取得）
            - IConfiguration（設定情報：appsettings.json、環境変数）
        - Output:
            - IServiceCollection（設定完了済みDIコンテナ）
        - 処理内容：
            - 全主要クラスのインターフェース登録
            - ライフタイム設定（Singleton/Transient）
            - Optionsパターン設定値注入
            - HostedService登録
        - データ取得元：各Interface・Implementationクラス、IConfiguration（設定値）

    ・RegisterCoreServices（コアサービス登録）
        - Input:
            - IServiceCollection（DIコンテナ）
        - Output:
            - IServiceCollection（コア登録完了済み）
        - 処理内容：
            - ApplicationController → IApplicationController（Singleton）
            - ExecutionOrchestrator → IExecutionOrchestrator（Transient：PLC別インスタンス）
            - ConfigToFrameManager → IConfigToFrameManager（Transient：設定ファイル別）
            - PlcCommunicationManager → IPlcCommunicationManager（Transient：PLC別）
            - DataOutputManager → IDataOutputManager（Singleton：共有リソース）
        - データ取得元：各コアクラス・インターフェース

    ・RegisterInfrastructureServices（インフラサービス登録）
        - Input:
            - IServiceCollection（DIコンテナ）
        - Output:
            - IServiceCollection（インフラ登録完了済み）
        - 処理内容：
            - LoggingManager → ILoggingManager（Singleton：ログ集約）
            - ErrorHandler → IErrorHandler（Singleton：エラー統計）
            - ResourceManager → IResourceManager（Singleton：システム監視）
            - AsyncExceptionHandler → IAsyncExceptionHandler（Singleton：例外処理統一）
            - ResourceSemaphoreManager → IResourceSemaphoreManager（Singleton：共有リソース制御）
        - データ取得元：各インフラクラス・インターフェース

    ・RegisterAsyncServices（非同期処理サービス登録）
        - Input:
            - IServiceCollection（DIコンテナ）
        - Output:
            - IServiceCollection（非同期登録完了済み）
        - 処理内容：
            - CancellationCoordinator → ICancellationCoordinator（Singleton：キャンセル制御統一）
            - ParallelExecutionController → IParallelExecutionController（Singleton：並行実行制御）
            - ProgressReporter<T> → IProgressReporter<T>（Transient：進捗報告個別）
            - TimerService → ITimerService（Transient：タイマー個別）
        - データ取得元：各非同期処理クラス・インターフェース

    ・RegisterHostedServices（HostedService登録）
        - Input:
            - IServiceCollection（DIコンテナ）
        - Output:
            - IServiceCollection（HostedService登録完了済み）
        - 処理内容：
            - AndonHostedService登録（IHostedService）
            - GracefulShutdownHandler登録（バックグラウンドサービス）
        - データ取得元：各HostedServiceクラス

クラス：OptionsConfigurator
機能概要：Optionsパターン設定値注入、型安全設定管理、バリデーション設定
メソッド：
    ・ConfigureOptions（Options設定・注入）
        - Input:
            - IServiceCollection（DIコンテナ）
            - IConfiguration（設定情報：appsettings.json等）
        - Output:
            - IServiceCollection（Options設定完了済み）
        - 処理内容：
            - IOptions<ConnectionConfig>注入設定
            - IOptions<TimeoutConfig>注入設定
            - IOptions<SystemResourcesConfig>注入設定
            - IOptions<LoggingConfig>注入設定
            - バリデーション設定（DataAnnotations）
        - データ取得元：各ConfigModelsクラス、IConfiguration（設定値）

    ・ValidateOptions（設定値バリデーション）
        - Input:
            - IServiceCollection（DIコンテナ）
        - Output:
            - IServiceCollection（バリデーション設定完了済み）
        - 処理内容：
            - 必須項目チェック設定
            - 範囲値チェック設定
            - 形式チェック設定（IPアドレス、ポート番号等）
        - データ取得元：ValidationAttributes、各ConfigModelsクラス

クラス：ServiceLifetimeManager
機能概要：サービスライフタイム最適化、メモリ効率管理、パフォーマンス最適化
メソッド：
    ・DetermineLifetime（ライフタイム判定）
        - Input:
            - Type（対象クラス型）
            - ServiceRole（サービス役割：Core, Infrastructure, Async, etc.）
        - Output:
            - ServiceLifetime（Singleton, Scoped, Transient）
        - 処理内容：
            - Singleton判定条件：共有リソース、統計管理、システム監視クラス
            - Transient判定条件：PLC別、設定ファイル別、進捗報告クラス
            - パフォーマンス・メモリ効率考慮
        - データ取得元：クラス特性分析、リソース使用パターン

    ・ValidateLifetimeConsistency（ライフタイム整合性検証）
        - Input:
            - IServiceCollection（DIコンテナ）
        - Output:
            - ValidationResult（整合性検証結果）
        - 処理内容：
            - 依存関係ライフタイム検証
            - Singleton→Transient依存の警告
            - 循環依存チェック
        - データ取得元：サービス登録情報、依存関係分析

クラス：MultiConfigDIIntegration
機能概要：複数設定ファイルとDIコンテナ統合、軽量インスタンス注入、設定別サービス解決
メソッド：
    ・RegisterMultiConfigServices（複数設定対応サービス登録）
        - Input:
            - IServiceCollection（DIコンテナ）
            - MultiConfigManager（複数設定管理：事前初期化済み）
        - Output:
            - IServiceCollection（複数設定対応完了済み）
        - 処理内容：
            - 設定ファイル別ConfigToFrameManagerファクトリ登録
            - PLC別PlcCommunicationManagerファクトリ登録
            - 軽量インスタンス生成器登録
        - データ取得元：MultiConfigManager（共有設定データ）、各ManagerFactoryクラス

    ・CreateConfigSpecificProvider（設定別サービスプロバイダ作成）
        - Input:
            - IServiceProvider（メインプロバイダ）
            - string（設定ファイル名：PLC1_settings.xlsx等）
        - Output:
            - IServiceProvider（設定専用プロバイダ）
        - 処理内容：
            - 設定ファイル専用スコープ作成
            - 該当設定値の注入
            - 軽量インスタンス解決
        - データ取得元：MultiConfigManager（指定設定ファイル）、DIコンテナ（ベースサービス）


- インターフェース設計拡張
機能概要：非同期・並行処理・DI対応インターフェース追加、テスタビリティ確保、契約ベース設計
詳細機能：
    ・非同期処理系インターフェース
    ・並行実行系インターフェース
    ・DI統合系インターフェース
    ・設定管理系インターフェース
インターフェース：

    ・IAsyncExceptionHandler（AsyncExceptionHandler契約）
        - 目的：階層的例外ハンドリングの抽象化
        - メソッド：
            - Task<AsyncOperationResult<T>> HandleCriticalOperationAsync<T>(Func<Task<T>>, string, CancellationToken)
            - Task<GeneralOperationResult> HandleGeneralOperationsAsync(IEnumerable<Func<Task>>, string, CancellationToken)
        - 実装クラス：AsyncExceptionHandler
        - DIライフタイム：Singleton（例外処理統一）

    ・ICancellationCoordinator（CancellationCoordinator契約）
        - 目的：キャンセレーション制御の抽象化
        - メソッド：
            - CancellationTokenSource CreateHierarchicalToken(CancellationToken, TimeSpan?)
            - CancellationTokenRegistration RegisterCancellationCallback(CancellationToken, Func<Task>, string)
        - 実装クラス：CancellationCoordinator
        - DIライフタイム：Singleton（キャンセル制御統一）

    ・IResourceSemaphoreManager（ResourceSemaphoreManager契約）
        - 目的：共有リソース排他制御の抽象化
        - メソッド：
            - Task<T> ExecuteWithSemaphoreAsync<T>(SemaphoreSlim, Func<Task<T>>, CancellationToken, TimeSpan?)
            - SemaphoreSlim GetResourceSemaphore(ResourceType)
        - 実装クラス：ResourceSemaphoreManager
        - DIライフタイム：Singleton（共有リソース制御統一）

    ・IProgressReporter<T>（ProgressReporter<T>契約）
        - 目的：進捗報告の抽象化
        - 継承関係：IProgress<T>（.NET標準）を継承
        - メソッド：
            - void Report(T value)
            - ProgressReporter<ProgressInfo> CreateStepProgress(string, int)
        - 実装クラス：ProgressReporter<T>
        - DIライフタイム：Transient（進捗報告個別）

    ・IParallelExecutionController（ParallelExecutionController契約）
        - 目的：並行実行制御の抽象化
        - メソッド：
            - Task<ParallelExecutionResult> ExecuteParallelPlcOperationsAsync(IEnumerable<ConfigToFrameManager>, Func<ConfigToFrameManager, CancellationToken, Task<CycleExecutionResult>>, CancellationToken)
            - Task MonitorParallelExecution(IEnumerable<Task<CycleExecutionResult>>, IProgress<ParallelProgressInfo>, CancellationToken)
        - 実装クラス：ParallelExecutionController
        - DIライフタイム：Singleton（並行実行制御統一）

    ・IExecutionOrchestrator（ExecutionOrchestrator契約）
        - 目的：Step2-7データ処理サイクルの詳細実行制御の抽象化
        - メソッド：
            - Task RunContinuousDataCycleAsync(List<IPlcCommunicationManager> plcManagers, CancellationToken cancellationToken)
        - 実装クラス：ExecutionOrchestrator
        - DIライフタイム：Transient（PLC別インスタンス）
        - 備考：
            - GetMonitoringInterval() は public メソッドだがインターフェースには含まれない（実装クラス固有）
            - ExecuteMultiPlcCycleAsync() は public メソッドだがインターフェースには含まれない（追加機能）
            - ExecuteMultiPlcCycleAsync_Internal() は private メソッド（内部実装）

    ・ITimerService（TimerService契約）
        - 目的：タイマー制御の抽象化
        - メソッド：
            - Task StartPeriodicExecution(Func<Task>, TimeSpan, CancellationToken)
        - 実装クラス：TimerService
        - DIライフタイム：Transient（タイマー個別）

    ・IConfigurationWatcher（ConfigurationWatcher契約）
        - 目的：設定ファイル変更監視の抽象化（将来実装用）
        - メソッド：
            - Task StartWatchingAsync(string, CancellationToken)
            - event EventHandler<ConfigChangedEventArgs> ConfigChanged
        - 実装クラス：ConfigurationWatcher
        - DIライフタイム：Singleton（設定監視統一）

    ・IMultiConfigDIIntegration（MultiConfigDIIntegration契約）
        - 目的：複数設定ファイルDI統合の抽象化
        - メソッド：
            - IServiceCollection RegisterMultiConfigServices(IServiceCollection, MultiConfigManager)
            - IServiceProvider CreateConfigSpecificProvider(IServiceProvider, string)
        - 実装クラス：MultiConfigDIIntegration
        - DIライフタイム：Singleton（DI統合管理）


- Program.cs・エントリーポイント設計
機能概要：アプリケーション起動制御、Host・DIコンテナ初期化、コマンドライン引数処理、設定ファイル初期読み込み、HostedService起動
基本方針：
    ・Host構成：.NET Generic Host使用（Microsoft.Extensions.Hosting）
    ・DIコンテナ：DependencyInjectionConfigurator経由で一括設定
    ・設定読み込み：appsettings.json + 環境変数 + コマンドライン引数
    ・エラーハンドリング：最上位例外キャッチ、適切なエラーコード返却
    ・ログ初期化：起動時ログ設定、コンソール・ファイル両対応
詳細機能：
    ・Host構築・初期化制御
        - データ取得元：Microsoft.Extensions.Hosting（Generic Host）、IHostBuilder（Host構築）
    ・DIコンテナ統合設定
        - データ取得元：DependencyInjectionConfigurator.ConfigureServices()、IServiceCollection（サービス登録）
    ・設定ファイル統合読み込み
        - データ取得元：appsettings.json（基本設定）、環境変数（実行環境設定）、コマンドライン引数（起動時オプション）
    ・HostedService起動制御
        - データ取得元：AndonHostedService（メイン実行サービス）、IHost.RunAsync()（Host実行）
    ・最上位例外処理・終了制御
        - データ取得元：GracefulShutdownHandler（適切な終了処理）、最上位try-catch（未処理例外キャッチ）

クラス：Program（静的クラス）
メソッド：
    ・Main（アプリケーションエントリーポイント）
        - Input:
            - string[] args（コマンドライン引数：実行時パラメータ）
        - Output:
            - int（終了コード：0=正常終了、1=エラー終了、2=設定エラー、3=権限エラー）
        - 処理内容：
            - コマンドライン引数解析
            - CreateHostBuilder()実行
            - Host.RunAsync()実行
            - 最上位例外処理
        - データ取得元：コマンドライン引数、CreateHostBuilder()、IHost

    ・CreateHostBuilder（Host構築）
        - Input:
            - string[] args（コマンドライン引数：Main()から取得）
        - Output:
            - IHostBuilder（構築済みHostBuilder）
        - 処理内容：
            - Generic Host初期化
            - ConfigureServices()実行
            - ConfigureConfiguration()実行
            - ConfigureLogging()実行
        - データ取得元：Host.CreateDefaultBuilder()、各種Configuratorクラス

    ・ConfigureServices（サービス設定）
        - Input:
            - HostBuilderContext（Hostコンテキスト）
            - IServiceCollection（DIコンテナ）
        - Output:
            - void（サービス登録完了）
        - 処理内容：
            - DependencyInjectionConfigurator.ConfigureServices()実行
            - OptionsConfigurator.ConfigureOptions()実行
            - AndonHostedService登録
        - データ取得元：DependencyInjectionConfigurator、OptionsConfigurator、各種サービスクラス

    ・ConfigureConfiguration（設定統合）
        - Input:
            - HostBuilderContext（Hostコンテキスト）
            - IConfigurationBuilder（設定ビルダー）
        - Output:
            - void（設定読み込み完了）
        - 処理内容：
            - appsettings.json読み込み
            - 環境変数読み込み
            - コマンドライン引数読み込み
            - 設定優先順位設定（コマンドライン > 環境変数 > appsettings.json）
        - データ取得元：appsettings.json、環境変数、コマンドライン引数

    ・ConfigureLogging（ログ設定）
        - Input:
            - HostBuilderContext（Hostコンテキスト）
            - ILoggingBuilder（ログビルダー）
        - Output:
            - void（ログ設定完了）
        - 処理内容：
            - コンソールログ設定
            - ファイルログ設定
            - ログレベル設定
            - ログフォーマット設定
        - データ取得元：IConfiguration（ログ設定）、LoggingConfig（ログ出力設定）

クラス：CommandLineOptions
機能概要：コマンドライン引数解析、起動オプション管理、バリデーション実行
プロパティ：
    ・ConfigDirectory（string型、null許容）: 設定ファイルディレクトリパス（--config-dir）
    ・LogLevel（string型、null許容）: ログレベル（--log-level）
    ・ConsoleOutput（bool型、必須）: コンソール出力有効性（--console、デフォルト：true）
    ・ShowVersion（bool型、必須）: バージョン表示フラグ（--version）
    ・ShowHelp（bool型、必須）: ヘルプ表示フラグ（--help）
    ・DryRun（bool型、必須）: ドライ実行フラグ（--dry-run、設定検証のみ）
メソッド：
    ・Parse（コマンドライン引数解析）
        - Input:
            - string[] args（コマンドライン引数：Main()から取得）
        - Output:
            - CommandLineOptions（解析済みオプション）
        - 処理内容：
            - 引数パターンマッチング
            - オプション値抽出
            - バリデーション実行
        - データ取得元：コマンドライン引数

    ・Validate（オプションバリデーション）
        - Input:
            - CommandLineOptions（解析済みオプション）
        - Output:
            - ValidationResult（バリデーション結果）
        - 処理内容：
            - 設定ディレクトリ存在チェック
            - ログレベル形式チェック
            - オプション組み合わせチェック
        - データ取得元：ファイルシステム、設定値

クラス：ExitCodeManager
機能概要：終了コード管理、エラー分類、統一的な終了処理
列挙型：
    ・ExitCode（終了コード列挙型）
        - Success: 正常終了（0）
        - GeneralError: 一般エラー（1）
        - ConfigurationError: 設定エラー（2）
        - PermissionError: 権限エラー（3）
        - NetworkError: ネットワークエラー（4）
        - FileSystemError: ファイルシステムエラー（5）
メソッド：
    ・DetermineExitCode（終了コード判定）
        - Input:
            - Exception（発生例外：Main()から取得）
        - Output:
            - ExitCode（適切な終了コード）
        - 処理内容：
            - 例外タイプ分析
            - エラーカテゴリ判定
            - 終了コード決定
        - データ取得元：例外オブジェクト、ErrorHandler.DetermineErrorCategory()

    ・LogExitInformation（終了情報ログ出力）
        - Input:
            - ExitCode（終了コード）
            - Exception（例外：null許容）
            - TimeSpan（実行時間）
        - Output:
            - Task（ログ出力完了）
        - 処理内容：
            - 終了コード・理由ログ出力
            - 実行時間・統計ログ出力
            - エラー詳細ログ出力（エラー時のみ）
        - データ取得元：LoggingManager.LogStateAsync()、統計情報

実装例（Program.cs基本構造）：
```csharp
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace Andon
{
    public class Program
    {
        public static async Task<int> Main(string[] args)
        {
            var startTime = DateTime.UtcNow;
            ExitCode exitCode = ExitCode.Success;
            Exception lastException = null;

            try
            {
                // コマンドライン引数解析
                var options = CommandLineOptions.Parse(args);
                if (options.ShowVersion) { ShowVersion(); return 0; }
                if (options.ShowHelp) { ShowHelp(); return 0; }
                if (options.DryRun) return await ExecuteDryRun(options);

                // Host構築・実行
                var hostBuilder = CreateHostBuilder(args, options);
                using var host = hostBuilder.Build();
                await host.RunAsync();
            }
            catch (Exception ex)
            {
                lastException = ex;
                exitCode = ExitCodeManager.DetermineExitCode(ex);
            }
            finally
            {
                var executionTime = DateTime.UtcNow - startTime;
                await ExitCodeManager.LogExitInformation(exitCode, lastException, executionTime);
            }

            return (int)exitCode;
        }

        public static IHostBuilder CreateHostBuilder(string[] args, CommandLineOptions options) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureConfiguration((context, config) =>
                    ConfigureConfiguration(context, config, options))
                .ConfigureServices((context, services) =>
                    ConfigureServices(context, services))
                .ConfigureLogging((context, logging) =>
                    ConfigureLogging(context, logging));
    }
}
```

---

# 📚 旧仕様（参考：DWord分割・結合方式）

**⚠️ 注意：以下は2025-11-06以前の旧仕様です。Random READコマンドの活用により、DWord分割・結合処理は不要になりました。**

## 旧Step2-1: SplitDwordToWord（削除済み）

### 機能概要
デバイスデータ前処理・機器種別判定・DWord分割

### 旧メソッド仕様
```
・SplitDwordToWord（Step2-1: デバイスデータ前処理・機器種別判定・DWord分割）
    - Input:
        - TargetDeviceConfig（MDeviceRange, DDeviceRange, DataType：ConfigToFrameManager.LoadConfigAsync()から取得）
    - Output:
        - 前処理済みデバイス要求情報（機器種別判定済み、必要時のみDWord分割実行、最適化済み範囲情報）
        - ProcessedDeviceRequestInfo（SplitRanges, DataTypeInfo, OptimizedRanges, DeviceTypeClassification）
    - 処理条件分岐:
        【機器種別判定】（SLMP仕様書pdf2img/page_36.png準拠）
        - ビット機器（M, X, Y, L, F, V, B, TS, TC）: 分割処理スキップ → そのまま保持
        - ワード機器（D, W, SD, TN）: DataType判定後処理実行
        【DataType別処理】
        - ワード機器 + DataType="DWord": DWord分割処理実行（16bit×2分割）
        - ワード機器 + DataType="Word": 分割処理スキップ → そのまま保持
        - 全機器共通: 範囲最適化・連続範囲統合処理実行
    - 処理例:
        - M001-999（ビット機器）→ 分割なし → ["M001-999(bit)"]
        - D001-999（ワード機器）+ DataType="DWord" → 分割実行 → ["D001-999(Low)", "D1000-1998(High)"]
        - D001-999（ワード機器）+ DataType="Word" → 分割なし → ["D001-999(word)"]
    - データ取得元：ConfigToFrameManager.LoadConfigAsync()（デバイス設定）、SLMP仕様書（機器種別判定表）
```

### 削除理由
Random READコマンドが各デバイスのワード数を個別指定可能なため、アプリケーション側でのDWord分割処理が不要になった。

---

## 旧Step2-2: BuildFrames（READコマンドのみ方式）

### 旧フレーム生成方式
```
【旧方式】
送信1: READコマンド(0401) - Mデバイス（ビット単位）
送信2: READコマンド(0401) - Dデバイス Low（ワード単位）
送信3: READコマンド(0401) - Dデバイス High（ワード単位）

→ 3回送信が必要
→ アプリケーション側でLow/High結合が必要
```

### 新方式との比較
```
【新方式】
送信1: READコマンド(0401) - Mデバイス（ビット単位）
送信2: Random READコマンド(0403) - Dデバイス（ワード/ダブルワード個別指定）

→ 2回送信のみ
→ PLCが自動的にDWord形式で返す
```

---

## 旧Step6-2: CombineDwordData（削除済み）

### 機能概要
DWord結合処理

### 旧メソッド仕様
```
・CombineDwordData（Step6-2: DWord結合処理）
    - Input:
        - BasicProcessedResponseData（基本後処理結果：PlcCommunicationManager.ProcessReceivedRawData()から取得）
        - ProcessedDeviceRequestInfo（DWord分割情報：ConfigToFrameManager.SplitDwordToWord()から取得）
    - Output:
        - ProcessedResponseData（最終処理結果オブジェクト）
            - 基本結果: 元生データ、処理済みデータ（DWord結合済み）、DWord結合フラグ、処理時刻
            - エラー情報: エラーフラグ、エラー・警告メッセージリスト
            - 統計情報: 処理デバイス数、DWord結合数（自動計算）
    - 処理対象：DWord分割が必要なワードデバイスデータ
    - 責任範囲：
        - DWord分割要否判定
        - Low/Highワードの結合処理
        - 結合結果の検証
        - DWord結合統計の計算
    - データ取得元：PlcCommunicationManager.ProcessReceivedRawData()（基本後処理結果）、ConfigToFrameManager.SplitDwordToWord()（DWord分割情報）
```

### 削除理由
Random READコマンドの応答は既にDWord形式で返されるため、Low/Highワードの結合処理が不要になった。

---

## 旧ProcessedDeviceRequestInfo構造

### 旧プロパティ
```
・ProcessedDeviceRequestInfo（ConfigToFrameManager.SplitDwordToWord戻り値）
    - プロパティ：
        - SplitRanges（Dictionary<string, List<string>>型、必須）: 機器種別判定・必要時のみ分割済み範囲情報
            構造例:
            - ビット機器: { "M001-M999": ["M001-M999"] }（分割なし）
            - ワード機器+Word: { "D001-D999": ["D001-D999"] }（分割なし）
            - ワード機器+DWord: { "D001-D999": ["D001-D999(Low)", "D1000-1998(High)"] }（分割実行）
        - DataTypeInfo（Dictionary<string, string>型、必須）: デバイス範囲別データ型情報
            構造例: { "M001-M999": "Bit", "D001-D999": "Word", "D500-D599": "DWord" }
        - OptimizedRanges（Dictionary<string, string>型、必須）: 最適化済み範囲情報
            構造例: { "M": "M001-M999", "D": "D001-D999" }（デバイス種別毎の統合範囲）
        - DeviceTypeClassification（Dictionary<string, string>型、必須）: 機器種別分類情報
            構造例: { "M001-M999": "BitDevice", "D001-D999": "WordDevice", "X100-X199": "BitDevice" }
```

### 変更点
- `SplitRanges`: 削除（DWord分割不要）
- `DataTypeInfo`: 削除（Random READでワード数指定）
- `OptimizedRanges`: 削除（最適化不要）
- `RandomReadDeviceList`: 追加（Random READ用デバイス指定リスト）
- `BitDeviceRanges`: 追加（ビットデバイス範囲情報）

---

## 旧ProcessedResponseData構造

### 旧プロパティ
```
・ProcessedResponseData（PlcCommunicationManager.CombineDwordData戻り値）
    - プロパティ：
        - OriginalRawData（string型、必須）: 元の受信生データ（16進数文字列）
        - IsDwordCombined（bool型、必須）: DWord結合処理実行フラグ
        - DWordCombinedCount（int型、必須）: DWord結合されたデバイス数
    - メソッド：
        - GetCombinedDWordDevices(): DWord結合デバイス一覧取得
        - GetNonCombinedDevices(): 結合対象外デバイス一覧取得
```

### 変更点
- `OriginalRawData`: `OriginalRawDataList`に変更（複数応答対応）
- `IsDwordCombined`: 削除（DWord結合不要）
- `DWordCombinedCount`: 削除
- `MergedResponseCount`: 追加（統合された応答数）
- `BitDeviceCount`, `WordDeviceCount`, `DWordDeviceCount`: 追加（デバイス種別統計）
- `GetCombinedDWordDevices()`: 削除
- `GetDWordDevices()`: 追加（Random READ応答から取得）

---

## 旧実装フローとの比較

### 旧フロー（DWord分割・結合方式）
```
Step2-1: SplitDwordToWord()
  ↓ DWord分割実行（D000-D999 → D000-D999(Low) + D1000-D1998(High)）
Step2-2: BuildFrames()
  ↓ 3つのフレーム生成（M用、D Low用、D High用）
Step4-5: 3回送受信
  ↓
Step6-1: ProcessReceivedRawData() × 3回
  ↓ 3つの応答をパース
Step6-2: CombineDwordData()
  ↓ Low + High → DWord結合
Step6-3: ParseRawToStructuredData()
```

### 新フロー（Random READ方式）
```
Step2-1: PrepareDeviceRequestInfo()
  ↓ Random READ用デバイスリスト生成（DWord分割不要）
Step2-2: BuildFrames()
  ↓ 2つのフレーム生成（M用、Random READ用）
Step4-5: 2回送受信
  ↓
Step6-1: ProcessReceivedRawData() × 2回
  ↓ 2つの応答をパース（Random READ応答は既にDWord形式）
Step6-2: MergeResponseData()
  ↓ 2つの応答を統合（結合不要）
Step6-3: ParseRawToStructuredData()
```

---

## 旧Step6詳細フロー設計（2025-11-05検討資料）

**⚠️ 注意：以下は2025-11-05時点の詳細設計検討資料です。Random READコマンド活用により、DWord結合処理は不要になったため、この詳細設計は旧仕様となりました。**

**出典：** `documents/ToDo/step6内容検討.md`（2025-11-05検討）

### 旧Step6-1: 受信データ基本後処理フロー

```
↓ 生データ(16進数) + ProcessedDeviceRequestInfo
│
▼
┌─────────────────┐
│ 16進数パース実行  │
└─────────────────┘
│
▼
◇ パース成功？ ───N──→ ┌───────────────┐
│                      │ エラー情報記録   │
Y                      │ return結果(Error)│
│                      └───────────────┘
▼
┌─────────────────────┐
│ デバイス別データ抽出   │
│ ・ビットデータ抽出    │
│ ・ワードデータ抽出    │
└─────────────────────┘
│
▼
┌─────────────────────┐
│ 基本型変換実行       │
│ ・ビット→bool       │
│ ・ワード→int/uint   │
└─────────────────────┘
│
▼
┌─────────────────┐
│ エラー検証実行    │
└─────────────────┘
│
▼
┌──────────────────────┐
│ 統計情報計算          │
│ ・処理デバイス数算出   │
└──────────────────────┘
│
▼
┌───────────────────────────┐
│ BasicProcessedResponseData作成│
└───────────────────────────┘
│
▼
return BasicProcessedResponseData
```

**Input:**
- 生データ(16進数): `PlcCommunicationManager.ReceiveResponseAsync()`から取得
- `ProcessedDeviceRequestInfo`: `ConfigToFrameManager.SplitDwordToWord()`から取得（旧仕様）

**Output:**
- `BasicProcessedResponseData`
  - 基本結果: 元生データ、基本処理済みデータ（デバイス名キー構造）、処理時刻
  - エラー情報: エラーフラグ、エラー・警告メッセージリスト
  - 統計情報: 処理デバイス数

### 旧Step6-2: DWord結合処理フロー

```
↓ BasicProcessedResponseData + ProcessedDeviceRequestInfo
│
▼
┌──────────────────┐
│ DWord分割要否判定 │
└──────────────────┘
│
▼
◇ DWord分割必要？ ───N──→ ┌────────────────┐
│                        │ 統計情報計算    │
Y                        │ (分割数=0)     │
│                        └────────┬───────┘
▼                                 │
┌───────────────────────┐        │
│ Low/Highワード結合処理  │        │
│ ・ペア検索             │        │
│ ・32bit値計算          │        │
└───────────────────────┘        │
│                                 │
▼                                 │
◇ 結合成功？ ───N──→ ┌──────────┐│
│                    │エラー記録 ││
Y                    │return結果││
│                    └──────────┘│
▼                                 │
┌───────────────┐                │
│ 結合結果検証   │                │
└───────────────┘                │
│                                 │
▼                                 │
┌──────────────────────┐         │
│ DWord結合統計計算     │         │
│ ・DWord結合数算出     │         │
└──────────────────────┘         │
│                                 │
▼                                 ▼
┌────────────────────────────────┐
│ ProcessedResponseData作成       │
└────────────────────────────────┘
│
▼
return ProcessedResponseData
```

**Input:**
- `BasicProcessedResponseData`: `PlcCommunicationManager.ProcessReceivedRawData()`から取得
- `ProcessedDeviceRequestInfo`: `ConfigToFrameManager.SplitDwordToWord()`から取得（旧仕様）

**Output:**
- `ProcessedResponseData`
  - 基本結果: 元生データ、処理済みデータ（DWord結合済み）、DWord結合フラグ、処理時刻
  - エラー情報: エラーフラグ、エラー・警告メッセージリスト
  - 統計情報: 処理デバイス数、DWord結合数（自動計算）

### 旧Step6-3: 構造化データ変換フロー

```
↓ ProcessedResponseData
│
▼
┌─────────────────┐
│ SLMPヘッダー解析 │
│ ・応答データ長   │
│ ・終了コード等   │
└─────────────────┘
│
▼
┌─────────────────┐
│ 終了コード確認   │
└─────────────────┘
│
▼
◇ 終了コード正常？ ───N──→ ┌──────────────────┐
│                          │ エラー詳細情報作成 │
Y                          │ ・エラーコード     │
│                          │ ・エラー説明       │
▼                          │ ・影響デバイス     │
┌──────────────────┐      └──────┬───────────┘
│ デバイスデータ    │             │
│ 構造化変換       │             │
└──────────────────┘             │
│                                 │
▼                                 │
┌──────────────────┐             │
│ 解析詳細情報作成  │             │
│ ・解析手順記録   │             │
│ ・解釈情報       │             │
│ ・処理時間       │             │
└──────────────────┘             │
│                                 │
▼                                 │
┌──────────────────┐             │
│ ステータス判定    │             │
└──────────────────┘             │
│                                 │
▼                                 ▼
┌─────────────────────────────────┐
│ StructuredData作成               │
│ ・SLMPヘッダー情報               │
│ ・デバイスデータ                 │
│ ・解析詳細情報/エラー詳細情報    │
└─────────────────────────────────┘
│
▼
return StructuredData
```

**Input:**
- `ProcessedResponseData`: `PlcCommunicationManager.CombineDwordData()`から取得（旧仕様）

**Output:**
- `StructuredData`
  - 基本構造化データ: SLMPヘッダー（全標準情報）、終了コード、デバイスデータ、受信時刻、エラーフラグ
  - 解析詳細情報: 解析手順記録、解釈情報、処理時間、デバイス解釈、ステータス判定
  - エラー詳細情報: 詳細エラーコード、エラー説明、影響デバイス（エラー時のみ）

---

### 旧設計での型整合性問題と解決方針

**検討日：** 2025-11-05

#### 問題点
DWordが無い場合にStep6-2をスキップすると、Step6-3が以下の2つの異なる型を受け取ることになる：
- **DWordなし**: `BasicProcessedResponseData` (Step6-1から)
- **DWordあり**: `ProcessedResponseData` (Step6-2から)

→ **型安全性が損なわれる**

#### 検討した設計パターン

**パターンA: Step6-2は常に実行（採用された方針）**

```
Step6-1 → BasicProcessedResponseData
    ↓
Step6-2 (常に実行)
    ├─ DWordあり → 結合処理実行
    └─ DWordなし → 結合処理スキップ（変換のみ）
    ↓
ProcessedResponseData
    ↓
Step6-3
```

**Step6-2実装イメージ（旧設計）:**
```csharp
public ProcessedResponseData CombineDwordData(
    BasicProcessedResponseData basicData,
    ProcessedDeviceRequestInfo requestInfo)
{
    if (!requestInfo.HasDwordSplit)  // DWord分割無し
    {
        // BasicProcessedResponseData → ProcessedResponseData 変換のみ
        return ConvertToProcessedResponseData(basicData, dwordCombinedCount: 0);
    }

    // DWord結合処理実行
    // ...
}
```

**メリット:**
1. **型安全性**: 常に`ProcessedResponseData`を受け取る
2. **シンプル**: 条件分岐がStep6-2内に集約される
3. **保守性**: 呼び出し側が複雑な型判定をする必要がない
4. **一貫性**: フロー図とコードが一致する

**パターンB: 共通インターフェース使用**

```csharp
public interface IProcessedResponseData
{
    byte[] RawData { get; }
    Dictionary<string, object> ProcessedData { get; }
    bool HasError { get; }
    // ...
}

public class BasicProcessedResponseData : IProcessedResponseData { }
public class ProcessedResponseData : IProcessedResponseData { }
```

**メリット:**
- 柔軟性が高い

**デメリット:**
- 複雑性が増す
- 呼び出し側での型判定が必要になる可能性

#### 採用方針（旧設計）

**採用: パターンA（Step6-2常に実行）**

**理由:**
1. C#初学者にも理解しやすいシンプルな設計
2. 型安全性が保たれる
3. フロー図と実装の一貫性が保たれる
4. メンテナンス性が高い

**実装時の注意点（旧設計）:**
- Step6-2内で`HasDwordSplit`フラグによる分岐を実装
- DWordなしの場合は、統計情報の`DwordCombinedCount = 0`として変換のみ実行
- Step6-3は常に`ProcessedResponseData`を受け取る前提で実装

---

### 新仕様との設計変更点

**新仕様（Random READ方式）では：**

1. **Step6-1の変更**:
   - 旧：1回実行（3つの応答を順次処理）
   - 新：2回実行（M用とD用を個別に処理）

2. **Step6-2の変更**:
   - 旧：`CombineDwordData()` - DWord結合処理
   - 新：`MergeResponseData()` - 2つの応答データ統合処理
   - **DWord結合処理は不要**（Random READが自動的にDWord形式で返すため）

3. **型整合性の問題解決**:
   - 新仕様では、Step6-2は**常に実行**される（2つの応答を統合する必要があるため）
   - 旧設計で検討した「常に実行」方針は、異なる理由で新設計でも維持されている

4. **データフロー変更**:
   ```
   旧: 生データ×3 → Step6-1×3 → BasicData×3 → Step6-2 → ProcessedData（DWord結合済み） → Step6-3
   新: 生データ×2 → Step6-1×2 → BasicData×2 → Step6-2 → ProcessedData（統合済み） → Step6-3
   ```

---

## 旧仕様の設計上の問題点

1. **通信回数の増加**: 3回送信が必要（M, D Low, D High）
2. **実装の複雑性**: DWord分割・結合ロジックが複雑
3. **エラーポイントの増加**: 3回の通信それぞれでエラーの可能性
4. **処理時間の増加**: 分割・結合処理のオーバーヘッド
5. **保守性の低下**: 分割・結合ロジックのバグリスク

---

## 新仕様のメリット（2025-11-20更新：Random READ一括取得方式）

1. **通信回数最小化**: 1回送信のみ（旧: 2回送信）
2. **実装の大幅簡素化**: DWord分割・結合処理が不要、応答統合処理も不要
3. **エラーポイント最小化**: 通信回数最小化によるエラーリスク大幅低下
4. **処理時間最短化**: 分割・結合・統合処理のオーバーヘッド完全削除
5. **保守性最大化**: 極めてシンプルなコード、バグリスク最小化
6. **データ処理の簡素化**:
   - BasicProcessedResponseData廃止（中間データ型不要）
   - MergeResponseData廃止（統合処理不要）
   - ProcessReceivedRawDataで処理完結
7. **型設計の簡素化**:
   - ProcessedResponseData.OriginalRawData: string型（単一データ）
   - ProcessedResponseData.ProcessedData: Dictionary<string, DeviceData>型（明示的型定義）

---

**📌 参考資料**
- SLMP仕様書：C:\Users\1010821\Desktop\python\andon\pdf2img
  - Random READコマンド仕様：page_53-57
  - READコマンド仕様：page_44-48
  - レスポンスフレーム構造：page_20-23
- データ送信形式検討.md：Random READ活用による設計変更詳細
- フレーム構築方法.md：要求・応答フレーム構造詳細
  - **重要**: 4E応答フレームには監視タイマフィールドが存在しない
  - 4E Binary応答: 終了コードオフセット13-14、デバイスデータ開始オフセット15
  - 3E Binary応答: 終了コードオフセット9-10、デバイスデータ開始オフセット11

---

## ConfigModels拡張仕様（Excel対応）

### PlcConfiguration クラス

**概要：** Excel設定ファイル（*.xlsx）から読み込んだPLC接続設定を保持するモデルクラス

**配置：** Core/Models/ConfigModels/PlcConfiguration.cs

**プロパティ：**
- ConnectionConfig（接続設定）
- TimeoutConfig（タイムアウト設定）
- TargetDeviceConfig（対象デバイス設定）
- MonitoringIntervalMs（監視間隔ミリ秒）
- SystemResourcesConfig（システムリソース設定）
- DataProcessingConfig（データ処理設定）
- LoggingConfig（ログ設定）
- DataTransferConfig（データ転送設定）
- ActualConfigPath（実際に読み込んだファイルパス）

**データ取得元：** ConfigurationLoaderExcel.LoadPlcConnectionConfig()

**用途：**
- Excel設定ファイルベースのPLC接続設定管理
- ConfigToFrameManagerのBuildReadRandomFrameFromConfig()オーバーロードの入力
- Step1-3オフラインテスト用のモック設定

### ConfigurationLoaderExcel クラス

**概要：** Excel設定ファイル（*.xlsx）からPLC接続設定を読み込むクラス

**配置：** Infrastructure/Configuration/ConfigurationLoaderExcel.cs

**メソッド：**

#### LoadAllPlcConnectionConfigs（複数PLC設定一括読み込み）
- Input:
  - configDirectory（string型、デフォルト："./config/"）
  - filePattern（string型、デフォルト："*_settings.xlsx"）
- Output:
  - Dictionary<string, PlcConfiguration>（ファイル名キーの設定辞書）
- 処理内容：
  - 指定ディレクトリ内の全Excel設定ファイルを読み込み
  - 各ファイルごとにPlcConfigurationオブジェクトを生成
  - ファイル名をキーとした辞書で返却
- データ取得元：*.xlsx（Excel設定ファイル群）

#### LoadPlcConnectionConfig（単一PLC設定読み込み）
- Input:
  - configFileName（string型、例："plc_config.xlsx"）
- Output:
  - PlcConfiguration（PLC接続設定オブジェクト）
- 処理内容：
  - 指定されたExcel設定ファイルを読み込み
  - PlcConfigurationオブジェクトに変換して返却
  - パス解決順序：./config/[fileName] → ./[fileName] → 環境変数ANDON_CONFIG_PATH
- データ取得元：*.xlsx（Excel設定ファイル）

**依存関係：**
- ClosedXML または EPPlus（Excelファイル読み込みライブラリ）
- PlcConfiguration（設定モデルクラス）

**備考：**
- JSON用のConfigurationLoaderとは別クラスとして実装
- Excel特有のエラーハンドリング（ファイル形式エラー、セル読み込みエラー等）を実装
- UTF-8エンコーディング前提

---

## 📝 変更履歴

### Phase12対応（2025-12-02）
- **ReadRandomRequestInfo追加**: ReadRandom(0x0403)専用の本番実装用クラス追加（line 1310-1327）
- **ProcessedDeviceRequestInfo位置づけ明確化**: テスト専用（TC029/TC037用）として明記（line 1288-1308）
- **IPlcCommunicationManager.ExecuteFullCycleAsync()更新**:
  - 旧シグネチャ: `ExecuteFullCycleAsync(..., ProcessedDeviceRequestInfo, ...)`
  - 新シグネチャ: `ExecuteFullCycleAsync(..., ReadRandomRequestInfo, ...)` （Phase12で更新）
  - ExecutionOrchestratorからの呼び出しでReadRandomRequestInfoを使用
