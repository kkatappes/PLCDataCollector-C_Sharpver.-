# Step7 実装時の対応関係・関連情報

## 概要

本文書は、Step7データ出力機能を実装する際に、既存の実装とどのように連携・対応させるかを詳細に記載したガイドです。

---

## 1. 現在の実装状況（Phase7時点）

### 1.1 既存実装ファイル

#### DataOutputManager（既存実装あり）
**ファイル**: `andon/Core/Managers/DataOutputManager.cs`

**既存メソッド**:
- `OutputToJson()` - JSON出力メソッド（Phase7で実装済み）
  - 行: 23-76
  - シグネチャ:
    ```csharp
    public void OutputToJson(
        ProcessedResponseData data,
        string outputDirectory,
        string ipAddress,
        int port,
        Dictionary<string, DeviceEntryInfo> deviceConfig)
    ```

- `ConvertValue()` - デバイス値変換プライベートメソッド
  - 行: 81-90
  - シグネチャ:
    ```csharp
    private object ConvertValue(DeviceData deviceData)
    ```

**注意点**:
- 現在の実装は `ProcessedResponseData` を入力として受け取る
- 設計書では `StructuredData` を入力とする想定だが、実装では異なる
- `ProcessedResponseData.ProcessedData` プロパティを使用してデバイスデータにアクセス

#### DeviceEntryInfo（既存実装あり）
**ファイル**: `andon/Core/Managers/DataOutputManager.cs`（同一ファイル内）

**実装箇所**: 行: 96-109

**プロパティ**:
```csharp
public class DeviceEntryInfo
{
    public string Name { get; set; } = string.Empty;  // センサー名・用途説明
    public int Digits { get; set; } = 1;              // データ桁数
}
```

**将来の移動予定**:
- 現在はDataOutputManager.cs内に定義
- 将来的には `andon/Core/Models/ConfigModels/DeviceEntryInfo.cs` に移動推奨

#### IDataOutputManager（インターフェースのみ、メソッド未定義）
**ファイル**: `andon/Core/Interfaces/IDataOutputManager.cs`

**現在の状態**:
```csharp
public interface IDataOutputManager
{
    // TODO: Method signatures
}
```

**必要な対応**:
- `OutputToJson()` メソッドのシグネチャを追加
- または非同期版 `OutputToJsonAsync()` を定義

---

## 2. データモデルの対応関係

### 2.1 ProcessedResponseData vs StructuredData

**重要**: 設計書と実装で異なる型を使用している

#### ProcessedResponseData（実装で使用）
**ファイル**: `andon/Core/Models/ProcessedResponseData.cs`

**主要プロパティ**:
```csharp
// Step7で使用するプロパティ
public Dictionary<string, DeviceData> ProcessedData { get; set; }  // デバイス名キー構造
public DateTime ProcessedAt { get; set; }                           // 処理完了時刻
public long ProcessingTimeMs { get; set; }                          // 処理時間
public string OriginalRawData { get; set; }                         // 元の受信生データ
public bool IsSuccess { get; set; }                                 // 処理成功フラグ
public List<string> Errors { get; set; }                            // エラー情報
public List<string> Warnings { get; set; }                          // 警告情報
```

**統計プロパティ（自動計算）**:
```csharp
public int TotalProcessedDevices => ProcessedData.Count;
public int BitDeviceCount => ProcessedData.Values.Count(d => d.Code.IsBitDevice());
public int WordDeviceCount => ProcessedData.Values.Count(d => !d.Code.IsBitDevice() && !d.IsDWord);
public int DWordDeviceCount => ProcessedData.Values.Count(d => d.IsDWord);
```

**ユーティリティメソッド**:
```csharp
public uint? GetDeviceValue(string deviceName)
public List<string> GetBitDevices()
public List<string> GetWordDevices()
public List<string> GetDWordDevices()
```

#### StructuredData（設計書で想定）
**ファイル**: `andon/Core/Models/StructuredData.cs`

**主要プロパティ**:
```csharp
public bool IsSuccess { get; set; }
public List<StructuredDevice> StructuredDevices { get; set; }  // 構造化デバイス一覧
public DateTime ProcessedAt { get; set; }
public long ProcessingTimeMs { get; set; }
public FrameInfo FrameInfo { get; set; }                       // 3Eフレーム情報
public List<string> ParseSteps { get; set; }
public List<string> Errors { get; set; }
public List<string> Warnings { get; set; }
```

**使い分け**:
- **ProcessedResponseData**: Phase5～Phase7で実装、デバイスデータ辞書構造
- **StructuredData**: 将来の構造化データ用（現在未使用）

### 2.2 DeviceData（核心的なデータ構造）

**ファイル**: `andon/Core/Models/DeviceData.cs`

**プロパティ一覧**:
```csharp
public string DeviceName { get; set; }      // "M000", "D100", "W0x11AA"等
public DeviceCode Code { get; set; }        // デバイスコード（M, D, W等）
public int Address { get; set; }            // デバイス番号（アドレス）
public uint Value { get; set; }             // デバイス値（16bit/32bit）
public bool IsDWord { get; set; }           // ダブルワードフラグ
public bool IsHexAddress { get; set; }      // 16進アドレス表記フラグ
public string Type { get; set; }            // "Bit", "Word", "DWord"
```

**Type プロパティの使用方法**:
```csharp
// Step7でのJSON出力時に小文字変換
unit = deviceData.Type.ToLower()  // "Bit" -> "bit", "Word" -> "word", "DWord" -> "dword"
```

**静的ファクトリメソッド**:
```csharp
// ワードデバイス生成
public static DeviceData FromDeviceSpecification(DeviceSpecification device, ushort value)

// ダブルワードデバイス生成（2ワード結合）
public static DeviceData FromDWordDevice(DeviceSpecification device, ushort lowerWord, ushort upperWord)
```

### 2.3 StructuredDevice（現在未使用）

**ファイル**: `andon/Core/Models/StructuredDevice.cs`

**主要プロパティ**:
```csharp
public string DeviceName { get; set; }
public string StructureType { get; set; }
public Dictionary<string, object> Fields { get; set; }
public DateTime ParsedTimestamp { get; set; }
public string SourceFrameType { get; set; }
```

**注意**: Step7データ出力では現在使用していない（将来の構造化データ用）

---

## 3. 設定情報の取得方法

### 3.1 ConnectionConfig（接続設定）

**ファイル**: `andon/Core/Models/ConfigModels/ConnectionConfig.cs`

**プロパティ**:
```csharp
public string IpAddress { get; set; }       // IPアドレス
public int Port { get; set; }               // ポート番号
public bool UseTcp { get; set; }            // TCP/UDP選択
public string ConnectionType { get; set; }  // "TCP"/"UDP"（ログ出力用）
public bool IsBinary { get; set; }          // Binary/ASCII
public FrameVersion FrameVersion { get; set; }  // 3E/4E
```

**DataOutputManagerでの使用**:
```csharp
// OutputToJsonメソッドのパラメータとして受け取る
public void OutputToJson(
    ProcessedResponseData data,
    string outputDirectory,
    string ipAddress,           // ← ConnectionConfig.IpAddressから渡す
    int port,                   // ← ConnectionConfig.Portから渡す
    Dictionary<string, DeviceEntryInfo> deviceConfig)
```

### 3.2 DeviceConfig辞書の構築

**構築方法**:
```csharp
// appsettings.jsonから読み込んだデバイス設定を辞書に変換
var deviceConfig = new Dictionary<string, DeviceEntryInfo>();

foreach (var deviceEntry in targetDeviceConfig.Devices)
{
    // デバイス名をキーとして登録
    string deviceName = $"{deviceEntry.DeviceType}{deviceEntry.DeviceNumber}";
    deviceConfig[deviceName] = new DeviceEntryInfo
    {
        Name = deviceEntry.Description ?? deviceName,
        Digits = 1  // デフォルト値
    };
}
```

**appsettings.json構造例**:
```json
{
  "TargetDevices": {
    "Devices": [
      {
        "DeviceType": "M",
        "DeviceNumber": 0,
        "Description": "停止纏めON=異常無",
        "IsHexAddress": false
      },
      {
        "DeviceType": "D",
        "DeviceNumber": 100,
        "Description": "生産台数",
        "IsHexAddress": false
      }
    ]
  }
}
```

---

## 4. 既存メソッドとの連携

### 4.1 PlcCommunicationManager連携

**メソッド**: `ParseRawToStructuredData()`
- **ファイル**: `andon/Core/Managers/PlcCommunicationManager.cs`
- **行**: 2220-2339

**戻り値**: `StructuredData`

**注意**:
- 現在のDataOutputManagerは `ProcessedResponseData` を受け取る
- 将来的に `StructuredData` を受け取るように変更する可能性あり
- Phase7では `ProcessedResponseData` のまま実装継続

**呼び出しフロー**:
```
PlcCommunicationManager.ReceiveResponseAsync()
  ↓ 受信生データ取得
PlcCommunicationManager.ProcessReceivedRawData()
  ↓ ProcessedResponseData生成
DataOutputManager.OutputToJson()
  ↓ JSON出力
```

### 4.2 データ取得の実装例

```csharp
// ExecutionOrchestratorまたはApplicationController内で実行

// Step3-6: PLC通信・データ取得
var connectionConfig = configToFrameManager.GetConfig<ConnectionConfig>();
var processedData = await plcCommunicationManager.ProcessReceivedRawData(...);

// Step7: データ出力
var deviceConfig = BuildDeviceConfigDictionary(targetDeviceConfig);
dataOutputManager.OutputToJson(
    processedData,
    "./output",
    connectionConfig.IpAddress,
    connectionConfig.Port,
    deviceConfig
);
```

---

## 5. DeviceCode列挙型の活用

**ファイル**: `andon/Core/Constants/DeviceConstants.cs`

**定義**:
```csharp
public enum DeviceCode : byte
{
    // ビットデバイス（16点=1ワード）
    SM = 0x91,   // 特殊リレー
    X = 0x9C,    // 入力
    Y = 0x9D,    // 出力
    M = 0x90,    // 内部リレー
    L = 0x92,    // ラッチリレー
    F = 0x93,    // アナンシエータ
    B = 0xA0,    // リンクリレー

    // ワードデバイス
    SD = 0xA9,   // 特殊レジスタ
    D = 0xA8,    // データレジスタ
    W = 0xB4,    // リンクレジスタ
    R = 0xAF,    // ファイルレジスタ
    ZR = 0xB0,   // ファイルレジスタ（拡張）

    // タイマー
    TN = 0xC2,   // タイマ現在値
    TS = 0xC1,   // タイマ接点
    TC = 0xC0,   // タイマコイル

    // カウンタ
    CN = 0xC5,   // カウンタ現在値
    CS = 0xC4,   // カウンタ接点
    CC = 0xC3,   // カウンタコイル
}
```

**拡張メソッド**（同ファイル内に定義されている想定）:
```csharp
public static class DeviceCodeExtensions
{
    // ビットデバイス判定
    public static bool IsBitDevice(this DeviceCode code)
    {
        return code switch
        {
            DeviceCode.SM => true,
            DeviceCode.X => true,
            DeviceCode.Y => true,
            DeviceCode.M => true,
            DeviceCode.L => true,
            DeviceCode.F => true,
            DeviceCode.B => true,
            _ => false
        };
    }

    // 16進アドレス表記デバイス判定
    public static bool IsHexAddress(this DeviceCode code)
    {
        return code == DeviceCode.W || code == DeviceCode.ZR;
    }

    // ReadRandomコマンド対応判定
    public static bool IsReadRandomSupported(this DeviceCode code)
    {
        return code switch
        {
            DeviceCode.TS => false,  // タイマ接点（非対応）
            DeviceCode.TC => false,  // タイマコイル（非対応）
            DeviceCode.CS => false,  // カウンタ接点（非対応）
            DeviceCode.CC => false,  // カウンタコイル（非対応）
            _ => true
        };
    }
}
```

**DataOutputManagerでの使用例**:
```csharp
// ビットデバイス判定
if (deviceData.Code.IsBitDevice())
{
    // 16ビット展開処理
    for (int i = 0; i < 16; i++)
    {
        int bit = (int)((deviceData.Value >> i) & 1);
        // items配列に追加
    }
}
```

---

## 6. ファイル名生成の実装詳細

### 6.1 現在の実装（DataOutputManager.cs）

**実装箇所**: 行33-38

```csharp
// ファイル名生成: yyyymmdd_hhmmssSSS_xxx-xxx-x-xx_zzzz.json
var timestamp = data.ProcessedAt;
var dateString = timestamp.ToString("yyyyMMdd_HHmmssfff");
var ipString = ipAddress.Replace(".", "-");
var fileName = $"{dateString}_{ipString}_{port}.json";
var filePath = Path.Combine(outputDirectory, fileName);
```

**ファイル名形式**:
- `yyyyMMdd_HHmmssfff_xxx-xxx-x-xx_zzzz.json`
- 例: `20251126_123456789_192-168-1-10_5007.json`

### 6.2 設計書との違い

**設計書の仕様**:
- `xxx-xxx-x-xx_zzzz.json`（タイムスタンプなし）
- 例: `192-168-1-10_5007.json`

**実装の仕様**:
- `yyyyMMdd_HHmmssfff_xxx-xxx-x-xx_zzzz.json`（タイムスタンプ付き）
- 例: `20251126_123456789_192-168-1-10_5007.json`

**差異の理由**:
- タイムスタンプ付きで履歴管理が容易
- 同一PLCへの複数回出力に対応

**将来の対応**:
- 設計書を実装に合わせて更新
- または設定で切り替え可能にする

---

## 7. JSON出力の実装詳細

### 7.1 現在の実装（DataOutputManager.cs）

**実装箇所**: 行41-75

```csharp
// JSON構造構築
var jsonData = new
{
    source = new
    {
        plcModel = plcModel,          // 固定値 "Unknown"
        ipAddress = ipAddress,
        port = port
    },
    timestamp = new
    {
        local = timestamp.ToString("yyyy-MM-ddTHH:mm:ss.fffzzz")  // ISO 8601 with timezone
    },
    items = data.ProcessedData.Select(kvp => new
    {
        name = deviceConfig.TryGetValue(kvp.Key, out var config) ? config.Name : kvp.Key,
        device = new
        {
            code = kvp.Value.Code.ToString(),
            number = kvp.Value.Address.ToString()
        },
        digits = deviceConfig.TryGetValue(kvp.Key, out var config2) ? config2.Digits : 1,
        unit = kvp.Value.Type.ToLower(),  // "Bit" -> "bit", "Word" -> "word", "DWord" -> "dword"
        value = ConvertValue(kvp.Value)
    }).ToArray()
};

// JSON出力（インデント付き、読みやすい形式）
var options = new JsonSerializerOptions
{
    WriteIndented = true,
    Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping
};

var jsonString = JsonSerializer.Serialize(jsonData, options);
File.WriteAllText(filePath, jsonString);
```

### 7.2 plcModel値の取得方法（将来対応）

**現在**: 固定値 `"Unknown"`

**将来の取得方法**:
1. appsettings.jsonに `PlcModel` 設定追加
2. ConnectionConfigに `PlcModel` プロパティ追加
3. OutputToJsonメソッドのパラメータに追加

**設定例**:
```json
{
  "Connection": {
    "IpAddress": "192.168.1.10",
    "Port": 5007,
    "PlcModel": "Q00UJCPU"  // ← 追加
  }
}
```

### 7.3 device.number フォーマット

**現在の実装**:
```csharp
number = kvp.Value.Address.ToString()
```
- 結果: `"0"`, `"100"`, `"999"`

**設計書の仕様**:
- `"000"`, `"100"`, `"999"` （3桁ゼロ埋め）

**修正案**:
```csharp
number = kvp.Value.Address.ToString("D3")  // 3桁ゼロ埋め
```

---

## 8. ビットデバイス分割処理の実装

### 8.1 現在の実装状況

**現状**: ビットデバイス分割処理は**未実装**

**現在の動作**:
- ビットデバイスもワードデバイスと同様に1エントリとして出力
- M000（16ビット分）→ 1つのJSON itemとして出力

**必要な実装**:
- ビットデバイスを16個のitemに分割
- M000 → M000, M001, ..., M015として出力

### 8.2 実装方針

**修正箇所**: `DataOutputManager.OutputToJson()` メソッド内のitems生成部分

**修正前**:
```csharp
items = data.ProcessedData.Select(kvp => new
{
    name = deviceConfig.TryGetValue(kvp.Key, out var config) ? config.Name : kvp.Key,
    device = new { code = kvp.Value.Code.ToString(), number = kvp.Value.Address.ToString() },
    digits = deviceConfig.TryGetValue(kvp.Key, out var config2) ? config2.Digits : 1,
    unit = kvp.Value.Type.ToLower(),
    value = ConvertValue(kvp.Value)
}).ToArray()
```

**修正後**:
```csharp
var itemsList = new List<object>();

foreach (var kvp in data.ProcessedData)
{
    var deviceData = kvp.Value;

    // ビットデバイスの場合は16ビット分に展開
    if (deviceData.Code.IsBitDevice())
    {
        uint bitValue = deviceData.Value;
        for (int i = 0; i < 16; i++)
        {
            int bit = (int)((bitValue >> i) & 1);
            string bitDeviceName = $"{deviceData.Code}{deviceData.Address + i}";

            itemsList.Add(new
            {
                name = deviceConfig.TryGetValue(bitDeviceName, out var config) ? config.Name : bitDeviceName,
                device = new
                {
                    code = deviceData.Code.ToString(),
                    number = (deviceData.Address + i).ToString("D3")  // 3桁ゼロ埋め
                },
                digits = 1,
                unit = "bit",
                value = bit
            });
        }
    }
    else
    {
        // ワード/ダブルワードデバイスはそのまま
        itemsList.Add(new
        {
            name = deviceConfig.TryGetValue(kvp.Key, out var config) ? config.Name : kvp.Key,
            device = new
            {
                code = deviceData.Code.ToString(),
                number = deviceData.Address.ToString("D3")  // 3桁ゼロ埋め
            },
            digits = deviceConfig.TryGetValue(kvp.Key, out var config2) ? config2.Digits : 1,
            unit = deviceData.Type.ToLower(),
            value = ConvertValue(deviceData)
        });
    }
}

var jsonData = new
{
    source = ...,
    timestamp = ...,
    items = itemsList.ToArray()
};
```

### 8.3 deviceConfig辞書の対応

**ビットデバイス用の設定追加**:
```csharp
// M0指定時に、M0～M15の16個のエントリを生成
for (int i = 0; i < 16; i++)
{
    string bitDeviceName = $"M{deviceEntry.DeviceNumber + i}";
    deviceConfig[bitDeviceName] = new DeviceEntryInfo
    {
        Name = $"{deviceEntry.Description} ビット{i}",  // または個別の説明
        Digits = 1
    };
}
```

**appsettings.json設定例**:
```json
{
  "Devices": [
    {
      "DeviceType": "M",
      "DeviceNumber": 0,
      "Description": "停止纏めON=異常無",
      "BitDescriptions": [
        "ビット0: XXX",
        "ビット1: YYY",
        // ... 16個の説明
      ]
    }
  ]
}
```

---

## 9. エラーハンドリングの実装

### 9.1 現在の実装状況

**現状**: エラーハンドリング**未実装**

**必要な実装**:
1. try-catchブロックの追加
2. ファイルI/Oエラー処理
3. データ検証エラー処理
4. ログ出力

### 9.2 実装方針

**修正後のOutputToJsonメソッド**:
```csharp
public void OutputToJson(
    ProcessedResponseData data,
    string outputDirectory,
    string ipAddress,
    int port,
    Dictionary<string, DeviceEntryInfo> deviceConfig)
{
    try
    {
        // データ検証
        if (data == null || data.ProcessedData == null || data.ProcessedData.Count == 0)
        {
            throw new ArgumentException("ProcessedDataが空です");
        }

        // ディレクトリ存在確認・作成
        if (!Directory.Exists(outputDirectory))
        {
            Directory.CreateDirectory(outputDirectory);
        }

        // 既存のJSON生成処理
        // ...

        // ログ出力（正常系）
        Console.WriteLine($"JSON出力完了: {filePath}, デバイス数: {data.ProcessedData.Count}");
    }
    catch (UnauthorizedAccessException ex)
    {
        Console.WriteLine($"書き込み権限エラー: {ex.Message}");
        throw;
    }
    catch (IOException ex)
    {
        Console.WriteLine($"ファイルI/Oエラー: {ex.Message}");
        throw;
    }
    catch (Exception ex)
    {
        Console.WriteLine($"予期しないエラー: {ex.Message}");
        throw;
    }
}
```

---

## 10. 実装チェックリスト

### 10.1 Phase7実装時の確認項目

#### 必須項目
- [ ] ビットデバイス16ビット分割処理の実装
- [ ] device.numberの3桁ゼロ埋めフォーマット対応
- [ ] deviceConfig辞書の構築処理（ビットデバイス対応）
- [ ] エラーハンドリングの実装
- [ ] ログ出力の実装
- [ ] IDataOutputManagerインターフェースの更新
- [ ] ディレクトリ存在確認・作成処理

#### 推奨項目
- [ ] 非同期版メソッド `OutputToJsonAsync()` の実装
- [ ] plcModel値の動的取得（appsettings.jsonから）
- [ ] OutputResultクラスの実装（戻り値型）
- [ ] DeviceEntryInfoのファイル分離（ConfigModelsフォルダへ移動）

#### 将来対応項目
- [ ] ファイル名形式の設定による切り替え
- [ ] 複数出力形式対応（CSV等）
- [ ] ファイルローテーション機能
- [ ] データ圧縮保存機能

---

## 11. テスト実装時の注意点

### 11.1 モックデータの作成

**ProcessedResponseDataのモック**:
```csharp
var mockData = new ProcessedResponseData
{
    ProcessedData = new Dictionary<string, DeviceData>
    {
        ["M0"] = new DeviceData
        {
            DeviceName = "M0",
            Code = DeviceCode.M,
            Address = 0,
            Value = 0b1010110011010101,  // 16ビット値
            Type = "Bit"
        },
        ["D100"] = new DeviceData
        {
            DeviceName = "D100",
            Code = DeviceCode.D,
            Address = 100,
            Value = 12345,
            Type = "Word"
        }
    },
    ProcessedAt = DateTime.Now,
    IsSuccess = true
};
```

**deviceConfigのモック**:
```csharp
var mockDeviceConfig = new Dictionary<string, DeviceEntryInfo>
{
    ["M0"] = new DeviceEntryInfo { Name = "停止纏めON=異常無", Digits = 1 },
    ["M1"] = new DeviceEntryInfo { Name = "自動運転 開始", Digits = 1 },
    // ... M15まで
    ["D100"] = new DeviceEntryInfo { Name = "生産台数", Digits = 5 }
};
```

### 11.2 期待値の検証

**JSON出力の検証**:
```csharp
// ファイル存在確認
Assert.IsTrue(File.Exists(outputPath));

// JSON解析
string jsonContent = File.ReadAllText(outputPath);
var jsonDocument = JsonDocument.Parse(jsonContent);

// source検証
Assert.AreEqual("192.168.1.10", jsonDocument.RootElement.GetProperty("source").GetProperty("ipAddress").GetString());
Assert.AreEqual(5007, jsonDocument.RootElement.GetProperty("source").GetProperty("port").GetInt32());

// items検証
var items = jsonDocument.RootElement.GetProperty("items");
Assert.AreEqual(17, items.GetArrayLength());  // ビット16個 + ワード1個

// ビットデバイス検証
var m0 = items[0];
Assert.AreEqual("M", m0.GetProperty("device").GetProperty("code").GetString());
Assert.AreEqual("000", m0.GetProperty("device").GetProperty("number").GetString());
Assert.AreEqual("bit", m0.GetProperty("unit").GetString());
```

---

## 12. 補足資料

### 12.1 関連ファイルパス一覧

```
andon/
├── Core/
│   ├── Managers/
│   │   ├── DataOutputManager.cs              // 既存実装あり
│   │   └── PlcCommunicationManager.cs        // データ取得元
│   ├── Models/
│   │   ├── ProcessedResponseData.cs          // 入力データ型
│   │   ├── DeviceData.cs                     // デバイスデータ型
│   │   ├── StructuredData.cs                 // 将来の入力データ型
│   │   └── ConfigModels/
│   │       ├── ConnectionConfig.cs           // 接続設定
│   │       └── DeviceEntryInfo.cs (将来)    // デバイス説明情報
│   ├── Interfaces/
│   │   └── IDataOutputManager.cs             // インターフェース（TODO状態）
│   └── Constants/
│       └── DeviceConstants.cs                // DeviceCode列挙型
└── Tests/
    └── Unit/
        └── Core/
            └── Managers/
                └── DataOutputManagerTests.cs   // 単体テスト
```

### 12.2 依存関係図

```
ExecutionOrchestrator / ApplicationController
  ↓
ConfigToFrameManager.GetConfig<ConnectionConfig>()
  ↓
PlcCommunicationManager.ProcessReceivedRawData()
  ↓ ProcessedResponseData
DataOutputManager.OutputToJson()
  ↓ JSON File
```

---

## 作成日時
- **作成日**: 2025年11月26日
- **対象Phase**: Phase7（データ出力機能実装）
- **更新履歴**: 初版作成
