# Step7 データ出力機能 実装ガイド

## 概要

本文書は、Step7データ出力機能の実装時に参照すべき情報を集約したガイドです。

---

## 1. 出力ファイル仕様

### 1.1 ファイル保存方式

- **保存ルール**: 1つのPLCにつき1つのJSONファイルを保持
- **上書き方式**: データ出力時に同名ファイルに上書き
- **複数PLC対応**: 3つのPLCからデータ取得した場合は3つのファイルが生成される

### 1.2 ファイル名規則

**形式**: `xxx-xxx-x-xx_zzzz.json`

- `xxx-xxx-x-xx`: IPアドレスのドット(`.`)をハイフン(`-`)に変換した文字列
  - 例: IPアドレス `192.168.1.10` → ファイル名 `192-168-1-10_5007.json`
- `zzzz`: ポート番号（4桁）
  - 例: ポート `5007` → `_5007`

**実装時の処理**:
```csharp
// IPアドレス変換処理
string fileName = ipAddress.Replace(".", "-") + "_" + port.ToString() + ".json";
```

### 1.3 JSON出力構造

```json
{
  "source": {
    "plcModel": "Q00UJCPU",
    "ipAddress": "192.168.1.10",
    "port": 5007
  },
  "timestamp": {
    "local": "2025-11-26T12:34:56+09:00"
  },
  "items": [
    {
      "name": "停止纏めON=異常無",
      "device": {
        "code": "M",
        "number": "000"
      },
      "digits": 1,
      "unit": "bit",
      "value": 1
    },
    {
      "name": "生産台数",
      "device": {
        "code": "D",
        "number": "100"
      },
      "digits": 5,
      "unit": "word",
      "value": 12345
    }
  ]
}
```

### 1.4 JSON各フィールド定義

#### sourceセクション
- `plcModel`: string（必須） - PLC機種名
- `ipAddress`: string（必須） - IPv4/IPv6書式
- `port`: integer（必須） - 1～65535の範囲

#### timestampセクション
- `local`: string（必須） - ISO 8601ローカル時刻、タイムゾーンオフセット付き
  - 例: `"2025-11-26T12:34:56+09:00"`

#### itemsセクション
- `items`: array（必須） - デバイスデータの配列
  - `name`: string（必須） - デバイスの説明名
  - `device.code`: string（必須） - デバイスコード（"M", "D", "W"等）
  - `device.number`: string（必須） - デバイス番号（3桁ゼロ埋め）
  - `digits`: integer（必須） - 表示桁数（1以上）
  - `unit`: string（必須） - "bit", "word", "dword"のいずれか
  - `value`: string または number - デバイス値
    - unit="bit"の場合: 0または1（整数）
    - unit="word"/"dword"の場合: string, int16/int32, uint16/uint32, float16/float32

### 1.5 ビットデバイス分割出力仕様

**重要**: Read Randomコマンドでビットデバイスを取得した場合、1ワード（16ビット）単位で取得されるため、JSON出力時に16デバイス分に分割する必要がある。

**処理の流れ**:
1. Read Randomコマンド送信: ビットデバイスM000を指定（アクセス点数=1）
2. 受信データ: 16ビット分のデータ（M000～M015）
3. Step6受信データ処理: 16ビット分を保持
4. **Step7データ出力**: 16ビット分をM000, M001, ..., M015に分割してitems配列に格納

**出力例**:
```json
{
  "items": [
    {
      "name": "停止纏めON=異常無",
      "device": {
        "code": "M",
        "number": "000"
      },
      "digits": 1,
      "unit": "bit",
      "value": 1
    },
    {
      "name": "自動運転    開始",
      "device": {
        "code": "M",
        "number": "001"
      },
      "digits": 1,
      "unit": "bit",
      "value": 1
    },
    // ... M002～M015まで続く
  ]
}
```

---

## 2. DataOutputManager実装仕様

### 2.1 クラス配置
- **実装場所**: `andon/Core/Managers/DataOutputManager.cs`
- **インターフェース**: `andon/Core/Interfaces/IDataOutputManager.cs`

### 2.2 依存関係

**データ取得元**:
- `PlcCommunicationManager.ParseRawToStructuredData()`: 構造化データ（StructuredData型）
- `ConfigToFrameManager.LoadConfigAsync()`: 出力設定（DataProcessingConfig型）

**データ形式**:
- **入力**: `StructuredData`（Step6で生成された構造化データ）
  - `DeviceData`: `Dictionary<string, DeviceData>` - デバイス名キー構造
  - `ReceivedAt`: `DateTime` - 受信時刻
  - `SlmpHeader`: `SlmpHeaderInfo` - SLMPヘッダー情報
- **出力**: JSON形式ファイル

### 2.3 主要メソッド

#### OutputDataAsync（データ出力）

**シグネチャ**:
```csharp
Task<OutputResult> OutputDataAsync(
    StructuredData structuredData,
    DataProcessingConfig config,
    string outputDirectory = "./output"
);
```

**Input**:
- `structuredData`: `StructuredData`型 - Step6で生成された構造化データ
- `config`: `DataProcessingConfig`型 - データ処理設定
- `outputDirectory`: `string`型 - 出力先ディレクトリパス（デフォルト: "./output"）

**Output**:
- `OutputResult`型 - 出力結果オブジェクト
  - `OutputPath`: `string` - 実際の出力ファイルパス
  - `BytesWritten`: `long` - 書き込んだバイト数
  - `RecordsWritten`: `int` - 書き込んだレコード数
  - `WriteTime`: `TimeSpan` - 書き込み時間
  - `Success`: `bool` - 出力成功フラグ
  - `ErrorMessage`: `string?` - エラーメッセージ（失敗時）

**処理内容**:
1. ファイル名生成（IPアドレスとポート番号から）
2. JSON構造の構築
   - sourceセクション生成
   - timestampセクション生成
   - itemsセクション生成（ビットデバイス分割処理を含む）
3. JSONファイル書き込み
4. エラーハンドリング

---

## 3. 設定関連モデル

### 3.1 DeviceEntryInfo（Phase7新規追加）

**実装場所**: `andon/Core/Models/ConfigModels/DeviceEntryInfo.cs`

**プロパティ**:
- `Name`: `string` - デバイス説明名（JSON出力のnameフィールド）
- `Digits`: `int` - 表示桁数（JSON出力のdigitsフィールド）

**用途**:
- DataOutputManagerのJSON出力時にデバイス説明情報を提供
- appsettings.jsonから読み込まれた設定情報を保持

**設定ファイルマッピング**:
```json
{
  "Devices": [
    {
      "DeviceType": "M",
      "DeviceNumber": 0,
      "Name": "停止纏めON=異常無",  // ← DeviceEntryInfo.Name
      "Digits": 1                    // ← DeviceEntryInfo.Digits
    }
  ]
}
```

### 3.2 DataProcessingConfig

**実装場所**: `andon/Core/Models/ConfigModels/DataProcessingConfig.cs`

**プロパティ**:
- `TargetName`: `string` - データ識別名
- `ContinuousDataMode`: `bool` - 継続データモード有効化（将来実装用）
- `DataRetentionDays`: `int` - データ保持日数（将来実装用）

---

## 4. データ構造変換フロー

### 4.1 Step6からStep7へのデータ受け渡し

**Step6の出力（StructuredData）**:
```csharp
public class StructuredData
{
    public SlmpHeaderInfo SlmpHeader { get; set; }
    public ushort EndCode { get; set; }
    public Dictionary<string, DeviceData> DeviceData { get; set; }  // ← 重要
    public DateTime ReceivedAt { get; set; }
    public bool HasError { get; set; }
    // ...その他のプロパティ
}
```

**DeviceData構造**:
```csharp
public class DeviceData
{
    public string DeviceName { get; set; }      // "M000", "D100"等
    public DeviceCode Code { get; set; }        // M, D, W等
    public int Address { get; set; }            // デバイス番号
    public uint Value { get; set; }             // デバイス値
    public bool IsDWord { get; set; }           // ダブルワードフラグ
    public bool IsHexAddress { get; set; }      // 16進アドレス表記フラグ
}
```

**Step7での変換処理**:
```csharp
// StructuredData.DeviceData から JSON items配列への変換
foreach (var (deviceName, deviceData) in structuredData.DeviceData)
{
    // ビットデバイスの場合は16ビット分に分割
    if (deviceData.Code.IsBitDevice())
    {
        // 16ビット分に展開
        for (int i = 0; i < 16; i++)
        {
            // 各ビットをitems配列に追加
        }
    }
    else
    {
        // ワード/ダブルワードデバイスはそのまま追加
    }
}
```

### 4.2 ビットデバイス分割処理詳細

**入力データ例**:
- `DeviceData["M000"]`: Value = 0b1010110011010101（2バイト）

**出力データ例**:
```json
[
  {"device": {"code": "M", "number": "000"}, "value": 1},  // ビット0
  {"device": {"code": "M", "number": "001"}, "value": 0},  // ビット1
  {"device": {"code": "M", "number": "002"}, "value": 1},  // ビット2
  // ... 続く
  {"device": {"code": "M", "number": "015"}, "value": 1}   // ビット15
]
```

**実装コード例**:
```csharp
// 16ビット分に展開
uint bitValue = deviceData.Value;
for (int i = 0; i < 16; i++)
{
    int bit = (int)((bitValue >> i) & 1);
    string bitDeviceNumber = (deviceData.Address + i).ToString("D3");

    var item = new JsonOutputItem
    {
        Name = GetDeviceName(deviceData.Code, bitDeviceNumber),  // 設定から取得
        Device = new { Code = deviceData.Code.ToString(), Number = bitDeviceNumber },
        Digits = 1,
        Unit = "bit",
        Value = bit
    };
    items.Add(item);
}
```

---

## 5. エラーハンドリング

### 5.1 ファイル出力エラー

**検出すべきエラー**:
- ディスクフル（ディスク容量不足）
- アクセス権限エラー（書き込み権限なし）
- パス不正エラー（存在しないディレクトリ等）

**エラー処理**:
```csharp
try
{
    // ファイル書き込み処理
    await File.WriteAllTextAsync(filePath, jsonContent);
}
catch (UnauthorizedAccessException ex)
{
    return new OutputResult
    {
        Success = false,
        ErrorMessage = "書き込み権限がありません: " + filePath
    };
}
catch (IOException ex)
{
    return new OutputResult
    {
        Success = false,
        ErrorMessage = "ファイル書き込みエラー: " + ex.Message
    };
}
```

### 5.2 データ変換エラー

**検出すべきエラー**:
- DeviceData辞書がnullまたは空
- デバイス情報不正（DeviceEntryInfo未設定）
- JSON変換エラー

---

## 6. ログ出力設計

### 6.1 出力すべきログ情報

**正常系**:
- 出力ファイル名
- 書き込んだデバイス数
- 書き込み時間
- ファイルサイズ

**異常系**:
- エラー内容
- エラー発生箇所
- スタックトレース（デバッグモード時）

### 6.2 ログ出力例

```csharp
_logger.LogInformation(
    "データ出力完了: ファイル={FilePath}, デバイス数={DeviceCount}, 処理時間={Duration}ms",
    result.OutputPath,
    result.RecordsWritten,
    result.WriteTime.TotalMilliseconds
);

_logger.LogError(
    "データ出力失敗: ファイル={FilePath}, エラー={ErrorMessage}",
    filePath,
    result.ErrorMessage
);
```

---

## 7. テスト要件

### 7.1 単体テスト（TC042-TC046）

**テストファイル**: `Tests/Unit/Core/Managers/DataOutputManagerTests.cs`

**テストケース**:
1. **TC042**: 正常系 - ビットデバイスのみ
2. **TC043**: 正常系 - ワードデバイスのみ
3. **TC044**: 正常系 - ダブルワードデバイスのみ
4. **TC045**: 正常系 - 混在（ビット+ワード+ダブルワード）
5. **TC046**: 異常系 - ファイル書き込み失敗

**モック・スタブ**:
- `MockLoggingManager`: ログ出力のモック
- `ConfigurationStubs`: 設定データのスタブ
- `PlcResponseStubs`: 構造化データのスタブ

### 7.2 統合テスト

**Step3-6統合テスト**: `Tests/Integration/Step3_6_IntegrationTests.cs`
- PLC通信からデータ出力までの一貫処理テスト
- 実ファイル生成とJSON内容検証

---

## 8. 実装順序（推奨）

### Phase 1: 基本構造実装
1. `IDataOutputManager`インターフェース定義
2. `DataOutputManager`クラス骨組み実装
3. `DeviceEntryInfo`モデルクラス実装

### Phase 2: JSON生成機能実装
1. ファイル名生成処理
2. sourceセクション生成
3. timestampセクション生成
4. itemsセクション生成（ワード/ダブルワードのみ）

### Phase 3: ビットデバイス分割処理実装
1. ビットデバイス判定ロジック
2. 16ビット展開処理
3. デバイス名マッピング処理

### Phase 4: エラーハンドリング実装
1. ファイル出力エラー処理
2. データ変換エラー処理
3. ログ出力

### Phase 5: テスト実装
1. 単体テスト（TC042-TC046）
2. モック・スタブ作成
3. 統合テスト

---

## 9. パフォーマンス考慮事項

### 9.1 メモリ使用量

- JSON生成時の文字列連結を最小化（StringBuilderまたはSystem.Text.Json使用）
- 大量デバイス処理時のメモリアロケーション最適化

### 9.2 ファイルI/O

- 非同期書き込み（`WriteAllTextAsync`）使用
- ディスク容量事前チェック（将来実装）

---

## 10. 将来拡張機能（Phase7では実装しない）

### 10.1 CSV出力機能（旧設計）
- CsvFileWriterクラス
- 継続データモード（追記モード）
- 古いファイル削除機能（CleanupOldFilesAsync）

### 10.2 データ転送機能（オプション）
- DataTransferManagerクラス
- ネットワーク転送（TCP/UDP/HTTP）
- リトライ処理

### 10.3 ファイル管理機能
- ファイルローテーション
- 圧縮保存
- データ保持期間管理

---

## 11. 参照文書

### 本フォルダ内
- `出力ファイル設計.md`: 出力ファイル仕様
- `実装時対応関係.md`: **既存実装との連携・対応関係の詳細** ⭐重要

### 設計文書フォルダ
- `クラス設計/Step7_データ出力.md`: クラス設計詳細
- `クラス設計/インターフェース定義.md`: インターフェース設計
- `クラス設計/補助クラス・データモデル.md`: データモデル定義
- `プロジェクト構造設計.md`: プロジェクト全体構造

---

## 12. 実装時の重要な注意事項

### 12.1 既存実装との違い

**重要**: 本実装ガイドの設計と既存実装には以下の差異があります。詳細は `実装時対応関係.md` を参照してください。

1. **入力データ型**: 設計書は `StructuredData` を想定、実装は `ProcessedResponseData` を使用
2. **ファイル名形式**: 設計書は `xxx-xxx-x-xx_zzzz.json`、実装は `yyyyMMdd_HHmmssfff_xxx-xxx-x-xx_zzzz.json`
3. **ビットデバイス分割**: 設計書では必須、現在の実装では未実装（要実装）
4. **device.number フォーマット**: 設計書は3桁ゼロ埋め、現在の実装は未対応（要修正）

### 12.2 実装優先順位

Phase7実装時は以下の順序で対応してください:

1. **最優先**: ビットデバイス16ビット分割処理の実装
2. **高優先**: device.numberの3桁ゼロ埋めフォーマット対応
3. **高優先**: エラーハンドリングの実装
4. **中優先**: IDataOutputManagerインターフェースの更新
5. **低優先**: plcModel値の動的取得

---

## 作成日時
- **作成日**: 2025年11月26日
- **最終更新**: 2025年11月26日
- **対象Phase**: Phase7（データ出力機能実装）
