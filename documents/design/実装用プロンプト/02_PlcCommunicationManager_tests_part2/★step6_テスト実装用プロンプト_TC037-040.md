# TC037-TC040_ParseRawToStructuredData実装プロンプト

## 実装指示

**コード作成を開始してください。**

TC037-TC040 ParseRawToStructuredDataテストケースを、TDD手法に従って実装してください。

---

## 実装概要

### 目的
PlcCommunicationManager.ParseRawToStructuredData()メソッドのテストケースTC037-TC040を実装します。
このテストは、SLMPフレームの構造化データ変換機能が正常に動作することを検証します。

### 実装対象
- **テストファイル**: `Tests/Unit/Core/Managers/PlcCommunicationManagerTests_ParseRawToStructuredData.cs`
- **テスト名前空間**: `andon.Tests.Unit.Core.Managers`
- **テストメソッド名**:
  - `TC037_ParseRawToStructuredData_3E_Binary`
  - `TC037_ParseRawToStructuredData_3E_ASCII`
  - `TC038_ParseRawToStructuredData_4E_Binary_実機データ`
  - `TC038_ParseRawToStructuredData_4E_ASCII`
  - `TC039_ParseRawToStructuredData_DWord結合済み`
  - `TC040_ParseRawToStructuredData_DWord結合未実行_例外`
  - `TC040_ParseRawToStructuredData_不正フレームタイプ_例外`
  - `TC040_ParseRawToStructuredData_不完全フレーム_例外`

---

## 前提条件の確認

実装開始前に以下を確認してください：

1. **依存ファイルの存在確認**
   - `Core/Managers/PlcCommunicationManager.cs` (ParseRawToStructuredDataメソッド追加可)
   - `Core/Interfaces/IPlcCommunicationManager.cs`
   - `Core/Models/ProcessedResponseData.cs`
   - `Core/Models/StructuredData.cs`
   - `Core/Constants/ErrorMessages.cs`

2. **テストユーティリティの確認**
   - `Tests/TestUtilities/TestDataGenerator.cs` (テストデータ生成用)

3. **開発手法ドキュメント確認**
   - `C:\Users\1010821\Desktop\python\andon\documents\development_methodology\development-methodology.md`を参照

不足しているファイルがあれば報告してください。

---

## 実装手順（TDD Red-Green-Refactor）

### Phase 1: Red（テスト失敗）

#### Step 1-1: テストファイル作成
```
ファイル: Tests/Unit/Core/Managers/PlcCommunicationManagerTests_ParseRawToStructuredData.cs
名前空間: andon.Tests.Unit.Core.Managers
```

#### Step 1-2: テストケース実装（優先順位順）

---

### TC037_ParseRawToStructuredData_3E_Binary（最優先）

**Arrange（準備）**:
1. **入力データ準備（13バイト）**:
```csharp
byte[] rawData = new byte[] {
    0xD0, 0x00,         // サブヘッダ（3E Binary応答）
    0x00,               // ネットワーク番号
    0xFF,               // PC番号
    0xFF, 0x03,         // I/O番号（LE: 0x03FF）
    0x00,               // 局番
    0x04, 0x00,         // データ長（LE: 4バイト）
    0x00, 0x00,         // 終了コード（正常終了）
    0xC8, 0x00          // デバイスデータ（2バイト）
};
```

2. **ProcessedResponseData作成**:
```csharp
var processedResponse = new ProcessedResponseData
{
    RawData = rawData,
    IsDwordCombined = true,
    ProcessedAt = DateTime.Now,
    HasError = false,
    ProcessedDeviceCount = 8
};
```

3. **期待値準備**:
```csharp
var expected = new StructuredData
{
    FrameType = "3E",
    IsBinary = true,
    SubHeader = (ushort)0xD000,
    NetworkNumber = 0x00,
    PcNumber = 0xFF,
    IoNumber = 0x03FF,
    StationNumber = 0x00,
    DataLength = 4,
    EndCode = 0x0000,
    DeviceDataOffset = 11,
    DeviceDataLength = 2,
    DeviceData = new byte[] { 0xC8, 0x00 },
    BitValues = new bool[] { false, false, false, true, false, false, true, true }, // M100-M107: 0,0,0,1,0,0,1,1
    IsError = false
};
```

**Act（実行）**:
```csharp
var result = manager.ParseRawToStructuredData(processedResponse);
```

**Assert（検証）**:
- `result.FrameType == "3E"`
- `result.IsBinary == true`
- `result.SubHeader == 0xD000`
- `result.EndCode == 0x0000`
- `result.DeviceDataOffset == 11`
- `result.DeviceDataLength == 2`
- `result.DeviceData` がバイト配列として正しい
- `result.BitValues[0] == false` (M100)
- `result.BitValues[3] == true` (M103)
- `result.BitValues[6] == true` (M106)
- `result.BitValues[7] == true` (M107)

---

### TC037_ParseRawToStructuredData_3E_ASCII

**Arrange（準備）**:
1. **入力データ準備（文字列）**:
```csharp
string asciiFrame = "D00000FF03FF000004000000C800";
byte[] rawData = Encoding.ASCII.GetBytes(asciiFrame);
```

2. **ProcessedResponseData作成**:
```csharp
var processedResponse = new ProcessedResponseData
{
    RawData = rawData,
    IsDwordCombined = true,
    ProcessedAt = DateTime.Now,
    HasError = false
};
```

3. **期待値準備**:
```csharp
var expected = new StructuredData
{
    FrameType = "3E",
    IsBinary = false,
    SubHeader = "D000",
    NetworkNumber = 0x00,
    PcNumber = 0xFF,
    IoNumber = 0x03FF,
    StationNumber = 0x00,
    DataLength = 4,
    EndCode = 0x0000,
    DeviceDataOffset = 20,
    DeviceData = "C800",
    BitValues = new bool[] { false, false, false, true, false, false, true, true },
    IsError = false
};
```

**Act（実行）**:
```csharp
var result = manager.ParseRawToStructuredData(processedResponse);
```

**Assert（検証）**:
- `result.FrameType == "3E"`
- `result.IsBinary == false`
- `result.SubHeader == "D000"`
- `result.DeviceDataOffset == 20`
- `result.DeviceData == "C800"`
- `result.BitValues` が正しく変換されている

---

### TC038_ParseRawToStructuredData_4E_Binary_実機データ（重要）

**Arrange（準備）**:
1. **実機入力データ準備（113バイト）**:
```csharp
byte[] rawData = new byte[] {
    // サブヘッダ（2バイト）
    0xD4, 0x00,
    // シリアル・予約（4バイト）
    0x00, 0x00, 0x00, 0x00,
    // ヘッダー（11バイト）
    0x00,               // ネットワーク番号
    0xFF,               // PC番号
    0xFF, 0x03,         // I/O番号（LE: 0x03FF）
    0x00,               // 局番
    0x62, 0x00,         // データ長（LE: 98バイト）
    0x00, 0x00,         // 監視タイマ（応答は0固定）
    0x00, 0x00,         // 終了コード（オフセット15-16）← 重要！
    // デバイスデータ（96バイト、オフセット17-）← 重要！
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x07, 0x19,         // Word 8: 0x1907 (6407) ← 検証ポイント
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x00, 0x10, 0x00, 0x08, 0x00, 0x01,
    0x00, 0x10, 0x00, 0x10, 0x00, 0x08,
    0x20, 0x00,         // Word 23: 0x0020 (32) ← 検証ポイント
    0x10, 0x00,         // Word 24: 0x0010 (16) ← 検証ポイント
    0x08, 0x00,         // Word 25: 0x0008 (8) ← 検証ポイント
    0x02, 0x00,         // Word 26: 0x0002 (2) ← 検証ポイント
    // 残り21ワード（42バイト）はすべて0x00
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
};
```

2. **ProcessedResponseData作成**:
```csharp
var processedResponse = new ProcessedResponseData
{
    RawData = rawData,
    IsDwordCombined = true,
    ProcessedAt = DateTime.Now,
    HasError = false,
    ProcessedDeviceCount = 48
};
```

3. **期待値準備**:
```csharp
var expected = new StructuredData
{
    FrameType = "4E",
    IsBinary = true,
    SubHeader = (ushort)0xD400,
    SerialNumber = 0x0000,
    NetworkNumber = 0x00,
    PcNumber = 0xFF,
    IoNumber = 0x03FF,
    StationNumber = 0x00,
    DataLength = 98,
    EndCode = 0x0000,
    DeviceDataOffset = 17,      // ← 重要！
    DeviceDataLength = 96,
    IsError = false
};
```

**Act（実行）**:
```csharp
var result = manager.ParseRawToStructuredData(processedResponse);
```

**Assert（検証）**:
- **フレームタイプ検証**:
  - `result.FrameType == "4E"`
  - `result.IsBinary == true`
  - `result.SubHeader == 0xD400`
- **シリアル・予約フィールド検証**:
  - `result.SerialNumber == 0x0000`
- **ヘッダー検証**:
  - `result.NetworkNumber == 0x00`
  - `result.PcNumber == 0xFF`
  - `result.IoNumber == 0x03FF`
  - `result.DataLength == 98`
- **終了コード検証（最重要）**:
  - `result.EndCode == 0x0000`
  - 終了コードはオフセット15-16から抽出されている（11-12ではない！）
- **デバイスデータ検証（最重要）**:
  - `result.DeviceDataOffset == 17` （13ではない！）
  - `result.DeviceDataLength == 96`
- **ワードデータ検証（特徴的な値）**:
  - `result.WordData[8] == 0x1907` (6407)
  - `result.WordData[23] == 0x0020` (32)
  - `result.WordData[24] == 0x0010` (16)
  - `result.WordData[25] == 0x0008` (8)
  - `result.WordData[26] == 0x0002` (2)

**不合格条件（即座に調査が必要）**:
- ❌ 終了コード抽出位置が誤っている（オフセット11-12を使用）
- ❌ デバイスデータ開始位置が誤っている（オフセット13を使用）
- ❌ シリアル・予約フィールドが考慮されていない
- ❌ ワード値がリトルエンディアンで正しく変換されていない

---

### TC038_ParseRawToStructuredData_4E_ASCII

**Arrange（準備）**:
1. **入力データ準備（文字列）**:
```csharp
string asciiFrame = "D40000000000FFFF03000062000000FFFF" +
                    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" +
                    "FFFFFFFFFFFFFFFF0719FFFFFFFFFFFF" +
                    "FFFFFFFFFFFFFFFFFFFFFFFFFF00100008" +
                    "00010010001000080020001000080002" +
                    new string('0', 84); // 残り42バイト（84文字）

byte[] rawData = Encoding.ASCII.GetBytes(asciiFrame);
```

2. **ProcessedResponseData作成**:
```csharp
var processedResponse = new ProcessedResponseData
{
    RawData = rawData,
    IsDwordCombined = true,
    ProcessedAt = DateTime.Now,
    HasError = false
};
```

**Act（実行）**:
```csharp
var result = manager.ParseRawToStructuredData(processedResponse);
```

**Assert（検証）**:
- `result.FrameType == "4E"`
- `result.IsBinary == false`
- `result.SubHeader == "D400"`
- `result.DeviceDataOffset == 30`
- `result.WordData[8] == 0x1907`

---

### TC039_ParseRawToStructuredData_DWord結合済み

**Arrange（準備）**:
1. **DWord結合済みデータ準備**:
```csharp
var processedData = new Dictionary<string, object>
{
    { "D100", (uint)0x12345678 },
    { "D102", (uint)0xABCDEF00 }
};

var processedResponse = new ProcessedResponseData
{
    RawData = rawData, // 4Eフレーム
    ProcessedData = processedData,
    IsDwordCombined = true,
    DwordCombinedCount = 2,
    ProcessedAt = DateTime.Now,
    HasError = false
};
```

**Act（実行）**:
```csharp
var result = manager.ParseRawToStructuredData(processedResponse);
```

**Assert（検証）**:
- `result.IsDwordCombined == true`
- DWord結合されたデバイス情報が保持される
- 32bit値が正しく解釈されている

---

### TC040_ParseRawToStructuredData_DWord結合未実行_例外

**Arrange（準備）**:
```csharp
var processedResponse = new ProcessedResponseData
{
    RawData = rawData,
    IsDwordCombined = false,  // ← 未実行フラグ
    ProcessedAt = DateTime.Now
};
```

**Act & Assert（実行・検証）**:
```csharp
var ex = Assert.Throws<InvalidOperationException>(
    () => manager.ParseRawToStructuredData(processedResponse)
);
Assert.Contains("DWord結合処理が未実行です", ex.Message);
```

---

### TC040_ParseRawToStructuredData_不正フレームタイプ_例外

**Arrange（準備）**:
```csharp
byte[] rawData = new byte[] {
    0xAA, 0x00,  // 不正なサブヘッダ
    0x00, 0xFF, 0xFF, 0x03, 0x00
};

var processedResponse = new ProcessedResponseData
{
    RawData = rawData,
    IsDwordCombined = true
};
```

**Act & Assert（実行・検証）**:
```csharp
var ex = Assert.Throws<ArgumentException>(
    () => manager.ParseRawToStructuredData(processedResponse)
);
Assert.Contains("不明なフレームタイプです: 0xAA00", ex.Message);
```

---

### TC040_ParseRawToStructuredData_不完全フレーム_例外

**Arrange（準備）**:
```csharp
byte[] rawData = new byte[] {
    0xD4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x03
    // 4Eフレームなのに10バイトしかない
};

var processedResponse = new ProcessedResponseData
{
    RawData = rawData,
    IsDwordCombined = true
};
```

**Act & Assert（実行・検証）**:
```csharp
var ex = Assert.Throws<ArgumentException>(
    () => manager.ParseRawToStructuredData(processedResponse)
);
Assert.Contains("フレームデータが不完全です", ex.Message);
Assert.Contains("期待バイト数: 17", ex.Message);
Assert.Contains("実際: 10", ex.Message);
```

---

#### Step 1-3: テスト実行（Red確認）
```bash
dotnet test --filter "FullyQualifiedName~TC037|TC038|TC039|TC040"
```

期待結果: すべてのテスト失敗（ParseRawToStructuredDataが未実装のため）

---

### Phase 2: Green（最小実装）

#### Step 2-1: ParseRawToStructuredData最小実装

**実装箇所**: `Core/Managers/PlcCommunicationManager.cs`

**最小実装要件**:
```csharp
public StructuredData ParseRawToStructuredData(ProcessedResponseData processedResponse)
{
    // 1. DWord結合処理チェック
    if (!processedResponse.IsDwordCombined)
    {
        throw new InvalidOperationException(ErrorMessages.DwordCombineNotExecuted);
    }

    byte[] rawData = processedResponse.RawData;

    // 2. フレームタイプ判定
    bool isBinary = rawData[0] == 0xD0 || rawData[0] == 0xD4;
    string frameType;
    ushort subHeader;

    if (isBinary)
    {
        subHeader = BitConverter.ToUInt16(rawData, 0);
        frameType = (subHeader == 0xD000) ? "3E" : "4E";
    }
    else
    {
        string asciiHeader = Encoding.ASCII.GetString(rawData, 0, 2);
        frameType = (asciiHeader == "D0") ? "3E" : "4E";
    }

    // 3. フレームタイプ別解析
    if (frameType == "3E" && isBinary)
    {
        return Parse3EBinary(rawData);
    }
    else if (frameType == "3E" && !isBinary)
    {
        return Parse3EAscii(rawData);
    }
    else if (frameType == "4E" && isBinary)
    {
        return Parse4EBinary(rawData);
    }
    else if (frameType == "4E" && !isBinary)
    {
        return Parse4EAscii(rawData);
    }

    throw new ArgumentException(string.Format(ErrorMessages.UnknownFrameType, subHeader));
}

private StructuredData Parse3EBinary(byte[] rawData)
{
    // 最小ヘッダーサイズチェック（11バイト）
    if (rawData.Length < 11)
    {
        throw new ArgumentException(
            string.Format(ErrorMessages.IncompleteFrameData, 11, rawData.Length)
        );
    }

    var result = new StructuredData
    {
        FrameType = "3E",
        IsBinary = true,
        SubHeader = BitConverter.ToUInt16(rawData, 0),
        NetworkNumber = rawData[2],
        PcNumber = rawData[3],
        IoNumber = BitConverter.ToUInt16(rawData, 4),
        StationNumber = rawData[6],
        DataLength = BitConverter.ToUInt16(rawData, 7),
        EndCode = BitConverter.ToUInt16(rawData, 9),
        DeviceDataOffset = 11,
        ReceivedAt = DateTime.Now,
        IsError = false
    };

    // デバイスデータ抽出
    int deviceDataLength = result.DataLength - 2; // 終了コード2バイトを除く
    result.DeviceDataLength = deviceDataLength;
    result.DeviceData = rawData.Skip(11).Take(deviceDataLength).ToArray();

    // ビットデータ変換（BCDデコード）
    result.BitValues = ParseBinaryBitData((byte[])result.DeviceData, 8);

    return result;
}

private StructuredData Parse4EBinary(byte[] rawData)
{
    // 最小ヘッダーサイズチェック（17バイト）
    if (rawData.Length < 17)
    {
        throw new ArgumentException(
            string.Format(ErrorMessages.IncompleteFrameData, 17, rawData.Length)
        );
    }

    var result = new StructuredData
    {
        FrameType = "4E",
        IsBinary = true,
        SubHeader = BitConverter.ToUInt16(rawData, 0),
        SerialNumber = BitConverter.ToUInt16(rawData, 2),
        NetworkNumber = rawData[6],
        PcNumber = rawData[7],
        IoNumber = BitConverter.ToUInt16(rawData, 8),
        StationNumber = rawData[10],
        DataLength = BitConverter.ToUInt16(rawData, 11),
        EndCode = BitConverter.ToUInt16(rawData, 15),  // ← オフセット15-16が重要！
        DeviceDataOffset = 17,  // ← オフセット17が重要！
        ReceivedAt = DateTime.Now,
        IsError = false
    };

    // デバイスデータ抽出
    int deviceDataLength = result.DataLength - 2; // 終了コード2バイトを除く
    result.DeviceDataLength = deviceDataLength;
    result.DeviceData = rawData.Skip(17).Take(deviceDataLength).ToArray();

    // ワードデータ変換（リトルエンディアン）
    result.WordData = ParseBinaryWordData((byte[])result.DeviceData);

    return result;
}

private StructuredData Parse3EAscii(byte[] rawData)
{
    string asciiFrame = Encoding.ASCII.GetString(rawData);

    var result = new StructuredData
    {
        FrameType = "3E",
        IsBinary = false,
        SubHeader = asciiFrame.Substring(0, 4),
        NetworkNumber = (byte)Convert.ToInt32(asciiFrame.Substring(2, 2), 16),
        PcNumber = (byte)Convert.ToInt32(asciiFrame.Substring(4, 2), 16),
        IoNumber = (ushort)Convert.ToInt32(asciiFrame.Substring(6, 4), 16),
        StationNumber = (byte)Convert.ToInt32(asciiFrame.Substring(10, 2), 16),
        DataLength = (ushort)Convert.ToInt32(asciiFrame.Substring(12, 4), 16),
        EndCode = (ushort)Convert.ToInt32(asciiFrame.Substring(16, 4), 16),
        DeviceDataOffset = 20,
        ReceivedAt = DateTime.Now,
        IsError = false
    };

    // デバイスデータ抽出
    result.DeviceData = asciiFrame.Substring(20);

    // ビットデータ変換
    byte[] binaryData = ConvertAsciiHexToBytes((string)result.DeviceData);
    result.BitValues = ParseBinaryBitData(binaryData, 8);

    return result;
}

private StructuredData Parse4EAscii(byte[] rawData)
{
    string asciiFrame = Encoding.ASCII.GetString(rawData);

    var result = new StructuredData
    {
        FrameType = "4E",
        IsBinary = false,
        SubHeader = asciiFrame.Substring(0, 4),
        SerialNumber = (ushort)Convert.ToInt32(asciiFrame.Substring(4, 4), 16),
        NetworkNumber = (byte)Convert.ToInt32(asciiFrame.Substring(12, 2), 16),
        PcNumber = (byte)Convert.ToInt32(asciiFrame.Substring(14, 2), 16),
        IoNumber = (ushort)Convert.ToInt32(asciiFrame.Substring(16, 4), 16),
        StationNumber = (byte)Convert.ToInt32(asciiFrame.Substring(20, 2), 16),
        DataLength = (ushort)Convert.ToInt32(asciiFrame.Substring(22, 4), 16),
        EndCode = (ushort)Convert.ToInt32(asciiFrame.Substring(26, 4), 16),
        DeviceDataOffset = 30,
        ReceivedAt = DateTime.Now,
        IsError = false
    };

    // デバイスデータ抽出
    result.DeviceData = asciiFrame.Substring(30);

    // ワードデータ変換
    result.WordData = ParseAsciiWordData((string)result.DeviceData);

    return result;
}

// データ変換ユーティリティメソッド
private bool[] ParseBinaryBitData(byte[] binaryData, int count)
{
    // BCDデコード実装
    var result = new List<bool>();
    foreach (byte b in binaryData)
    {
        for (int i = 0; i < 8; i++)
        {
            result.Add((b & (1 << i)) != 0);
        }
    }
    return result.Take(count).ToArray();
}

private ushort[] ParseBinaryWordData(byte[] binaryData)
{
    var result = new ushort[binaryData.Length / 2];
    for (int i = 0; i < result.Length; i++)
    {
        result[i] = BitConverter.ToUInt16(binaryData, i * 2);
    }
    return result;
}

private ushort[] ParseAsciiWordData(string asciiData)
{
    var result = new ushort[asciiData.Length / 4];
    for (int i = 0; i < asciiData.Length; i += 4)
    {
        result[i / 4] = Convert.ToUInt16(asciiData.Substring(i, 4), 16);
    }
    return result;
}

private byte[] ConvertAsciiHexToBytes(string asciiHex)
{
    var result = new byte[asciiHex.Length / 2];
    for (int i = 0; i < result.Length; i++)
    {
        result[i] = Convert.ToByte(asciiHex.Substring(i * 2, 2), 16);
    }
    return result;
}
```

**必要なモデル**:

**ProcessedResponseData.cs**:
```csharp
namespace andon.Core.Models
{
    public class ProcessedResponseData
    {
        public byte[] RawData { get; set; }
        public Dictionary<string, object> ProcessedData { get; set; }
        public bool IsDwordCombined { get; set; }
        public DateTime ProcessedAt { get; set; }
        public bool HasError { get; set; }
        public List<string> ErrorMessages { get; set; }
        public int ProcessedDeviceCount { get; set; }
        public int DwordCombinedCount { get; set; }
    }
}
```

**StructuredData.cs**:
```csharp
namespace andon.Core.Models
{
    public class StructuredData
    {
        // 基本構造化データ
        public string FrameType { get; set; }          // "3E" or "4E"
        public bool IsBinary { get; set; }             // true=Binary, false=ASCII
        public object SubHeader { get; set; }          // ushort(Binary) or string(ASCII)
        public byte NetworkNumber { get; set; }
        public byte PcNumber { get; set; }
        public ushort IoNumber { get; set; }
        public byte StationNumber { get; set; }
        public ushort DataLength { get; set; }
        public ushort EndCode { get; set; }
        public DateTime ReceivedAt { get; set; }
        public bool IsError { get; set; }

        // デバイスデータ
        public int DeviceDataOffset { get; set; }
        public int DeviceDataLength { get; set; }
        public object DeviceData { get; set; }         // byte[](Binary) or string(ASCII)

        // 変換済みデータ
        public bool[]? BitValues { get; set; }         // ビットデータの場合
        public ushort[]? WordData { get; set; }        // ワードデータの場合

        // 解析詳細情報
        public string? ErrorMessage { get; set; }
        public TimeSpan ProcessingTime { get; set; }

        // 4Eフレーム専用
        public ushort? SerialNumber { get; set; }      // 4Eフレームのみ

        // DWord結合フラグ
        public bool IsDwordCombined { get; set; }
    }
}
```

**ErrorMessages.cs**:
```csharp
namespace andon.Core.Constants
{
    public static class ErrorMessages
    {
        public const string DwordCombineNotExecuted = "DWord結合処理が未実行です。先にCombineDwordData()を実行してください。";
        public const string UnknownFrameType = "不明なフレームタイプです: 0x{0:X4}";
        public const string IncompleteFrameData = "フレームデータが不完全です。期待バイト数: {0}, 実際: {1}";
        public const string InvalidEndCode = "エラー終了コード: 0x{0:X4} - {1}";
    }
}
```

#### Step 2-2: テスト再実行（Green確認）
```bash
dotnet test --filter "FullyQualifiedName~TC037|TC038|TC039|TC040"
```

期待結果: すべてのテストがパス

---

### Phase 3: Refactor（リファクタリング）

#### Step 3-1: コード品質向上
- ログ出力追加（LoggingManager連携）
  - 解析開始ログ: フレームタイプ、データ長
  - 解析完了ログ: 解析結果サマリ、所要時間
  - エラーログ: 例外詳細、生データダンプ
- エラーハンドリング強化
- ドキュメントコメント追加
- パフォーマンス最適化

#### Step 3-2: テスト再実行（Green維持確認）
```bash
dotnet test --filter "FullyQualifiedName~TC037|TC038|TC039|TC040"
```

期待結果: すべてのテストがパス（リファクタリング後も）

---

## 技術仕様詳細

### オフセット計算まとめ

#### フレームタイプ別のオフセット
- **3E Binary**: ヘッダー11バイト（サブヘッダ2 + フィールド9）
- **3E ASCII**: ヘッダー20文字（サブヘッダ2 + フィールド18）
- **4E Binary**: ヘッダー17バイト（サブヘッダ2 + シリアル・予約4 + フィールド11）
- **4E ASCII**: ヘッダー30文字（サブヘッダ2 + 予約・シリアル10 + フィールド18）

#### データ長の解釈
- **Binary**: 終了コード（2バイト）を含む
- **ASCII**: 終了コード（4文字）を含む
- 実データ長 = データ長フィールド値 - 終了コード長

#### エンディアン処理
- **Binary**: リトルエンディアン（BitConverter.ToUInt16）
- **ASCII**: 16進数文字列（既にビッグエンディアン表示）

---

### 3Eフレーム詳細仕様

#### 3E Binary構造（13バイト）
```
[0-1]  D0 00      サブヘッダ（3E Binary応答）
[2]    00         ネットワーク番号
[3]    FF         PC番号
[4-5]  FF 03      I/O番号（LE: 0x03FF）
[6]    00         局番
[7-8]  04 00      データ長（LE: 4バイト）
[9-10] 00 00      終了コード
[11-12] C8 00     デバイスデータ（2バイト）
```

#### 3E ASCII構造（30文字）
```
[0-1]   "D0"      サブヘッダ（3E ASCII応答）
[2-3]   "00"      ネットワーク番号
[4-5]   "FF"      PC番号
[6-9]   "03FF"    I/O番号
[10-11] "00"      局番
[12-15] "0004"    データ長（4バイト）
[16-19] "0000"    終了コード
[20-]   "C800"    デバイスデータ
```

---

### 4Eフレーム詳細仕様（最重要）

#### 4E Binary構造（113バイト）
```
[0-1]  D4 00      サブヘッダ（4E Binary応答）
[2-3]  00 00      シリアル番号
[4-5]  00 00      予約
[6]    00         ネットワーク番号
[7]    FF         PC番号
[8-9]  FF 03      I/O番号（LE: 0x03FF）
[10]   00         局番
[11-12] 62 00     データ長（LE: 98バイト）
[13-14] 00 00     監視タイマ（応答は0固定）
[15-16] 00 00     終了コード（正常終了）← オフセット15-16が重要！
[17-]  [96バイト] デバイスデータ ← オフセット17が重要！
```

**重要ポイント**:
1. サブヘッダ（2バイト）+ シリアル・予約（4バイト）= 6バイト
2. 終了コードはオフセット15-16（11-12ではない！）
3. デバイスデータはオフセット17から（13ではない！）
4. ヘッダー全体で17バイト

#### 4E ASCII構造
```
[0-1]   "D4"              サブヘッダ（4E ASCII応答）
[2-3]   "00"              予約1
[4-7]   "0000"            シリアル
[8-11]  "0000"            予約2
[12-13] "00"              ネットワーク番号
[14-15] "FF"              PC番号
[16-19] "03FF"            I/O番号
[20-21] "00"              局番
[22-25] "0062"            データ長（98バイト）
[26-29] "0000"            終了コード
[30-]   デバイスデータ（16進数ASCII文字列、192文字）
```

---

### ビットデータ変換（BCDデコード）

#### 入力（Binary）
```
0xC8 = 11001000 (ビッグエンディアン表示)
```

#### 変換処理
```
ビット順序（LSBファースト）:
bit0 = 0 (M100)
bit1 = 0 (M101)
bit2 = 0 (M102)
bit3 = 1 (M103)
bit4 = 0 (M104)
bit5 = 0 (M105)
bit6 = 1 (M106)
bit7 = 1 (M107)
```

#### 出力
```csharp
bool[] { false, false, false, true, false, false, true, true }
```

---

### ワードデータ変換（リトルエンディアン）

#### 入力（Binary）
```
[0x07, 0x19] (2バイト)
```

#### 変換処理
```csharp
ushort value = BitConverter.ToUInt16(bytes, offset);
// value = 0x1907 = 6407
```

#### 特徴的な値（TC038検証ポイント）
```
Word 8:  0x1907 (6407)
Word 23: 0x0020 (32)
Word 24: 0x0010 (16)
Word 25: 0x0008 (8)
Word 26: 0x0002 (2)
```

---

## エラーハンドリング

### ParseRawToStructuredData スロー例外

**InvalidOperationException**:
- DWord結合未実行

**ArgumentException**:
- 不正フレームタイプ
- 不完全フレーム

**FormatException**:
- データ形式エラー

### エラーメッセージ統一
**ファイル**: Core/Constants/ErrorMessages.cs

```csharp
public static class ErrorMessages
{
    public const string DwordCombineNotExecuted = "DWord結合処理が未実行です。先にCombineDwordData()を実行してください。";
    public const string UnknownFrameType = "不明なフレームタイプです: 0x{0:X4}";
    public const string IncompleteFrameData = "フレームデータが不完全です。期待バイト数: {0}, 実際: {1}";
    public const string InvalidEndCode = "エラー終了コード: 0x{0:X4} - {1}";
}
```

---

## 実装記録・ドキュメント作成要件

### 必須作業項目

#### 1. 進捗記録開始
**ファイル**: `documents/implementation_records/progress_notes/2025-11-13_TC037-040実装.md`
- 実装開始時刻
- 目標（TC037-040テスト実装完了）
- 実装方針

#### 2. 実装記録作成
**ファイル**: `documents/implementation_records/method_records/ParseRawToStructuredData実装記録.md`
- 実装判断根拠
  - なぜこの実装方法を選択したか
  - 検討した他の方法との比較
  - 技術選択の根拠とトレードオフ
- 発生した問題と解決過程
- 4Eフレームのオフセット計算の検証結果

#### 3. テスト結果保存
**ファイル**: `documents/implementation_records/execution_logs/TC037-040_テスト結果.log`
- 単体テスト結果（成功/失敗、実行時間）
- Red-Green-Refactorの各フェーズ結果
- エラーログとデバッグ情報
- 4Eフレーム実機データ検証結果

---

## 完了条件

以下すべてが満たされた時点で実装完了とする：

- [ ] TC037_3E_Binary テストがパス
- [ ] TC037_3E_ASCII テストがパス
- [ ] TC038_4E_Binary_実機データ テストがパス（最重要）
- [ ] TC038_4E_ASCII テストがパス
- [ ] TC039_DWord結合済み テストがパス
- [ ] TC040_DWord結合未実行_例外 テストがパス
- [ ] TC040_不正フレームタイプ_例外 テストがパス
- [ ] TC040_不完全フレーム_例外 テストがパス
- [ ] ParseRawToStructuredData本体実装完了
- [ ] 4Eフレームのオフセット計算が正確（終了コード15-16、デバイスデータ17-）
- [ ] リファクタリング完了（ログ出力、エラーハンドリング等）
- [ ] テスト再実行でGreen維持確認
- [ ] 進捗記録作成完了
- [ ] 実装記録作成完了
- [ ] `C:\Users\1010821\Desktop\python\andon\documents\design\チェックリスト\step3to6_test実施リスト.md`の該当項目にチェック

---

## 実装時の注意点

### TDD手法厳守
- 必ずテストを先に書く（Red）
- 最小実装でテストをパスさせる（Green）
- リファクタリングで品質向上（Refactor）
- 各フェーズでテスト実行を確認

### 4Eフレーム実装の最重要ポイント
- シリアル・予約フィールド（4バイト）が存在する
- 終了コードはオフセット15-16（11-12ではない！）
- デバイスデータはオフセット17から（13ではない！）
- 実機データで検証する

### 記録の重要性
- 実装判断の根拠を詳細に記録
- テスト結果は数値データも含めて保存
- 4Eフレームのオフセット計算の検証過程を記録

### 文字化け対策
- 日本語ファイル名の新規作成時は`.txt`経由で作成
- 作成後は必ずReadツールで確認
- 文字化け発見時は早期に対処

---

## 参考情報

### 設計書参照先
- `documents/design/クラス設計.md`
- `documents/design/テスト内容/02_PlcCommunicationManager_tests_part2.md`
- `documents/design/エラーハンドリング.md`
- `documents/design/情報まとめ(プロンプト作成用)/02_PlcCommunicationManager_tests_part2/step6_TC037-040.md`

### 開発手法
- `documents/development_methodology/development-methodology.md`

### PySLMPClient実装参照
- `PySLMPClient/pyslmpclient/const.py`（デバイスコード定義）
- `PySLMPClient/pyslmpclient/util.py`（フレーム作成ロジック）
- `PySLMPClient/tests/test_main.py`（テストケース実例）

---

以上の指示に従って、TC037-TC040 ParseRawToStructuredDataテストの実装を開始してください。

不明点や不足情報があれば、実装前に質問してください。
