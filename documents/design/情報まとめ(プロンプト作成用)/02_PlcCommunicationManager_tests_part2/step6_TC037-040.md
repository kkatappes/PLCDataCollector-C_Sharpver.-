# Step6 ParseRawToStructuredData テスト実装用情報（TC037-TC040）

## ドキュメント概要

### 目的
このドキュメントは、TC037-TC040（ParseRawToStructuredDataメソッドのテスト）の実装に必要な情報を集約したものです。
**コード作成時に必要となる技術情報のみ**を記載しており、学習資料や説明的な内容は含みません。

### 情報取得元
本ドキュメントの情報は以下のソースから抽出・統合されています：

#### 設計書（andon/documents/design/）
- `クラス・メソッドリスト.md` - クラス・メソッドの一覧と概要
- `クラス設計.md` - 詳細なクラス設計仕様
- `テスト内容/02_PlcCommunicationManager_tests_part2.md` - テストケース仕様（TC037-TC040）
- `プロジェクト構造設計.md` - フォルダ構造・プロジェクト構成
- `依存関係.md` - クラス間の依存関係

---

## 1. テスト対象メソッド仕様

### ParseRawToStructuredData（Step6-3: 構造化データ変換）
**クラス**: PlcCommunicationManager
**名前空間**: andon.Core.Managers

#### Input
- ProcessedResponseData（DWord結合済み処理データ）
  - 基本結果: 元生データ、処理済みデータ（DWord結合済み）、DWord結合フラグ、処理時刻
  - エラー情報: エラーフラグ、エラー・警告メッセージリスト
  - 統計情報: 処理デバイス数、DWord結合数

#### Output
- StructuredData（SLMP構造化解析結果オブジェクト）
  - 基本構造化データ: SLMPヘッダー（全標準情報）、終了コード、デバイスデータ、受信時刻、エラーフラグ
  - 解析詳細情報: 解析手順記録、解釈情報、処理時間、デバイス解釈、ステータス判定
  - エラー詳細情報: 詳細エラーコード、エラー説明、影響デバイス（エラー時のみ）

#### 機能
- フレームタイプ判定（3E/4E、Binary/ASCII）
- SLMPヘッダー詳細解析
- 終了コード解釈
- デバイスデータ構造化
- デバイス解釈情報追加
- ステータス判定

#### データ取得元
- ProcessedResponseData（CombineDwordData()の出力）

---

## 2. テストケース仕様（TC037-TC040）

### TC037_ParseRawToStructuredData_3Eフレーム解析（Binary/ASCII）
**目的**: 3Eフレーム（Binary/ASCII）の構造化データ変換機能をテスト

#### 3E Binary詳細仕様

**入力フレーム（13バイト）:**
```
D0 00 00 FF FF 03 00 04 00 00 00 C8 00
```

**フレーム構造:**
```
[0-1]  D0 00      サブヘッダ（3E Binary応答）
[2]    00         ネットワーク番号
[3]    FF         PC番号
[4-5]  FF 03      I/O番号（LE: 0x03FF）
[6]    00         局番
[7-8]  04 00      データ長（LE: 4バイト）
[9-10] 00 00      終了コード
[11-12] C8 00     デバイスデータ（2バイト）
```

**解析処理の流れ:**
1. フレームタイプ判定: frame[0] == 0xD0 && frame[1] == 0x00 → 3E Binary
2. ヘッダー解析（オフセット2-10、9バイト）:
   - NetworkNumber = frame[2] = 0x00
   - PcNumber = frame[3] = 0xFF
   - IoNumber = BitConverter.ToUInt16(frame, 4) = 0x03FF
   - StationNumber = frame[6] = 0x00
   - DataLength = BitConverter.ToUInt16(frame, 7) = 0x0004
   - EndCode = BitConverter.ToUInt16(frame, 9) = 0x0000
3. デバイスデータ抽出（オフセット11-、2バイト）:
   - DeviceDataOffset = 11
   - DeviceDataLength = DataLength - 2 = 2
   - DeviceData = frame[11..13] = [0xC8, 0x00]
4. ビットデータ変換（BCD形式）:
   - 0xC8 → BCDデコード → [0, 0, 0, 1, 0, 0, 1, 1]
   - M100=0, M101=0, M102=0, M103=1, M104=0, M105=0, M106=1, M107=1

**期待出力（Binary）:**
```csharp
{
  "FrameType": "3E",
  "IsBinary": true,
  "SubHeader": 0xD000,
  "NetworkNumber": 0x00,
  "PcNumber": 0xFF,
  "IoNumber": 0x03FF,
  "StationNumber": 0x00,
  "DataLength": 4,
  "EndCode": 0x0000,
  "DeviceDataOffset": 11,
  "DeviceDataLength": 2,
  "DeviceData": [0xC8, 0x00],
  "BitValues": [0, 0, 0, 1, 0, 0, 1, 1]  // M100-M107
}
```

**検証項目（Binary）:**
- 3Eフレーム構造の正確な解析（11バイトヘッダー）
- シーケンス番号・予約フィールドが存在しない
- デバイスデータ開始位置の正確性（オフセット11）
- ビットデータのBCDデコード（0xC8 → [0,0,0,1,0,0,1,1]）

#### 3E ASCII詳細仕様

**入力フレーム（文字列）:**
```
"D00000FF03FF000004000000C800"
```

**フレーム構造:**
```
[0-1]   "D0"      サブヘッダ（3E ASCII応答）
[2-3]   "00"      ネットワーク番号
[4-5]   "FF"      PC番号
[6-9]   "03FF"    I/O番号
[10-11] "00"      局番
[12-15] "0004"    データ長（4バイト）
[16-19] "0000"    終了コード
[20-]   "C800"    デバイスデータ
```

**解析処理の流れ:**
1. フレームタイプ判定: frame.Substring(0, 2) == "D0" → 3E ASCII
2. ヘッダー解析（文字2-19、18文字）:
   - NetworkNumber = Convert.ToInt32(frame.Substring(2, 2), 16) = 0x00
   - PcNumber = Convert.ToInt32(frame.Substring(4, 2), 16) = 0xFF
   - IoNumber = Convert.ToInt32(frame.Substring(6, 4), 16) = 0x03FF
   - StationNumber = Convert.ToInt32(frame.Substring(10, 2), 16) = 0x00
   - DataLength = Convert.ToInt32(frame.Substring(12, 4), 16) = 4
   - EndCode = Convert.ToInt32(frame.Substring(16, 4), 16) = 0x0000
3. デバイスデータ抽出（文字20-、4文字）:
   - DeviceDataOffset = 20
   - DeviceData = frame.Substring(20) = "C800"
4. ビットデータ変換（16進数ASCII → バイナリ）:
   - "C800" → [0xC8, 0x00] → BCDデコード → [0, 0, 0, 1, 0, 0, 1, 1]

**期待出力（ASCII）:**
```csharp
{
  "FrameType": "3E",
  "IsBinary": false,
  "SubHeader": "D000",
  "NetworkNumber": 0x00,
  "PcNumber": 0xFF,
  "IoNumber": 0x03FF,
  "StationNumber": 0x00,
  "DataLength": 4,
  "EndCode": 0x0000,
  "DeviceDataOffset": 20,
  "DeviceData": "C800",
  "BitValues": [0, 0, 0, 1, 0, 0, 1, 1]
}
```

---

### TC038_ParseRawToStructuredData_4Eフレーム解析（Binary/ASCII）
**目的**: 4Eフレーム（Binary/ASCII）の構造化データ変換機能をテスト

#### 4E Binary詳細仕様（実機データ使用）

**実例入力フレーム（113バイト）:**
```
D4 00 00 00 00 00 00 FF FF 03 00 62 00 00 00 00 00
FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
07 19 FF FF FF FF FF FF FF FF FF FF FF FF FF FF
FF FF 00 10 00 08 00 01 00 10 00 10 00 08 20 00
10 00 08 00 02 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```

**フレーム構造:**
```
[0-1]  D4 00      サブヘッダ（4E Binary応答）
[2-3]  00 00      シリアル番号
[4-5]  00 00      予約
[6]    00         ネットワーク番号
[7]    FF         PC番号
[8-9]  FF 03      I/O番号（LE: 0x03FF）
[10]   00         局番
[11-12] 62 00     データ長（LE: 98バイト）
[13-14] 00 00     終了コード（正常終了）
[15-]  [96バイト] デバイスデータ
```

**解析処理の流れ:**
1. フレームタイプ判定: frame[0] == 0xD4 && frame[1] == 0x00 → 4E Binary
2. シリアル・予約フィールド処理（オフセット2-5、4バイト）:
   - SerialNumber = BitConverter.ToUInt16(frame, 2) = 0x0000
   - Reserved = BitConverter.ToUInt16(frame, 4) = 0x0000
3. ヘッダー解析（オフセット6-14、9バイト）:
   - NetworkNumber = frame[6] = 0x00
   - PcNumber = frame[7] = 0xFF
   - IoNumber = BitConverter.ToUInt16(frame, 8) = 0x03FF
   - StationNumber = frame[10] = 0x00
   - DataLength = BitConverter.ToUInt16(frame, 11) = 98
   - EndCode = BitConverter.ToUInt16(frame, 13) = 0x0000 ※オフセット13-14が重要
4. デバイスデータ抽出（オフセット15-、96バイト）:
   - DeviceDataOffset = 15
   - DeviceDataLength = DataLength - 2 = 96
   - DeviceData = frame[15..111]
5. ワードデータ変換（リトルエンディアン）:
   - ワード数 = 96 / 2 = 48
   - WordData[8] = BitConverter.ToUInt16(DeviceData, 16) = 0x1907 (6407)
   - WordData[23] = 0x0020 (32)
   - WordData[24] = 0x0010 (16)
   - WordData[25] = 0x0008 (8)
   - WordData[26] = 0x0002 (2)

**期待出力（Binary）:**
```csharp
{
  "FrameType": "4E",
  "IsBinary": true,
  "SubHeader": 0xD400,
  "SerialNumber": 0x0000,
  "NetworkNumber": 0x00,
  "PcNumber": 0xFF,
  "IoNumber": 0x03FF,
  "StationNumber": 0x00,
  "DataLength": 98,
  "EndCode": 0x0000,
  "DeviceDataOffset": 15,
  "DeviceDataLength": 96,
  "DeviceData": [96バイトのバイト配列],
  "WordData": [
    0xFFFF, 0xFFFF, ... (8ワード),
    0x1907,  // Word 8: 6407
    0xFFFF, ... (7ワード),
    0xFFFF, 0x1000, 0x0800, 0x0100, 0x1000, 0x1000, 0x0800,
    0x0020,  // Word 23: 32
    0x0010,  // Word 24: 16
    0x0008,  // Word 25: 8
    0x0002,  // Word 26: 2
    0x0000, ... (21ワード)
  ]
}
```

**検証項目（Binary、最重要）:**
- ✓ サブヘッダが `D4 00` （4E応答フレーム）
- ✓ シリアルフィールド（2バイト）と予約フィールド（2バイト）が存在
- ✓ ヘッダー長が15バイト（サブヘッダ2 + シリアル・予約4 + ネットワーク～データ長5 + 終了コード2 + デバイスデータ開始2）
- ✓ **終了コード抽出位置がオフセット13-14（11-12ではない！）**
- ✓ デバイスデータ開始位置がオフセット15（13や17ではない！）
- ✓ データ長フィールド = 98バイト（0x62）
- ✓ 実際のデータ長 = 終了コード（2バイト） + デバイスデータ（96バイト） = 98バイト
- ✓ リトルエンディアン変換が正しい
- ✓ 特徴的な値の検出: Word 8=6407, Word 23=32, Word 24=16, Word 25=8, Word 26=2

**不合格条件（即座に調査が必要）:**
- ❌ 終了コード抽出位置が誤っている（オフセット11-12や15-16を使用している）
- ❌ デバイスデータ開始位置が誤っている（オフセット13や17を使用している）
- ❌ シリアル・予約フィールドが考慮されていない
- ❌ 監視タイマフィールドが存在すると誤認している（応答フレームには監視タイマなし）
- ❌ ワード値がリトルエンディアンで正しく変換されていない
- ❌ 特徴的な値が抽出できていない

#### 4E ASCII詳細仕様

**想定入力フレーム:**
```
"D40000000000FFFF03000062000000FFFF..."
```

**フレーム構造:**
```
[0-1]   "D4"              サブヘッダ（4E ASCII応答）
[2-3]   "00"              予約1
[4-7]   "0000"            シリアル
[8-11]  "0000"            予約2
[12-13] "00"              ネットワーク番号
[14-15] "FF"              PC番号
[16-19] "03FF"            I/O番号
[20-21] "00"              局番
[22-25] "0062"            データ長（98バイト）
[26-29] "0000"            終了コード
[30-]   デバイスデータ（16進数ASCII文字列、192文字）
```

**解析処理の流れ:**
1. フレームタイプ判定: frame.Substring(0, 2) == "D4" → 4E ASCII
2. シリアル・予約フィールド処理（文字2-11、10文字）:
   - Reserved1 = frame.Substring(2, 2) = "00"
   - SerialNumber = Convert.ToInt32(frame.Substring(4, 4), 16) = 0x0000
   - Reserved2 = frame.Substring(8, 4) = "0000"
3. ヘッダー解析（文字12-29、18文字）:
   - NetworkNumber = Convert.ToInt32(frame.Substring(12, 2), 16) = 0x00
   - PcNumber = Convert.ToInt32(frame.Substring(14, 2), 16) = 0xFF
   - IoNumber = Convert.ToInt32(frame.Substring(16, 4), 16) = 0x03FF
   - StationNumber = Convert.ToInt32(frame.Substring(20, 2), 16) = 0x00
   - DataLength = Convert.ToInt32(frame.Substring(22, 4), 16) = 98
   - EndCode = Convert.ToInt32(frame.Substring(26, 4), 16) = 0x0000
4. デバイスデータ抽出（文字30-、192文字）:
   - DeviceDataOffset = 30
   - DeviceDataLength = (DataLength - 4) * 2 = 188（ただし実際は192）
   - DeviceData = frame.Substring(30)
5. ワードデータ変換（ASCII16進数 → ushort）:
   - 4文字ずつ処理: "FFFF" → 0xFFFF
   - "1907" → 0x1907

**期待出力（ASCII）:**
```csharp
{
  "FrameType": "4E",
  "IsBinary": false,
  "SubHeader": "D400",
  "SerialNumber": 0x0000,
  "NetworkNumber": 0x00,
  "PcNumber": 0xFF,
  "IoNumber": 0x03FF,
  "StationNumber": 0x00,
  "DataLength": 98,
  "EndCode": 0x0000,
  "DeviceDataOffset": 30,
  "DeviceDataLength": 192,
  "DeviceData": "FFFF...1907FFFF...",
  "WordData": [48ワードの値配列]
}
```

---

### TC039_ParseRawToStructuredData_DWord結合済みデータ解析
**目的**: DWord結合済みデータの構造化変換機能をテスト

#### 入力データ
- ProcessedResponseData（DWord結合済み、IsDwordCombined=true）
  - DWord結合済みデバイス情報を含む
  - 32bit値が正しく格納されている

#### 期待出力
- StructuredData
  - DWord結合されたデバイス情報を含む構造化データ
  - 32bit値が正しく解釈されている
  - IsDwordCombined=trueフラグが保持される

#### 検証項目
- DWord結合フラグが正しく保持される
- 32bit値が正しく解釈される
- デバイス名とDWord値のマッピングが正確

---

### TC040_ParseRawToStructuredData_異常系全般
**目的**: 各種異常系シナリオのエラー検出機能をテスト

#### TC040-1: DWord結合未実行
**入力**: 未処理のProcessedResponseData（CombineDwordData未実行）
**期待出力**: InvalidOperationException
**エラーメッセージ**: "DWord結合処理が未実行です。先にCombineDwordData()を実行してください。"

#### TC040-2: 不正フレームタイプ
**目的**: 不正なフレームタイプの検出
**入力**: サブヘッダが `0xAA00` など不正な値
**期待出力**: `ArgumentException("Unknown frame type")`
**エラーメッセージ**: "不明なフレームタイプです: 0xAA00"

#### TC040-3: 不完全フレーム
**目的**: 不完全フレームの検出
**入力**: 4Eフレームだがデータが10バイトしかない
**期待出力**: `ArgumentException("Incomplete frame data")`
**エラーメッセージ**: "フレームデータが不完全です。期待バイト数: 17, 実際: 10"

---

### TC041_ParseRawToStructuredData_エラー終了コード
**目的**: エラー終了コードの検出
**入力**: 終了コードが `0xC059` (不正コマンド)
**期待出力**:
```csharp
{
  "EndCode": 0xC059,
  "IsError": true,
  "ErrorMessage": "Invalid command",
  "DeviceData": null
}
```

#### 主要な終了コード一覧
- `0x0000`: 正常終了
- `0xC059`: 不正コマンド
- `0xC05C`: 範囲外アクセス
- `0xC061`: 書き込み不可デバイス

---

## 3. オフセット計算まとめ

### フレームタイプ別のオフセット
- **3E Binary**: ヘッダー11バイト（サブヘッダ2 + フィールド9）、デバイスデータ開始オフセット11
- **3E ASCII**: ヘッダー20文字（サブヘッダ2 + フィールド18）、デバイスデータ開始オフセット20
- **4E Binary**: ヘッダー15バイト（サブヘッダ2 + シリアル・予約4 + フィールド9）、デバイスデータ開始オフセット15
- **4E ASCII**: ヘッダー30文字（サブヘッダ2 + 予約・シリアル10 + フィールド18）、デバイスデータ開始オフセット30

### 重要: 4Eフレームの応答には監視タイマフィールドが存在しない
- 要求フレーム: 監視タイマあり（データ長の後）
- 応答フレーム: 監視タイマなし、データ長の直後が終了コード

### データ長の解釈
- **Binary**: 終了コード（2バイト）を含む
- **ASCII**: 終了コード（4文字）を含む
- 実データ長 = データ長フィールド値 - 終了コード長

### エンディアン処理
- **Binary**: リトルエンディアン（BitConverter.ToUInt16）
- **ASCII**: 16進数文字列（既にビッグエンディアン表示）

---

## 4. データ変換ユーティリティメソッド

### ParseBinaryBitData
```csharp
public static bool[] ParseBinaryBitData(byte[] binaryData, int count)
{
    // BCDデコード: [0x12] → [1, 2]
    var decoded = DecodeBcd(binaryData);
    var result = decoded.Select(b => b == 1).ToArray();

    // 奇数個の場合、最後の余分なビットを削除
    if (count % 2 == 1 && result.Length > count)
    {
        return result.Take(count).ToArray();
    }

    return result;
}
```

### ParseBinaryWordData
```csharp
public static ushort[] ParseBinaryWordData(byte[] binaryData)
{
    var result = new ushort[binaryData.Length / 2];
    Buffer.BlockCopy(binaryData, 0, result, 0, binaryData.Length);
    return result;
}
```

### ParseAsciiWordData
```csharp
public static ushort[] ParseAsciiWordData(string asciiData)
{
    var result = new ushort[asciiData.Length / 4];
    for (int i = 0; i < asciiData.Length; i += 4)
    {
        result[i / 4] = Convert.ToUInt16(asciiData.Substring(i, 4), 16);
    }
    return result;
}
```

---

## 5. 依存クラス・モデル

### ProcessedResponseData（入力モデル）
```csharp
public class ProcessedResponseData
{
    public byte[] RawData { get; set; }                       // 元生データ
    public Dictionary<string, object> ProcessedData { get; set; } // DWord結合済みデータ
    public bool IsDwordCombined { get; set; }                 // DWord結合フラグ
    public DateTime ProcessedAt { get; set; }                  // 処理時刻
    public bool HasError { get; set; }                         // エラーフラグ
    public List<string> ErrorMessages { get; set; }            // エラー・警告メッセージ
    public int ProcessedDeviceCount { get; set; }              // 処理デバイス数
    public int DwordCombinedCount { get; set; }                // DWord結合数
}
```

### StructuredData（出力モデル）
```csharp
public class StructuredData
{
    // 基本構造化データ
    public string FrameType { get; set; }               // "3E" or "4E"
    public bool IsBinary { get; set; }                  // true=Binary, false=ASCII
    public object SubHeader { get; set; }               // ushort(Binary) or string(ASCII)
    public byte NetworkNumber { get; set; }
    public byte PcNumber { get; set; }
    public ushort IoNumber { get; set; }
    public byte StationNumber { get; set; }
    public ushort DataLength { get; set; }
    public ushort EndCode { get; set; }
    public DateTime ReceivedAt { get; set; }
    public bool IsError { get; set; }

    // デバイスデータ
    public int DeviceDataOffset { get; set; }
    public int DeviceDataLength { get; set; }
    public object DeviceData { get; set; }              // byte[](Binary) or string(ASCII)

    // 変換済みデータ
    public bool[]? BitValues { get; set; }              // ビットデータの場合
    public ushort[]? WordData { get; set; }             // ワードデータの場合

    // 解析詳細情報
    public string? ErrorMessage { get; set; }
    public TimeSpan ProcessingTime { get; set; }

    // 4Eフレーム専用
    public ushort? SerialNumber { get; set; }           // 4Eフレームのみ
}
```

---

## 6. テスト実装方針（TDD）

### 開発手法
- C:\Users\1010821\Desktop\python\andon\documents\development_methodology\development-methodology.mdに記載のTDD手法を使用

### テストファイル配置
- **ファイル名**: PlcCommunicationManagerTests_ParseRawToStructuredData.cs
- **配置先**: Tests/Unit/Core/Managers/
- **名前空間**: andon.Tests.Unit.Core.Managers

### テスト実装順序
1. **TC037_3E_Binary**（最優先）
   - 3E Binaryフレーム解析テスト
   - ビットデータ変換テスト
2. **TC037_3E_ASCII**
   - 3E ASCIIフレーム解析テスト
3. **TC038_4E_Binary**（重要）
   - 4E Binaryフレーム解析テスト（実機データ使用）
   - ワードデータ変換テスト
4. **TC038_4E_ASCII**
   - 4E ASCIIフレーム解析テスト
5. **TC039_DWord結合済み**
   - DWord結合データの解析テスト
6. **TC040_異常系全般**
   - DWord結合未実行
   - 不正フレームタイプ
   - 不完全フレーム
7. **TC041_エラー終了コード**
   - エラー終了コードの検出テスト

---

## 7. テストケース実装構造

### Arrange（準備）
1. ProcessedResponseDataの準備
   - RawData（生データ）
   - IsDwordCombined = true（TC039以外はfalseも可）
   - ProcessedData（必要に応じてDWord結合済みデータ）
2. 期待値の準備
   - 期待されるStructuredDataオブジェクト
   - 各フィールドの期待値
3. PlcCommunicationManagerインスタンス作成

### Act（実行）
1. ParseRawToStructuredData実行
   - ProcessedResponseDataを入力
   - StructuredDataを取得

### Assert（検証）
1. フレームタイプ検証
   - FrameType, IsBinaryが正しい
2. ヘッダー情報検証
   - NetworkNumber, PcNumber, IoNumber等が正しい
3. 終了コード検証
   - EndCodeが正しい
   - IsErrorフラグが正しい
4. デバイスデータ検証
   - DeviceDataOffset, DeviceDataLengthが正しい
   - DeviceDataが正しく抽出される
5. 変換済みデータ検証
   - BitValues/WordDataが正しく変換される
6. 異常系検証
   - 適切な例外がスローされる
   - エラーメッセージが正確

---

## 8. エラーハンドリング

### ParseRawToStructuredData スロー例外
- **InvalidOperationException**: DWord結合未実行
- **ArgumentException**: 不正フレームタイプ、不完全フレーム
- **FormatException**: データ形式エラー

### エラーメッセージ統一
**ファイル**: Core/Constants/ErrorMessages.cs

```csharp
public static class ErrorMessages
{
    public const string DwordCombineNotExecuted = "DWord結合処理が未実行です。先にCombineDwordData()を実行してください。";
    public const string UnknownFrameType = "不明なフレームタイプです: {0}";
    public const string IncompleteFrameData = "フレームデータが不完全です。期待バイト数: {0}, 実際: {1}";
    public const string InvalidEndCode = "エラー終了コード: 0x{0:X4} - {1}";
}
```

---

## 9. ログ出力要件

### LoggingManager連携
- 解析開始ログ: フレームタイプ、データ長
- 解析完了ログ: 解析結果サマリ、所要時間
- エラーログ: 例外詳細、生データダンプ

### ログレベル
- **Information**: 解析開始・完了
- **Warning**: エラー終了コード検出時
- **Error**: 例外発生時

---

## 10. テスト実装チェックリスト

### TC037-TC040実装前
- [ ] PlcCommunicationManagerクラスにParseRawToStructuredDataメソッド追加
- [ ] ProcessedResponseData・StructuredDataモデル作成
- [ ] データ変換ユーティリティメソッド作成
- [ ] テストデータ準備（3E/4E Binary/ASCII）

### TC037-TC040実装中
- [ ] Arrange: テストデータ準備
- [ ] Act: ParseRawToStructuredData呼び出し
- [ ] Assert: 解析結果検証
- [ ] TC037: 3E Binary/ASCII実装
- [ ] TC038: 4E Binary/ASCII実装（実機データ使用）
- [ ] TC039: DWord結合済みデータ実装
- [ ] TC040: 異常系全般実装

### TC037-TC040実装後
- [ ] テスト実行・Red確認
- [ ] ParseRawToStructuredData本体実装
- [ ] テスト実行・Green確認
- [ ] リファクタリング実施

---

## 11. パフォーマンステスト

### TC042_Parse_LargeFrame_Performance（大量データ処理）
**目的**: 大量データフレームの処理性能
**入力**: 1000ワード（2000バイト）のデバイスデータを含むフレーム
**期待出力**: パース処理時間 < 10ms

---

## 12. 重要な統合テストケース

### TC143_10 Step3-6 M100～M107ビット読み出し2パターン統合テスト（オフライン）
**目的**: 実際のPLC機器無しで、M100～M107ビット読み出しの2パターン（3E/4E × バイナリ）について、Step3-6の完全な通信フローが正しく動作することを検証

#### 想定するPLC設備状態
```
M100: OFF (0)
M101: OFF (0)
M102: OFF (0)
M103: ON  (1)
M104: OFF (0)
M105: OFF (0)
M106: ON  (1)
M107: ON  (1)

ビット配列: 0 0 0 1 0 0 1 1
16進数: 0xC8 (1バイト目), 0x00 (2バイト目、未使用ビット)
```

#### Step6（データ解析）の成功条件
- 終了コードが正常（`0x0000`）
- StructuredData.IsError == `false`
- ビット値が期待通り（M100～M107の各値が正確）
- RawDataHex == `"C8 00"`

---

### TC143_11 4Eフレーム ランダム読み出し（複数デバイス）実機データ解析テスト
**目的**: 実機PLCから受信した4Eフレーム（ランダム読み出し応答）の構造解析とデータ抽出が正しく動作することを検証

#### 成功条件（テスト合格基準）

1. **ヘッダー解析成功:**
   - サブヘッダ判定: `4Eフレーム` として認識
   - 終了コード抽出: オフセット15-16から `0x0000` を正しく取得
   - データ長検証: 98バイトを正しく認識

2. **デバイスデータ抽出成功:**
   - デバイスデータ開始位置: オフセット17から正しく抽出
   - デバイスデータ長: 96バイトを正しく取得

3. **ワード値変換成功:**
   - リトルエンディアン変換が全ワードで正しい
   - 特徴的な値（6407, 32, 16, 8, 2）が正確に抽出される

4. **エラーハンドリング:**
   - フレーム長不足時に適切なエラー検出
   - 不正なサブヘッダ時に適切なエラー検出

---

以上が TC037-TC040（ParseRawToStructuredData）テスト実装に必要な情報です。
