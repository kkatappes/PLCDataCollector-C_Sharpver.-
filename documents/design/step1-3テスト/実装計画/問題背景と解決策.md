# Step1-3テスト: 問題背景と解決策

## 問題の詳細

### 型の不一致により、現在の実装では動作しません

```
ConfigurationLoaderExcel → PlcConfiguration (List<DeviceSpecification>)
                                ↓ ❌ 型不一致
ConfigToFrameManager.BuildReadRandomFrameFromConfig(TargetDeviceConfig) (List<DeviceEntry>)
```

### 原因

実装が段階的に進められた結果、2つの設計パスが存在:

1. **JSONベースの設計**（古い）
   - ConfigurationLoader → TargetDeviceConfig → DeviceEntry
   - appsettings.json を使用

2. **Excelベースの設計**（新しい）
   - ConfigurationLoaderExcel → PlcConfiguration → DeviceSpecification
   - *.xlsx ファイルを使用

**問題**: 現在の`ConfigToFrameManager`は古いJSONベースの設計を前提としており、新しいExcelベースの設計には対応していない。

---

## 解決策: オーバーロードメソッドの追加

### Binary形式オーバーロード

```csharp
/// <summary>
/// PlcConfigurationからReadRandomフレームを構築（Excel読み込み用）
/// </summary>
public byte[] BuildReadRandomFrameFromConfig(PlcConfiguration config)
{
    if (config == null)
        throw new ArgumentNullException(nameof(config));

    if (config.Devices == null || config.Devices.Count == 0)
        throw new ArgumentException("デバイスリストが空です", nameof(config));

    // PlcConfiguration.Devices は既に DeviceSpecification型のリスト
    // そのままSlmpFrameBuilderに渡せる
    byte[] frame = SlmpFrameBuilder.BuildReadRandomRequest(
        config.Devices,
        frameType: "4E",  // 固定値
        timeout: 32       // 固定値
    );

    return frame;
}
```

### ASCII形式オーバーロード

```csharp
/// <summary>
/// PlcConfigurationからReadRandomフレームを構築（ASCII形式、Excel読み込み用）
/// </summary>
public string BuildReadRandomFrameFromConfigAscii(PlcConfiguration config)
{
    if (config == null)
        throw new ArgumentNullException(nameof(config));

    if (config.Devices == null || config.Devices.Count == 0)
        throw new ArgumentException("デバイスリストが空です", nameof(config));

    string asciiFrame = SlmpFrameBuilder.BuildReadRandomRequestAscii(
        config.Devices,
        frameType: "4E",
        timeout: 32
    );

    return asciiFrame;
}
```

---

## 修正後の動作フロー

### Before（❌ 動作しない）
```csharp
var loader = new ConfigurationLoaderExcel();
var plcConfig = loader.LoadAllPlcConnectionConfigs()[0]; // PlcConfiguration型

var frameManager = new ConfigToFrameManager();
var frame = frameManager.BuildReadRandomFrameFromConfig(plcConfig);
// ❌ エラー: TargetDeviceConfig型を期待しているがPlcConfiguration型を渡している
```

### After（✅ 正常に動作）
```csharp
var loader = new ConfigurationLoaderExcel();
var plcConfig = loader.LoadAllPlcConnectionConfigs()[0]; // PlcConfiguration型

var frameManager = new ConfigToFrameManager();
var frame = frameManager.BuildReadRandomFrameFromConfig(plcConfig);
// ✅ 成功: PlcConfiguration用のオーバーロードメソッドが呼ばれる
```

---

## テストコードへの影響

### TC_Step3_04 統合テスト 修正例

```csharp
// Step1: 設定読み込み（Excel）
var configLoader = new ConfigurationLoaderExcel();
var plcConfig = configLoader.LoadAllPlcConnectionConfigs()[0]; // PlcConfiguration

// Step2: フレーム構築（オーバーロード版を使用）
var frameManager = new ConfigToFrameManager();
var frameBytes = frameManager.BuildReadRandomFrameFromConfig(plcConfig); // ✅ 修正版

// Step3: 送信準備
// （PlcCommunicationManagerは接続情報のみ必要）
var connectionConfig = new ConnectionConfig
{
    IpAddress = plcConfig.IpAddress,
    Port = plcConfig.Port,
    UseTcp = false,  // UDP固定
    IsBinary = true,
    FrameVersion = FrameVersion.Frame4E
};

var mockSocket = new MockSocket(useTcp: false);
mockSocket.SetupConnected(true);
var socketFactory = new MockSocketFactory(mockSocket);

var plcManager = new PlcCommunicationManager(
    connectionConfig,
    timeoutConfig,
    socketFactory: socketFactory
);

// 実行
var connectResponse = await plcManager.ConnectAsync();
Assert.Equal(ConnectionStatus.Connected, connectResponse.Status);

await plcManager.SendFrameAsync(frameBytes);

var stats = plcManager.GetConnectionStats();
Assert.Equal(1, stats.TotalFramesSent);
Assert.Equal(frameBytes.Length, stats.TotalBytesSent);
```

---

## 実装対象ファイル

### 変更が必要なファイル
- **ConfigToFrameManager.cs**: オーバーロードメソッド追加
  - `BuildReadRandomFrameFromConfig(PlcConfiguration config)`
  - `BuildReadRandomFrameFromConfigAscii(PlcConfiguration config)`

### 新規作成が必要なファイル
- **ConfigToFrameManagerTests.cs**: 単体テスト
  - Binary形式テストケース（Round 1-4）
  - ASCII形式テストケース（Round 5-8）

- **Step1_3_IntegrationTests.cs**: 統合テスト
  - Excel読み込み→送信統合テスト（Round 9-10）

---

## 既存コードへの影響

### 影響なし（互換性維持）
既存の`BuildReadRandomFrameFromConfig(TargetDeviceConfig)`メソッドは**残存**させるため、既存コードは影響を受けない。

### オーバーロード解決
C#のメソッドオーバーロード機能により、引数の型に基づいて自動的に正しいメソッドが選択される:

```csharp
// TargetDeviceConfig を渡した場合 → 既存のメソッドが呼ばれる
frameManager.BuildReadRandomFrameFromConfig(targetDeviceConfig);

// PlcConfiguration を渡した場合 → 新しいオーバーロードが呼ばれる
frameManager.BuildReadRandomFrameFromConfig(plcConfig);
```

---

## JSON廃止計画（将来の対応）

### Phase 1完了後の対応（現在）
- ✅ Excel読み込み機能完全実装
- ✅ PlcConfiguration用オーバーロード実装
- ✅ Step1-3オフラインテスト完了

### Phase 2: 並行運用期間（移行猶予）
- JSON形式とExcel形式の両方をサポート
- ドキュメント更新: Excel形式推奨、JSON形式非推奨

### Phase 3: JSON機能廃止
- `ConfigurationLoader`クラス削除
- TargetDeviceConfig用メソッド削除:
  - `BuildReadRandomFrameFromConfig(TargetDeviceConfig)` 削除
  - `BuildReadRandomFrameFromConfigAscii(TargetDeviceConfig)` 削除
- `appsettings.json` サンプルファイル削除

### Phase 4: クリーンアップ
- TargetDeviceConfigモデルの見直し
- 不要な依存関係の削除
- ドキュメント最終更新

---

## 実装優先度

### 最優先（Step1-3テスト用）
1. **Binary形式オーバーロード実装**（Phase 1）
2. **ASCII形式オーバーロード実装**（Phase 2）
3. **統合テスト実装**（Phase 3）

### 将来対応（Phase完了後）
4. JSON機能の廃止検討
5. TargetDeviceConfigモデルの見直し
6. 統一されたクラス設計への移行

---

## 成功基準

### Step1-3テスト成功条件
- ✅ Excel設定ファイル読み込み成功（PlcConfiguration取得）
- ✅ PlcConfigurationから4Eフレーム構築成功
- ✅ MockSocketへのフレーム送信成功
- ✅ 全テストがパス（単体テスト、統合テスト）

### 将来的な成功条件
- Excel形式への完全移行
- JSON関連コードの完全削除
- 統一されたクラス設計
