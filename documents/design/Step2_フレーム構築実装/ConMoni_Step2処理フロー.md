# ConMoni (sample) - Step2: 通信フレーム構築処理フロー

## 処理概要

**範囲**: JSON設定ファイル生成時（Step1内で実施）
**動作**: SLMPフレーム（ReadRandom 0x0403）の自動構築
**実装場所**: `GenerateSettingJson.py:244-300`

---

## 全体処理フロー

```
┌──────────────────────────────────────────────────────────────┐
│ 1. フレーム構造初期化                                         │
│    GenerateSettingJson.py:251-256                            │
├──────────────────────────────────────────────────────────────┤
│ 辞書構造の初期化:                                             │
│    self.accessPlcSetting = {                                 │
│        "accessPlcSetting": [],      # 通信フレーム本体        │
│        "accessDeviceName": [],      # CSVヘッダ情報          │
│        "accessDeviceDigit": [],     # 桁数変換係数           │
│        "accessBitDataLoc": [],      # ビット判定フラグ       │
│        "accessCombinationDataGroup": [] # データ結合グループ  │
│    }                                                          │
└──────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────┐
│ 2. 基本フレーム構築                                           │
│    GenerateSettingJson.py:257-267                            │
├──────────────────────────────────────────────────────────────┤
│ SLMPフレーム（4E Binary相当）構築:                            │
│                                                               │
│ バイト位置 │ 値             │ 説明                          │
│ ─────────┼───────────────┼─────────────────────────  │
│ 0-1       │ 0x54, 0x00     │ サブヘッダ (※標準3Eは0x50)   │
│ 2-3       │ 0x00, 0x00     │ シリアル番号（予約）          │
│ 4-5       │ 0x00, 0x00     │ 予約フィールド                │
│ 6         │ 0x00           │ 要求先ネットワーク番号        │
│ 7         │ 0xFF           │ 要求先局番（全局）            │
│ 8-9       │ 0xFF, 0x03     │ 要求先I/O番号 (LE: 0x03FF)   │
│ 10        │ 0x00           │ マルチドロップ局番            │
│ 11-12     │ 0xFF, 0x03     │ データ長（後で動的計算）      │
│ 13-14     │ 0x20, 0x00     │ 監視タイマ (LE: 0x0020=32)   │
│           │                │ ※32×250ms = 8秒              │
│ 15-16     │ 0x03, 0x04     │ コマンド (LE: 0x0403)        │
│           │                │ ※ReadRandom一括読み出し      │
│ 17-18     │ 0x00, 0x00     │ サブコマンド                  │
│ 19        │ 0x00           │ ワード点数（後で動的設定）    │
│ 20        │ 0x00           │ Dword点数（未使用）           │
│                                                               │
│ ※注意: サブヘッダ 0x54 0x00 は4Eフレーム相当                 │
│         標準3Eフレームは 0x50 0x00                           │
└──────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────┐
│ 3. デバイス指定部構築                                         │
│    GenerateSettingJson.py:286 → generateDictData()          │
├──────────────────────────────────────────────────────────────┤
│ 各デバイスを4バイト単位で追加:                                 │
│                                                               │
│ 【ビットデバイスの場合】                                      │
│    16点単位の先頭デバイス情報を追加:                           │
│    [下位バイト, 中位バイト, 上位バイト, デバイスコード]        │
│                                                               │
│    例: M100-M115 (1ワード)                                    │
│        100 (0x64) → [0x64, 0x00, 0x00, 0x90]                │
│        ↑ デバイス番号(LE)  ↑ Mのコード                      │
│                                                               │
│ 【ワードデバイスの場合】                                      │
│    デバイスごとに4バイト追加:                                 │
│    [下位バイト, 中位バイト, 上位バイト, デバイスコード]        │
│                                                               │
│    例: D500, D502, D504                                       │
│        D500: [0xF4, 0x01, 0x00, 0xA8]                       │
│        D502: [0xF6, 0x01, 0x00, 0xA8]                       │
│        D504: [0xF8, 0x01, 0x00, 0xA8]                       │
│                                                               │
│ デバイスカウンタ:                                             │
│    self.deviceCounter += 1 (各デバイス追加ごと)              │
└──────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────┐
│ 4. データ長動的計算                                           │
│    GenerateSettingJson.py:291-294                            │
├──────────────────────────────────────────────────────────────┤
│ 【計算対象】                                                  │
│    バイト13以降のデータ長（監視タイマから末尾まで）            │
│                                                               │
│ 【計算式】                                                    │
│    numData = len(accessPlcSetting[13:])                      │
│                                                               │
│ 【リトルエンディアン変換】                                    │
│    hexDevices = hex(numData)[2:].zfill(4)  # "0048"形式     │
│    accessPlcSetting[11] = int(hexDevices[2:], 16)  # 下位    │
│    accessPlcSetting[12] = int(hexDevices[:2], 16)  # 上位    │
│                                                               │
│ 例: デバイス16点の場合                                        │
│    - コマンド部: 8バイト (監視タイマ～Dword点数)              │
│    - デバイス指定部: 4バイト × 16点 = 64バイト                │
│    - 合計: 72バイト (0x48)                                    │
│    → [11] = 0x48, [12] = 0x00                               │
└──────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────┐
│ 5. デバイス点数設定                                           │
│    GenerateSettingJson.py:299                                │
├──────────────────────────────────────────────────────────────┤
│ ワード点数フィールド更新:                                     │
│    accessPlcSetting[19] = self.deviceCounter                 │
│                                                               │
│ ※ビットデバイスは16点単位で1カウント                          │
│ ※ワードデバイスは1デバイス=1カウント                          │
│                                                               │
│ 例: M100-M115(1) + D500,D502,D504(3) = 合計4点               │
│    → accessPlcSetting[19] = 0x04                             │
└──────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────┐
│ 6. フレーム完成                                               │
│    GenerateSettingJson.py:300 → return                       │
├──────────────────────────────────────────────────────────────┤
│ 完成したフレーム構造:                                         │
│                                                               │
│ [サブヘッダ(2) + シリアル(2) + 予約(2) +                      │
│  ネットワーク設定(5) + データ長(2) +                          │
│  監視タイマ(2) + コマンド(2) + サブコマンド(2) +              │
│  点数指定(2) + デバイス指定(4×N)]                            │
│                                                               │
│ 具体例（16点の場合）:                                         │
│    総バイト数: 21（ヘッダ） + 72（データ長） = 93バイト       │
│                                                               │
│ このフレームをJSON設定ファイルの                              │
│ "accessPlcSetting" フィールドに保存                           │
└──────────────────────────────────────────────────────────────┘
```

---

## フレーム構造の詳細

### 基本フレームヘッダ (21バイト)

**実装コード** (GenerateSettingJson.py:257-267):

```python
self.accessPlcSetting["accessPlcSetting"].extend([
    0x54, 0x00,        # 0-1: サブヘッダ ※標準3Eは0x50 0x00
    0x00, 0x00,        # 2-3: シリアル番号（予約）
    0x00, 0x00,        # 4-5: 予約
    0x00,              # 6: 要求先ネットワーク番号
    0xFF,              # 7: 要求先局番
    0xFF, 0x03,        # 8-9: 要求先ユニットI/O番号 (LE: 0x03FF)
    0x00,              # 10: マルチドロップ局番
    0xFF, 0x03,        # 11-12: 要求データ長（後で動的計算）
    0x20, 0x00,        # 13-14: 監視タイマ (LE: 0x0020 = 32)
    0x03, 0x04,        # 15-16: コマンド (LE: 0x0403 = ReadRandom)
    0x00, 0x00,        # 17-18: サブコマンド
    0x00,              # 19: ワード点数（後で動的設定）
    0x00               # 20: Dword点数（未使用）
])
```

### フィールド別詳細説明

#### サブヘッダ (0x54 0x00)

**ConMoniの実装**:
```
0x54 0x00 (4Eフレーム相当)
```

**標準SLMP仕様**:
- 3E Binary: `0x50 0x00`
- 4E Binary: `0x54 0x00`

**注意点**:
- ConMoniは4E相当のサブヘッダを使用
- ただしシーケンス番号管理は未実装（0x00固定）
- 実機との互換性は確認済み（稼働実績あり）

**andon推奨**:
- 標準準拠の `0x50 0x00` (3E Binary)を優先
- 接続テストで問題があれば `0x54 0x00` も試行

#### シリアル番号 (0x00 0x00)

**用途**:
- 4Eフレームで要求-応答のマッチングに使用
- 複数要求の並行処理時に必須

**ConMoniの実装**:
```
固定値 0x00 0x00 (未使用)
```

**andon推奨**:
- 4Eフレーム使用時は自動インクリメント実装
- 要求ごとに +1 してユニークなシーケンス番号割り当て

#### 監視タイマ (0x20 0x00)

**計算方法**:
```
タイムアウト時間(秒) = 監視タイマ値 × 250ms
例: 0x0020 (32) = 32 × 250ms = 8秒
```

**ConMoniの設定**:
```
固定値: 0x20 0x00 (8秒)
```

**andon実装**:
```csharp
// appsettings.json: ReceiveTimeoutMs = 8000
ushort timerValue = (ushort)(receiveTimeoutMs / 250);
// 8000ms / 250 = 32 (0x0020)
```

#### コマンド (0x03 0x04)

**リトルエンディアン表記**:
```
0x03 0x04 (LE) = 0x0403 (BE) = ReadRandom一括読み出し
```

**SLMP主要コマンド**:
- `0x0401`: 一括読み出し（連続アドレス）
- `0x0403`: ランダム読み出し（不連続アドレス）
- `0x1401`: 一括書き込み
- `0x1403`: ランダム書き込み

**ConMoniの選択理由**:
- 不連続なデバイス番号に対応可能
- ビットデバイスとワードデバイスの混在可能
- 柔軟性が高い

---

## デバイス指定部の構築

### デバイス指定形式 (4バイト単位)

各デバイスは以下の4バイト構造:

```
[下位バイト, 中位バイト, 上位バイト, デバイスコード]
└──────── デバイス番号 (3バイトLE) ────────┘
```

### ビットデバイスの処理

**実装フロー**:

1. **16点単位でグループ化** (Step1で実施済み)
2. **先頭デバイスのみ登録**
3. **デバイスカウンタ +1** (16点で1カウント)

**例**: M100, M101, M102, M110 (4点使用)

```
グループ化: M100-M115 (16点範囲)
先頭デバイス: M100
通信データ: [0x64, 0x00, 0x00, 0x90]
    ↑ 100 (0x64) をリトルエンディアンで3バイト
                            ↑ Mのデバイスコード (0x90)
```

**受信時の展開**:
- PLCから1ワード（16ビット）受信
- ビット0 → M100
- ビット1 → M101
- ビット2 → M102
- ...
- ビット10 → M110
- ...
- ビット15 → M115

### ワードデバイスの処理

**実装フロー**:

1. **デバイスごとに個別登録**
2. **デバイスカウンタ +1** (1デバイス=1カウント)

**例**: D500, D502, D504

```
D500:
    デバイス番号: 500 (0x1F4)
    リトルエンディアン: [0xF4, 0x01, 0x00]
    デバイスコード: 0xA8 (D)
    通信データ: [0xF4, 0x01, 0x00, 0xA8]

D502:
    デバイス番号: 502 (0x1F6)
    通信データ: [0xF6, 0x01, 0x00, 0xA8]

D504:
    デバイス番号: 504 (0x1F8)
    通信データ: [0xF8, 0x01, 0x00, 0xA8]
```

---

## データ長の動的計算

### 計算対象範囲

```
データ長 = バイト13以降の全バイト数
         = 監視タイマ(2) + コマンド(2) + サブコマンド(2) +
           点数指定(2) + デバイス指定部(4×N)
```

### 実装コード解説

**実装** (GenerateSettingJson.py:291-294):

```python
numData = len(self.accessPlcSetting["accessPlcSetting"][13:])
hexDevices = str(hex(numData)[2:].zfill(4))
self.accessPlcSetting["accessPlcSetting"][11] = int(hexDevices[2:], 16)  # 下位
self.accessPlcSetting["accessPlcSetting"][12] = int(hexDevices[:2], 16)  # 上位
```

**処理ステップ**:

1. **バイト13以降の長さ取得**
   ```python
   numData = len(accessPlcSetting[13:])
   ```

2. **16進数文字列化（4桁）**
   ```python
   hexDevices = str(hex(numData)[2:].zfill(4))
   # 例: 72 → "0x48" → "48" → "0048"
   ```

3. **リトルエンディアン分割**
   ```python
   # "0048" の場合
   hexDevices[2:] = "48" → int("48", 16) = 0x48 (下位バイト)
   hexDevices[:2] = "00" → int("00", 16) = 0x00 (上位バイト)
   ```

4. **バイト11-12に書き込み**
   ```python
   accessPlcSetting[11] = 0x48  # 下位バイト
   accessPlcSetting[12] = 0x00  # 上位バイト
   ```

### 計算例

**デバイス16点の場合**:

```
監視タイマ:        2バイト
コマンド:          2バイト
サブコマンド:      2バイト
点数指定:          2バイト
デバイス指定部:   64バイト (4バイト × 16点)
─────────────────────────
合計:             72バイト (0x48)

リトルエンディアン: [0x48, 0x00]
```

**デバイス48点の場合**:

```
監視タイマ:        2バイト
コマンド:          2バイト
サブコマンド:      2バイト
点数指定:          2バイト
デバイス指定部:  192バイト (4バイト × 48点)
─────────────────────────
合計:            200バイト (0xC8)

リトルエンディアン: [0xC8, 0x00]
```

---

## 実際のフレーム例

### 実例1: 16点読み出し（ConMoni実機設定）

```json
{
  "accessPlcSetting": [
    84, 0,              // 0-1: サブヘッダ 0x54 0x00
    0, 0,               // 2-3: シリアル
    0, 0,               // 4-5: 予約
    0, 255, 255, 3, 0,  // 6-10: ネットワーク設定
    72, 0,              // 11-12: データ長 72バイト (0x48)
    32, 0,              // 13-14: 監視タイマ 8秒 (0x20)
    3, 4,               // 15-16: コマンド 0x0403 (ReadRandom)
    0, 0,               // 17-18: サブコマンド
    16, 0,              // 19-20: ワード16点, Dword0点

    // デバイス指定（4バイト×16点 = 64バイト）
    244, 1, 0, 168,     // D500: 500(0x1F4)→[0xF4,0x01,0x00], 0xA8
    246, 1, 0, 168,     // D502
    248, 1, 0, 168,     // D504
    249, 1, 0, 168,     // D505
    250, 1, 0, 168,     // D506
    252, 1, 0, 168,     // D508
    254, 1, 0, 168,     // D510
    0, 2, 0, 168,       // D512: 512(0x200)→[0x00,0x02,0x00]
    67, 6, 0, 144,      // M1603: 1603(0x643)→[0x43,0x06,0x00], 0x90
    175, 6, 0, 144,     // M1711: 1711(0x6AF)→[0xAF,0x06,0x00]
    198, 4, 0, 144,     // M1222
    176, 4, 0, 144,     // M1200
    192, 4, 0, 144,     // M1216
    230, 5, 0, 144,     // M1510
    48, 1, 0, 157,      // Y304: 0x130→[0x30,0x01,0x00], 0x9D
    96, 16, 0, 157      // Y4192: 0x1060→[0x60,0x10,0x00]
  ]
}
```

**フレーム構成の検証**:
- ヘッダ: 21バイト (0～20)
- データ長フィールド値: 72バイト
- デバイス点数: 16点
- デバイス指定部: 4×16 = 64バイト
- 計算検証: 8(コマンド部) + 64(デバイス指定) = 72バイト ✓

### 実例2: 3点読み出し（最小構成）

```json
{
  "accessPlcSetting": [
    84, 0,              // サブヘッダ
    0, 0, 0, 0,         // シリアル + 予約
    0, 255, 255, 3, 0,  // ネットワーク設定
    20, 0,              // データ長 20バイト (0x14)
    32, 0,              // 監視タイマ
    3, 4, 0, 0,         // コマンド
    3, 0,               // ワード3点, Dword0点

    // デバイス指定（4バイト×3点 = 12バイト）
    100, 0, 0, 168,     // D100
    200, 0, 0, 168,     // D200
    44, 1, 0, 168       // D300: 300(0x12C)→[0x2C,0x01,0x00]
  ]
}
```

**データ長計算**:
- コマンド部: 8バイト
- デバイス指定部: 12バイト (4×3)
- 合計: 20バイト (0x14) ✓

---

## フレーム送信処理

### 送信実装

**実装場所**: `GetPlcData.py:287-288`

```python
# 要求送信
self.sock.send(bytes(self.settingData["accessPlcSetting"]))
```

**処理内容**:
1. JSON設定から `accessPlcSetting` 配列取得
2. `bytes()` でバイト列に変換
3. ソケット経由でPLCに送信

**注意点**:
- TCP/UDPは初期化時に判定済み（Step1）
- タイムアウトは初期化時に設定済み
- 送信エラーは例外として上位へ伝播

---

## andonプロジェクトとの対比

### ConMoniの特徴

**✅ 採用すべき点:**

1. **データ長の動的計算**
   - デバイス数に応じて自動計算
   - 手動計算ミスを防止
   - andonでも同様の実装推奨

2. **リトルエンディアン処理の自動化**
   - デバイス番号変換が自動
   - バイト順の誤りを防止

3. **フレーム構造の明確化**
   - 各フィールドの役割が明確
   - コメント付きで可読性高い

**⚠️ 改善すべき点:**

1. **サブヘッダの非標準使用**
   - ConMoni: `0x54 0x00` (4E相当)
   - **andon推奨**: `0x50 0x00` (標準3E)

2. **シーケンス番号未実装**
   - 固定値 `0x00 0x00`
   - 複数要求の並行処理不可
   - **andon推奨**: 自動インクリメント実装

3. **フレーム検証なし**
   - 不正なデバイスコードでもそのまま送信
   - **andon推奨**: 送信前の多段階検証

### andonでの実装状況

**Step2: フレーム構築（実装済み）**

実装場所:
- `ConfigToFrameManager.cs` - 高レベルAPI
- `SlmpFrameBuilder.cs` - 低レベル実装

**主要メソッド**:

```csharp
// Binary形式
public byte[] BuildReadRandomFrameFromConfig(TargetDeviceConfig config)
{
    // 1. null チェック
    // 2. デバイスリスト検証
    // 3. フレームタイプ検証

    // 4. SlmpFrameBuilder呼び出し
    byte[] frame = SlmpFrameBuilder.BuildReadRandomRequest(
        config.Devices,
        config.FrameType,
        config.Timeout
    );

    return frame;
}
```

**ConMoniとの比較**:

| 項目 | ConMoni | andon |
|-----|---------|-------|
| フレーム生成タイミング | 事前生成（JSON保存） | 実行時動的生成 |
| サブヘッダ | 0x54 (4E相当) | 0x50/0x54 (設定可能) |
| シーケンス番号 | 未実装（0x00固定） | 自動インクリメント |
| データ長計算 | 動的計算 | 動的計算 |
| 入力検証 | なし | 多段階検証 |
| エラーハンドリング | 最小限 | 詳細な例外処理 |

---

## andon実装への適用推奨

### 1. データ長計算ロジックの実装

**推奨実装** (C#):

```csharp
public static byte[] CalculateDataLength(int commandPartLength)
{
    // コマンド部以降の総バイト数を計算
    // commandPartLength = 監視タイマ(2) + コマンド(4) + 点数(2) + デバイス指定(4×N)

    byte[] lengthBytes = new byte[2];
    lengthBytes[0] = (byte)(commandPartLength & 0xFF);        // 下位バイト
    lengthBytes[1] = (byte)((commandPartLength >> 8) & 0xFF); // 上位バイト

    return lengthBytes;
}
```

### 2. フレーム構築の統合処理

**推奨実装** (C#):

```csharp
public static byte[] BuildReadRandomRequest(
    List<DeviceSpecification> devices,
    string frameType,
    ushort timeout)
{
    var frame = new List<byte>();

    // 1. サブヘッダ追加
    frame.AddRange(GetSubHeader(frameType));

    // 2. ネットワーク設定追加
    frame.AddRange(GetNetworkConfig());

    // 3. データ長プレースホルダ（後で更新）
    int dataLengthIndex = frame.Count;
    frame.AddRange(new byte[] { 0x00, 0x00 });

    // 4. 監視タイマ追加
    frame.AddRange(BitConverter.GetBytes(timeout));

    // 5. コマンド部追加
    frame.AddRange(new byte[] { 0x03, 0x04, 0x00, 0x00 }); // ReadRandom

    // 6. 点数指定追加
    frame.Add((byte)devices.Count); // ワード点数
    frame.Add(0x00);                // Dword点数

    // 7. デバイス指定部追加
    foreach (var device in devices)
    {
        frame.AddRange(ConvertDeviceToBytes(device));
    }

    // 8. データ長更新
    int dataLength = frame.Count - dataLengthIndex - 2;
    frame[dataLengthIndex] = (byte)(dataLength & 0xFF);
    frame[dataLengthIndex + 1] = (byte)((dataLength >> 8) & 0xFF);

    return frame.ToArray();
}
```

### 3. デバイス変換ヘルパー

**推奨実装** (C#):

```csharp
private static byte[] ConvertDeviceToBytes(DeviceSpecification device)
{
    var bytes = new byte[4];

    // デバイス番号（3バイト、リトルエンディアン）
    bytes[0] = (byte)(device.DeviceNumber & 0xFF);
    bytes[1] = (byte)((device.DeviceNumber >> 8) & 0xFF);
    bytes[2] = (byte)((device.DeviceNumber >> 16) & 0xFF);

    // デバイスコード（1バイト）
    bytes[3] = DeviceCodeMap.GetDeviceCode(device.DeviceType);

    return bytes;
}
```

---

## フレーム検証チェックリスト

### 送信前検証項目

**必須チェック**:
- [ ] サブヘッダが正しい（0x50 or 0x54）
- [ ] データ長が正確に計算されている
- [ ] デバイス点数が一致している
- [ ] 各デバイスコードが有効
- [ ] リトルエンディアンが正しい
- [ ] 監視タイマが妥当な範囲（1～65535）

**推奨チェック**:
- [ ] デバイス点数が上限以下（255点）
- [ ] フレーム総サイズが妥当（4096バイト以下）
- [ ] TCP/UDPに応じた送信方法

### 受信後検証項目

**必須チェック**:
- [ ] 応答サブヘッダが正しい（0xD0 or 0xD4）
- [ ] 終了コードが0x0000（正常）
- [ ] データ長が期待値と一致
- [ ] 受信データが完全（切断なし）

**推奨チェック**:
- [ ] ネットワーク番号が一致
- [ ] PC番号が一致
- [ ] タイムアウト内で受信完了

---

## まとめ

### ConMoni Step2処理の要約

```
フレーム構造初期化
    ↓
基本ヘッダ構築（21バイト）
    - サブヘッダ: 0x54 0x00
    - ネットワーク設定
    - データ長プレースホルダ
    - 監視タイマ: 0x20 0x00 (8秒)
    - コマンド: 0x03 0x04 (ReadRandom)
    - 点数指定プレースホルダ
    ↓
デバイス指定部構築
    - ビットデバイス: 16点単位先頭のみ
    - ワードデバイス: 個別に追加
    - 各4バイト: [番号3バイト(LE), コード1バイト]
    ↓
データ長動的計算
    - バイト13以降の長さを計算
    - リトルエンディアン変換
    - バイト11-12に書き込み
    ↓
デバイス点数設定
    - デバイスカウンタ値をバイト19に設定
    ↓
フレーム完成
    - JSON設定ファイルに保存
    - Step3以降で使用
```

### 重要な技術的知見

1. **データ長の計算範囲**
   - バイト13以降（監視タイマから末尾まで）
   - フレーム総長 ≠ データ長フィールド値

2. **リトルエンディアンの徹底**
   - データ長、監視タイマ、コマンド、デバイス番号すべてLE
   - 16進数文字列での分割処理に注意

3. **デバイス点数のカウント**
   - ビットデバイス: 16点で1カウント
   - ワードデバイス: 1デバイスで1カウント

4. **フレーム再利用の効率性**
   - ConMoni: 事前生成で高速
   - andon: 動的生成で柔軟
   - 用途に応じた選択が重要

5. **サブヘッダの選択**
   - 標準準拠: 0x50 0x00 (3E Binary)
   - ConMoni実績: 0x54 0x00 (4E相当)
   - 実機テストで最終決定推奨
