# 6ステップフロー実装計画

## 背景
現在の4ステップフローを`動作イメージ.md`に記載されている6ステップフローに完全対応させる実装計画。

## 現在の実装状況

### 現在の4ステップフロー
1. **Step1**: PLCから型名を取得 (`Step1_GetPlcTypeAsync`)
2. **Step2**: 型名からデバイスコードを決定 (`Step2_BuildDiscoveryConfig`)
3. **Step3**: デバイス範囲を網羅的に確認 (`Step3_ScanDeviceRangesAsync`)
4. **Step4**: 応答のあったデバイスのみ継続監視 (`Step4_StartActiveDeviceMonitoringAsync`)

### 求められている6ステップフロー
1. **Step1**: 設定ファイルで接続するPLCを決定
2. **Step2**: Step1で定義したPLCに接続し機器情報を取得
3. **Step3**: Step2で得た機器情報からシリーズを判定し、それに対応したデバイスコードを抽出
4. **Step4**: Step3で抽出された全てのデバイスコード＋一般的な機器番号(例えばM100-M199)で網羅的にスキャンして応答を確認
5. **Step5**: 応答があった(非ゼロデータ)デバイスを抽出(例えば、M102, D205)
6. **Step6**: Step5で抽出したデバイスのデータのみを継続的に取得

## 実装計画

### 1. IntelligentMonitoringSystem.cs の修正

#### 新規メソッド追加
```csharp
// Step1: 設定ファイルからPLC接続情報を取得
public PlcConnectionInfo Step1_LoadPlcConfigurationAsync(IConfiguration config);

// Step2: PLC接続と機器情報取得 (現在のStep1を改名・拡張)
public async Task<(string typeName, TypeCode typeCode, string connectionInfo)> Step2_ConnectAndGetDeviceInfoAsync(
    PlcConnectionInfo connectionInfo, CancellationToken cancellationToken = default);

// Step3: シリーズ判定とデバイスコード抽出 (現在のStep2を改名)
public DeviceDiscoveryConfiguration Step3_DetermineSeriesAndExtractDeviceCodes(TypeCode typeCode);

// Step4: 全デバイスコード網羅的スキャン (現在のStep3を改名・拡張)
public async Task<List<DeviceScanResult>> Step4_ComprehensiveScanAllDevices(
    DeviceDiscoveryConfiguration configuration,
    CancellationToken cancellationToken = default);

// Step5: 非ゼロデータデバイス抽出 (新規)
public List<ActiveDeviceInfo> Step5_ExtractNonZeroDataDevices(List<DeviceScanResult> scanResults);

// Step6: 継続監視開始 (現在のStep4を改名)
public async Task<bool> Step6_StartContinuousMonitoring(
    List<ActiveDeviceInfo> activeDevices,
    CancellationToken cancellationToken = default);
```

#### データモデル追加
```csharp
public class PlcConnectionInfo
{
    public string IpAddress { get; set; }
    public int Port { get; set; }
    public bool UseTcp { get; set; }
    public string FrameVersion { get; set; }
    public int ReceiveTimeoutMs { get; set; }
    public int ConnectTimeoutMs { get; set; }
    public string DisplayName { get; set; } // 設定ファイルから取得した識別名
}

public class ActiveDeviceInfo
{
    public DeviceCode DeviceCode { get; set; }
    public uint Address { get; set; }
    public object Value { get; set; } // 非ゼロ値
    public DeviceValueType ValueType { get; set; }
    public DateTime DetectedAt { get; set; }
}
```

### 2. Program.cs の修正

#### コンソール出力メッセージ更新
```csharp
private static async Task RunIntelligentMonitoringAsync(IConfiguration config, ILoggerFactory loggerFactory)
{
    Console.WriteLine("🚀 インテリジェント監視システム開始");
    Console.WriteLine("6ステップフロー:");
    Console.WriteLine("1. 設定ファイルで接続するPLCを決定");
    Console.WriteLine("2. PLCに接続し機器情報を取得");
    Console.WriteLine("3. 機器情報からシリーズを判定し、デバイスコードを抽出");
    Console.WriteLine("4. 全デバイスコード＋一般的な機器番号で網羅的スキャン");
    Console.WriteLine("5. 応答があった(非ゼロデータ)デバイスを抽出");
    Console.WriteLine("6. 抽出したデバイスのデータのみを継続的に取得");
    Console.WriteLine();
    // ...
}
```

### 3. IntelligentMonitoringExample.cs の修正

#### 6ステップ実行デモの実装
```csharp
// === 方法2: 6ステップ別実行デモ ===
logger.LogInformation("\n=== 方法2: 6ステップ別実行デモ ===");

try
{
    // Step 1: 設定ファイルからPLC接続情報取得
    var plcConnectionInfo = monitoringSystem.Step1_LoadPlcConfiguration(config);
    logger.LogInformation("Step 1結果: PLC接続先='{DisplayName}' ({IpAddress}:{Port})",
        plcConnectionInfo.DisplayName, plcConnectionInfo.IpAddress, plcConnectionInfo.Port);

    // Step 2: PLC接続と機器情報取得
    var (typeName, typeCode, connectionInfo) = await monitoringSystem.Step2_ConnectAndGetDeviceInfoAsync(
        plcConnectionInfo, cancellationToken);
    logger.LogInformation("Step 2結果: 接続成功='{ConnectionInfo}', 型名='{TypeName}', TypeCode={TypeCode}",
        connectionInfo, typeName, typeCode);

    // Step 3: シリーズ判定とデバイスコード抽出
    var discoveryConfig = monitoringSystem.Step3_DetermineSeriesAndExtractDeviceCodes(typeCode);
    logger.LogInformation("Step 3結果: {ConfigInfo}",
        monitoringSystem.GetConfigurationSummary(discoveryConfig));

    // Step 4: 全デバイスコード網羅的スキャン
    logger.LogInformation("Step 4: 全デバイスコード＋一般的機器番号で網羅的スキャン実行");
    var scanResults = await monitoringSystem.Step4_ComprehensiveScanAllDevices(discoveryConfig, cancellationToken);
    var totalScanned = scanResults.Sum(r => r.ScannedRange.Count);
    logger.LogInformation("Step 4結果: 総スキャン数 {TotalScanned}個", totalScanned);

    // Step 5: 非ゼロデータデバイス抽出
    var activeDevices = monitoringSystem.Step5_ExtractNonZeroDataDevices(scanResults);
    logger.LogInformation("Step 5結果: 非ゼロデータデバイス {ActiveCount}個を抽出", activeDevices.Count);

    foreach (var device in activeDevices.Take(5)) // 最初の5個を表示
    {
        logger.LogInformation("  抽出デバイス: {DeviceCode}{Address} = {Value}",
            device.DeviceCode, device.Address, device.Value);
    }

    // Step 6: 継続監視開始
    if (activeDevices.Count > 0)
    {
        var monitoringStarted = await monitoringSystem.Step6_StartContinuousMonitoring(activeDevices, cancellationToken);
        logger.LogInformation("Step 6結果: 継続監視開始={MonitoringStarted}", monitoringStarted);
    }

    logger.LogInformation("✅ 6ステップ実行完了");
}
catch (Exception ex)
{
    logger.LogError(ex, "❌ 6ステップ実行でエラー");
}
```

### 4. 非ゼロデータフィルタリング機能の実装

#### Step5_ExtractNonZeroDataDevices の詳細実装
```csharp
public List<ActiveDeviceInfo> Step5_ExtractNonZeroDataDevices(List<DeviceScanResult> scanResults)
{
    _logger.LogInformation("Step 5実行: 非ゼロデータデバイス抽出");

    var activeDevices = new List<ActiveDeviceInfo>();
    var now = DateTime.Now;

    foreach (var scanResult in scanResults)
    {
        foreach (var deviceAddress in scanResult.ActiveDevices)
        {
            // デバイス値を取得
            var value = GetDeviceValue(scanResult.DeviceCode, deviceAddress);

            // 非ゼロ判定
            bool isNonZero = IsNonZeroValue(value, scanResult.DeviceCode);

            if (isNonZero)
            {
                activeDevices.Add(new ActiveDeviceInfo
                {
                    DeviceCode = scanResult.DeviceCode,
                    Address = deviceAddress,
                    Value = value,
                    ValueType = scanResult.DeviceCode.IsBitDevice() ? DeviceValueType.Bit : DeviceValueType.Word,
                    DetectedAt = now
                });
            }
        }
    }

    _logger.LogInformation("Step 5成功: {ActiveCount}個の非ゼロデータデバイスを抽出", activeDevices.Count);
    return activeDevices;
}

private bool IsNonZeroValue(object value, DeviceCode deviceCode)
{
    if (deviceCode.IsBitDevice())
    {
        return value is bool boolValue && boolValue; // true の場合のみアクティブ
    }
    else
    {
        return value switch
        {
            ushort ushortValue => ushortValue != 0,
            uint uintValue => uintValue != 0,
            int intValue => intValue != 0,
            _ => false
        };
    }
}
```

### 5. appsettings.json の拡張

#### PLC識別情報の追加
```json
{
  "PlcConnection": {
    "DisplayName": "製造ライン1号機PLC",
    "IpAddress": "172.30.40.15",
    "Port": 8192,
    "UseTcp": false,
    "IsBinary": true,
    "FrameVersion": "4E",
    "ReceiveTimeoutMs": 3000,
    "ConnectTimeoutMs": 10000
  }
}
```

### 6. ログ出力の強化

#### 各ステップでの詳細ログ
- Step1: 読み込んだ設定ファイル情報
- Step2: PLC接続成功・機器情報詳細
- Step3: 抽出されたデバイスコード一覧
- Step4: スキャン対象範囲と結果統計
- Step5: 非ゼロデータの具体的な値
- Step6: 継続監視対象デバイス一覧

## 実装順序

1. **データモデル追加** (PlcConnectionInfo, ActiveDeviceInfo)
2. **IntelligentMonitoringSystem.cs修正** (6ステップメソッド実装)
3. **Program.cs修正** (コンソール出力更新)
4. **IntelligentMonitoringExample.cs修正** (6ステップデモ実装)
5. **appsettings.json拡張** (DisplayName等追加)
6. **テスト・動作確認**

## 期待される結果

- 動作イメージ.mdに完全対応した6ステップフロー
- 各ステップの責任が明確化
- 非ゼロデータの明示的なフィルタリング

## 📚 参考資料・関連文書

### 🎯 実装時必須参照資料

#### 通信設定・PLC対応詳細
- **Q00CPU_UDP通信対応_完全解決プラン_20251002.md**
  - Q00CPUの具体的通信制限（TCP非対応、3Eフレームドロップ）
  - UDP+4Eフレーム設定の必要性
  - appsettings.json の正しい設定値
  - Step2実装時の重要な制約事項

#### 問題分析・エラー対処
- **SLMP_ASCIIフレーム解析エラー解決手順.md**
  - Q00CPU特有の通信制限詳細
  - ReadTypeName失敗時のフォールバック処理
  - 16進文字解析エラーの対処法
  - Step2-Step3実装時のエラーハンドリング参考

### 🏗️ 設計・機能拡張資料

#### ログ出力設計
- **設計書準拠ログ出力_Step4生データ記録_完全実装計画_20241001.md**
  - Step4でのSLMPフレーム生データ記録要件
  - 統合ログシステムとの連携方法
  - CYCLE_COMMUNICATIONエントリタイプの活用

#### 機能統合計画
- **SlmpRawDataAnalyzer統合計画.md**
  - Step4での詳細フレーム解析機能
  - 16進ダンプ可視化の統合方法
  - データ型別解析機能の活用

### 📋 基本仕様・概要
- **動作イメージ.md** - 6ステップフローの基本定義（本実装計画の基準仕様）

### ⚠️ 実装時の重要な注意事項

1. **Q00CPU制限への対応必須**
   - TCP通信は完全に使用不可
   - 3Eフレームは完全にドロップされる
   - Step2でのReadTypeName失敗に対するフォールバック処理が必要

2. **設定ファイル整合性**
   - 最新のQ00CPU対応設定（UDP, Port 8192, FrameVersion "4E"）
   - 従来のTCP設定は動作しない

3. **エラーハンドリング強化**
   - 16進文字解析エラーの詳細診断機能
   - ログファイル競合エラーの排他制御

この実装計画と最新の技術解決策を統合することで、Q00CPUに完全対応した堅牢な6ステップフローシステムが実現されます。
- より理解しやすいフロー構造
- run_rawdata_logging.bat実行で6ステップフローが動作

## 注意事項

- 既存の4ステップフローとの後方互換性を維持
- 設定ファイルの変更は追加のみ（既存設定を破壊しない）
- ログレベル・出力形式は既存仕様を踏襲
- エラーハンドリングは既存の継続動作方針を維持