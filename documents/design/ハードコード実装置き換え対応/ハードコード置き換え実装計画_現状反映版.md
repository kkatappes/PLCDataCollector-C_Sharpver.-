# ハードコード置き換え実装状況（現状反映版・完全版）

**作成日**: 2025-11-28
**最終更新**: 2025-11-28
**対象**: andonプロジェクト
**目的**: ハードコード値の現状と、Excel設定ファイルから読み込む形式への置き換え状況を記録

---

## 0. 文書の目的と構成

### 0.1 本文書の位置づけ

本文書は、**現在の実装状況を正確に反映**した完全版記録文書です。
- 当初計画していた実装方針と、実際の実装状況の差異を明確化
- 今後の実装に必要な全情報を集約（既定値、検証ルール、実装例など）
- 設計文書との整合性確認
- この文書だけで実装可能な完全な情報を提供

### 0.2 主要な差異サマリー

| 項目 | 当初計画 | 実装状況 |
|-----|---------|---------|
| **設定保持クラス** | PlcConfiguration単独 | PlcConfiguration + TargetDeviceConfig + PlcConnectionConfig の3クラス併用 |
| **FrameVersion/Timeout** | PlcConfigurationに実装予定 | TargetDeviceConfig（SLMP単位）とPlcConnectionConfig（ミリ秒単位）に実装済み |
| **Excel読み込み** | B10-B15セルから拡張項目取得 | B8, B9, B11-B13のみ読み込み中 |
| **ConfigToFrameManager** | PlcConfigurationのみ使用 | 2つのオーバーロード（TargetDeviceConfig版 / PlcConfiguration版）|
| **Phase 1-2** | 未実装 | 代替実装（TargetDeviceConfig使用） |
| **Phase 3** | 未実装 | TargetDeviceConfig版のみ完了 |
| **デフォルト値の違い** | 単一の既定値 | クラス毎に異なる設計意図（3E/4E、ミリ秒/SLMP単位）|

---

## 1. ハードコード対応方針（既定値・検証ルール）

### 1.1 対応対象項目一覧

現在のコード内で以下の値がハードコードされている可能性があります:

| 項目 | ハードコード値例 | 対応方針 |
|-----|---------------|---------|
| **IPAddress** | "127.0.0.1" | 既定値なし。ExcelファイルB8セルから取得された値のみ使用（必須項目） |
| **Port** | 8192 | 既定値なし。ExcelファイルB9セルから取得された値のみ使用（必須項目） |
| **ConnectionMethod** | "UDP" | 既定値: "UDP"。ExcelファイルB10セルから取得された値で更新（省略可） |
| **FrameVersion** | "3E" | 既定値: "4E"。ExcelファイルB11セルから取得された値で更新（省略可） |
| **Timeout** | 8000 | 既定値: 1000 (1秒)。ExcelファイルB12セルから取得された値で更新（省略可） |
| **IsBinary** | false | 既定値: true (Binary形式)。ExcelファイルB13セルから取得された値で更新（省略可） |
| **MonitoringIntervalMs** | 5000 | 既定値: 1000 (1秒)。ExcelファイルB14セルから取得された値で更新（省略可） |
| **PlcId** | "PLC_001" | 既定値なし。設定ファイルの「IP_ポート番号」を自動生成して使用 |
| **PlcName** | "ライン1_設備A" | 既定値なし（省略可）。ExcelファイルB15セルから取得、未設定時はPlcIdを使用 |
| **Priority** | 5 | **不要** (削除対象) |
| **ConnectTimeoutMs** | 5000 | 既定値: 3000 (3秒)。TimeoutConfig設定で更新可能 |
| **SendTimeoutMs** | 3000 | 既定値: 500 (0.5秒)。TimeoutConfig設定で更新可能 |
| **ReceiveTimeoutMs** | 5000 | 既定値: 500 (0.5秒)。TimeoutConfig設定で更新可能 |
| **SendIntervalMs** | 100 | 既定値: 100 (0.1秒)。TimeoutConfig設定で更新可能 |

**重要な補足説明**:

1. **IsBinary**: 現状のデフォルト値false（ASCII形式）を、true（Binary形式）に変更
   - 既定値変更により、設定ファイルで明示的に指定しない限りBinary形式を使用
   - 理由: Binary形式の方が高効率で一般的

2. **MonitoringIntervalMs** (データ取得間隔): 現状5000ms（5秒）のデフォルト値を1000ms（1秒）に変更
   - 現在は下記2箇所で重複定義されている:
     - DataProcessingConfig.cs:11 - プロパティのデフォルト値 `= 5000`
     - DependencyInjectionConfigurator.cs:27 - DI設定時の明示的設定 `= 5000`
   - 対応方針: 両方とも1000msに変更し、Excelファイルから取得された値で更新可能にする

3. **TimeoutConfig項目** (接続・送受信タイムアウト):
   - **ConnectTimeoutMs**: 既定値3000ms（3秒）
   - **SendTimeoutMs**: 既定値500ms（0.5秒）
   - **ReceiveTimeoutMs**: 既定値500ms（0.5秒）
   - **SendIntervalMs**: 既定値100ms（0.1秒）
   - これらの既定値は厳守すること。TimeoutConfig.csで定義され、設定で上書き可能

### 1.2 項目分類詳細

#### 1.2.1 必須項目（既定値なし）

これらの項目は必ずExcelファイルから取得する必要があります:

##### 1. IPAddress
- **既定値**: なし
- **検証**: 有効なIPv4アドレス形式であること
- **検証詳細**:
  - IPv4形式: xxx.xxx.xxx.xxx
  - 各オクテット: 0～255
  - "0.0.0.0"は不許可
- **例**: "192.168.1.10", "172.30.40.15"

##### 2. Port
- **既定値**: なし
- **検証**: 1～65535の範囲内
- **一般的なPLCポート**: 5000, 8192
- **例**: 8192, 5000

##### 3. PlcId
- **既定値**: なし
- **自動生成ルール**: `{IPAddress}_{Port}`
- **例**: "192.168.1.10_8192"
- **用途**: ログ出力、データ識別子として使用
- **検証**: 自動生成のため検証不要

#### 1.2.2 オプション項目（既定値あり）

これらの項目はExcelファイルに値がない場合、既定値を使用します:

##### 1. ConnectionMethod
- **既定値**: "UDP"
- **許可値**: "TCP" または "UDP"
- **検証**: 大文字小文字を区別しない
- **エラー例**: "ConnectionMethodの値が不正です: 'HTTP' (許可値: TCP, UDP)"

##### 2. FrameVersion
- **既定値**: "4E"
- **許可値**: "3E" または "4E"
- **検証**: 大文字小文字を区別しない
- **エラー例**: "FrameVersionの値が不正です: '5E' (許可値: 3E, 4E)"

##### 3. Timeout
- **既定値**: 1000 (1秒)
- **単位**: ミリ秒
- **検証**: 正の整数であること
- **推奨範囲**: 100～30000 (0.1秒～30秒)
- **推奨値**: 1000～10000 (1秒～10秒)
- **SLMP変換**: ミリ秒を250ms単位に変換（例: 8000ms → 32単位）
- **エラー例**: "Timeoutの値が範囲外です: 50 (推奨範囲: 100～30000)"

##### 4. IsBinary
- **既定値**: true (Binary形式)
- **許可値**: true または false
- **検証**: ブール値であること
- **補足**: Excelファイルに値がない場合はBinary形式を使用
- **"1"/"0"形式のサポート**: "1"はtrue、"0"はfalseとして扱う
- **エラー例**: "IsBinaryの値が不正です: 'invalid' (許可値: true, false)"

##### 5. MonitoringIntervalMs (データ取得間隔)
- **既定値**: 1000 (1秒)
- **単位**: ミリ秒
- **検証**: 正の整数であること
- **推奨範囲**: 100～60000 (0.1秒～60秒)
- **補足**: Excelファイルから取得された値で更新可能
- **エラー例**: "MonitoringIntervalMsの値が範囲外です: 50 (推奨範囲: 100～60000)"

##### 6. ConnectTimeoutMs (接続タイムアウト)
- **既定値**: 3000 (3秒)
- **単位**: ミリ秒
- **検証**: 正の整数であること
- **推奨範囲**: 1000～30000 (1秒～30秒)
- **補足**: TimeoutConfig設定で更新可能
- **エラー例**: "ConnectTimeoutMsの値が範囲外です: 500 (推奨範囲: 1000～30000)"

##### 7. SendTimeoutMs (送信タイムアウト)
- **既定値**: 500 (0.5秒)
- **単位**: ミリ秒
- **検証**: 正の整数であること
- **推奨範囲**: 100～10000 (0.1秒～10秒)
- **補足**: TimeoutConfig設定で更新可能
- **エラー例**: "SendTimeoutMsの値が範囲外です: 50 (推奨範囲: 100～10000)"

##### 8. ReceiveTimeoutMs (受信タイムアウト)
- **既定値**: 500 (0.5秒)
- **単位**: ミリ秒
- **検証**: 正の整数であること
- **推奨範囲**: 100～10000 (0.1秒～10秒)
- **補足**: TimeoutConfig設定で更新可能
- **エラー例**: "ReceiveTimeoutMsの値が範囲外です: 50 (推奨範囲: 100～10000)"

##### 9. SendIntervalMs (送信間隔)
- **既定値**: 100 (0.1秒)
- **単位**: ミリ秒
- **検証**: 正の整数であること
- **推奨範囲**: 10～5000 (0.01秒～5秒)
- **補足**: TimeoutConfig設定で更新可能。PLC側の処理能力に応じて調整
- **エラー例**: "SendIntervalMsの値が範囲外です: 5 (推奨範囲: 10～5000)"

#### 1.2.3 オプション項目（既定値なし - Excelから取得のみ）

以下の項目はExcelファイルに値がある場合のみ使用します:

##### 1. PlcName ("ライン1_設備A")
- **既定値**: なし（省略可能）
- **用途**: ログ出力、表示用の識別名として使用
- **補足**: 未設定の場合はPlcIdを使用
- **最大長**: 100文字（推奨）

#### 1.2.4 削除対象項目

以下の項目はシステムで使用しないため削除します:

##### 1. Priority (5)
- **理由**: 優先度制御機能が未実装
- **将来的に必要になる場合は再検討**

### 1.3 Excelファイルのレイアウト

#### 推奨レイアウト

```
| 項目名              | 値                  | 備考                                    |
|--------------------|---------------------|-----------------------------------------|
| IPAddress          | 192.168.1.10        | (必須)                                   |
| Port               | 8192                | (必須)                                   |
| ConnectionMethod   | UDP                 | (省略時: UDP)                            |
| FrameVersion       | 4E                  | (省略時: 4E)                             |
| Timeout            | 5000                | (省略時: 1000) 単位: ミリ秒               |
| IsBinary           | true                | (省略時: true) Binary/ASCII形式切替       |
| MonitoringIntervalMs| 1000               | (省略時: 1000) 単位: ミリ秒 データ取得間隔 |
| PlcName            | ライン1_設備A        | (省略時: PlcIdを使用) 表示用識別名         |
```

#### 実際のセルマッピング（計画）

| セル | 項目名 | 備考 |
|------|-------|------|
| B8 | IPAddress | 必須 |
| B9 | Port | 必須 |
| B10 | ConnectionMethod | 省略可（既定値: UDP） |
| B11 | FrameVersion | 省略可（既定値: 4E） |
| B12 | Timeout | 省略可（既定値: 1000ms） |
| B13 | IsBinary | 省略可（既定値: true） |
| B14 | MonitoringIntervalMs | 省略可（既定値: 1000ms） |
| B15 | PlcName | 省略可（未設定時はPlcIdを使用） |

### 1.4 エラーメッセージ一覧

#### 必須項目の欠落
```
"必須項目 'IPAddress' が設定ファイルに存在しません。"
"必須項目 'Port' が設定ファイルに存在しません。"
```

#### 検証エラー
```
"IPAddressの形式が不正です: '999.999.999.999'"
"Portの値が範囲外です: 70000 (許可範囲: 1～65535)"
"ConnectionMethodの値が不正です: 'HTTP' (許可値: TCP, UDP)"
"FrameVersionの値が不正です: '5E' (許可値: 3E, 4E)"
"Timeoutの値が範囲外です: 50 (推奨範囲: 100～30000)"
"IsBinaryの値が不正です: 'invalid' (許可値: true, false)"
"MonitoringIntervalMsの値が範囲外です: 50 (推奨範囲: 100～60000)"
"ConnectTimeoutMsの値が範囲外です: 500 (推奨範囲: 1000～30000)"
"SendTimeoutMsの値が範囲外です: 50 (推奨範囲: 100～10000)"
"ReceiveTimeoutMsの値が範囲外です: 50 (推奨範囲: 100～10000)"
"SendIntervalMsの値が範囲外です: 5 (推奨範囲: 10～5000)"
```

---

## 2. 現在の実装状況

### 2.1 PlcConfiguration の現状

**実装ファイル**: `andon/Core/Models/ConfigModels/PlcConfiguration.cs`

**実装済みプロパティ**:
```csharp
public class PlcConfiguration
{
    // 接続設定（Excel B8, B9から読み込み）
    public string IpAddress { get; set; } = string.Empty;
    public int Port { get; set; }

    // データ処理設定（Excel B11から読み込み）
    public int DataReadingFrequency { get; set; }  // ← 当初計画の"MonitoringIntervalMs"に相当

    // PLC識別情報（Excel B12から読み込み）
    public string PlcModel { get; set; } = string.Empty;  // ← 当初計画の"PlcName"に相当

    // 出力設定（Excel B13から読み込み）
    public string SavePath { get; set; } = string.Empty;

    // 内部管理用
    public string SourceExcelFile { get; set; } = string.Empty;
    public string ConfigurationName { get; }
    public List<DeviceSpecification> Devices { get; set; } = new();
}
```

**未実装プロパティ**（当初計画では追加予定だった項目）:
- `ConnectionMethod` (接続方式: TCP/UDP)
- `FrameVersion` (SLMPフレームバージョン: 3E/4E)
- `Timeout` (タイムアウト値)
- `IsBinary` (Binary/ASCII形式切替)
- `PlcId` (PLC識別子の自動生成)
- `PlcName` (PLC名称) → 代わりに`PlcModel`が実装済み
- `MonitoringIntervalMs` (監視間隔) → 代わりに`DataReadingFrequency`が実装済み

### 2.2 TargetDeviceConfig の現状

**実装ファイル**: `andon/Core/Models/ConfigModels/TargetDeviceConfig.cs`

**実装済みプロパティ**:
```csharp
public class TargetDeviceConfig
{
    public List<DeviceEntry> Devices { get; set; } = new();

    // フレーム構築用設定（当初はPlcConfigurationに実装予定だった項目）
    public string FrameType { get; set; } = "4E";   // ← PlcConfiguration.FrameVersionに相当
    public ushort Timeout { get; set; } = 32;        // ← PlcConfiguration.Timeoutに相当（SLMP単位: 32 = 8000ms）
}
```

**役割**:
- デバイス取得設定（どのデバイスを読み取るか）
- フレーム構築パラメータ（どのフレーム形式で、どのタイムアウトで送信するか）

**設計上の位置づけ**:
- プロジェクト構造設計.md に記載あり（設計通り）
- PlcConfigurationとは別の責務を持つクラスとして設計されている

**デフォルト値の実装状況**:
- `FrameType = "4E"`: ✅ **正式な既定値"4E"と一致** （ハードコード状況確認.md参照）
- `Timeout = 32` (SLMP単位): ⚠️ **正式な既定値は4 (1000ms相当)**
  - 現在の実装値32 (8000ms相当)は暫定値であり、最終的には4 (1000ms)に変更される予定
- **重要**: Timeout値は「ハードコード状況確認.md」の既定値仕様（1000ms = SLMP単位で4）に従って修正が必要

### 2.3 PlcConnectionConfig の現状

**実装ファイル**: `andon/Core/Models/ConfigModels/PlcConnectionConfig.cs`

**実装済みプロパティ**:
```csharp
public class PlcConnectionConfig
{
    // 接続設定
    public string IPAddress { get; set; } = "127.0.0.1";
    public int Port { get; set; } = 8192;
    public string ConnectionMethod { get; set; } = "UDP";

    // SLMP設定
    public string FrameVersion { get; set; } = "3E";
    public int Timeout { get; set; } = 8000;  // ミリ秒単位（注: TargetDeviceConfigはSLMP単位でushort型）

    // PLC識別情報
    public string PlcId { get; set; } = "PLC_001";
    public string PlcName { get; set; } = "ライン1_設備A";
    public int Priority { get; set; } = 5;
}
```

**役割**:
- 複数PLC並列実行時の個別PLC接続設定
- `MultiPlcConfig`内で使用される

**設計上の位置づけ**:
- クラス設計.md:319に記載あり（設計通り）
- 複数PLC対応のために追加されたクラス

**デフォルト値の実装状況**:
- `FrameVersion = "3E"`: **⚠️ 正式な既定値は"4E"** （ハードコード状況確認.md参照）
  - 現在の実装値"3E"は暫定値であり、最終的には"4E"に統一される予定
- `Timeout = 8000ms`: **⚠️ 正式な既定値は1000ms** （ハードコード状況確認.md参照）
  - 現在の実装値8000msは暫定値であり、最終的には1000msに変更される予定
- **重要**: これらの値は「ハードコード状況確認.md」の既定値仕様に従って修正が必要

### 2.4 ConfigurationLoaderExcel の現状

**実装ファイル**: `andon/Infrastructure/Configuration/ConfigurationLoaderExcel.cs`

**現在のExcel読み込みマッピング**:
```csharp
var config = new PlcConfiguration
{
    IpAddress = ReadCell<string>(settingsSheet, "B8", "PLCのIPアドレス"),
    Port = ReadCell<int>(settingsSheet, "B9", "PLCのポート"),
    DataReadingFrequency = ReadCell<int>(settingsSheet, "B11", "データ取得周期(ms)"),
    PlcModel = ReadCell<string>(settingsSheet, "B12", "デバイス名"),
    SavePath = ReadCell<string>(settingsSheet, "B13", "データ保存先パス"),
    SourceExcelFile = filePath,
    Devices = ReadDevices(devicesSheet, filePath)
};
```

**読み込んでいないセル**（当初計画では読み込み予定だった項目）:
- B10: ConnectionMethod（未実装）
- B11: FrameVersion（現在はDataReadingFrequency用途で使用中）
- B12: Timeout（現在はPlcModel用途で使用中）
- B13: IsBinary（現在はSavePath用途で使用中）
- B14: MonitoringIntervalMs（未実装）
- B15: PlcName（未実装）

**実際のExcel構造**:
| セル | 当初計画 | 現状の用途 |
|------|---------|-----------|
| B8 | IPAddress | IPAddress ✅ |
| B9 | Port | Port ✅ |
| B10 | ConnectionMethod | （未使用） |
| B11 | FrameVersion | DataReadingFrequency |
| B12 | Timeout | PlcModel |
| B13 | IsBinary | SavePath |
| B14 | MonitoringIntervalMs | （未使用） |
| B15 | PlcName | （未使用） |

### 2.5 ConfigToFrameManager の現状

**実装ファイル**: `andon/Core/Managers/ConfigToFrameManager.cs`

**実装済みオーバーロード**:

#### オーバーロード1: TargetDeviceConfig版（ハードコード解消済み）
```csharp
public byte[] BuildReadRandomFrameFromConfig(TargetDeviceConfig config)
{
    // config.FrameType と config.Timeout を使用（ハードコードなし）
    byte[] frame = SlmpFrameBuilder.BuildReadRandomRequest(
        deviceSpecifications,
        config.FrameType,   // ← 設定値から取得（ハードコードなし）
        config.Timeout      // ← 設定値から取得（ハードコードなし）
    );
    return frame;
}

public string BuildReadRandomFrameFromConfigAscii(TargetDeviceConfig config)
{
    string asciiFrame = SlmpFrameBuilder.BuildReadRandomRequestAscii(
        deviceSpecifications,
        config.FrameType,   // ← 設定値から取得（ハードコードなし）
        config.Timeout      // ← 設定値から取得（ハードコードなし）
    );
    return asciiFrame;
}
```

#### オーバーロード2: PlcConfiguration版（ハードコード継続中）
```csharp
public byte[] BuildReadRandomFrameFromConfig(PlcConfiguration config)
{
    byte[] frame = SlmpFrameBuilder.BuildReadRandomRequest(
        config.Devices,
        frameType: "4E",  // ← ハードコード（要対応）
        timeout: 32       // ← ハードコード（要対応）
    );
    return frame;
}

public string BuildReadRandomFrameFromConfigAscii(PlcConfiguration config)
{
    string asciiFrame = SlmpFrameBuilder.BuildReadRandomRequestAscii(
        config.Devices,
        frameType: "4E",  // ← ハードコード（要対応）
        timeout: 32       // ← ハードコード（要対応）
    );
    return asciiFrame;
}
```

**ハードコード箇所**: ConfigToFrameManager.cs:123, 124, 149, 150

---

## 3. 実装例とヘルパーメソッド

### 3.1 ConfigurationLoader.cs での実装イメージ

```csharp
public PlcConfiguration LoadFromExcel(string filePath)
{
    var config = new PlcConfiguration();

    // 必須項目（既定値なし）
    config.IpAddress = GetRequiredValue<string>(excel, "IPAddress");
    config.Port = GetRequiredValue<int>(excel, "Port");

    // PlcIdは自動生成
    config.PlcId = $"{config.IpAddress}_{config.Port}";

    // オプション項目（既定値あり）
    config.ConnectionMethod = GetOptionalValue(excel, "ConnectionMethod", "UDP");
    config.FrameVersion = GetOptionalValue(excel, "FrameVersion", "4E");
    config.Timeout = GetOptionalValue(excel, "Timeout", 1000);
    config.IsBinary = GetOptionalValue(excel, "IsBinary", true);
    config.MonitoringIntervalMs = GetOptionalValue(excel, "MonitoringIntervalMs", 1000);

    // オプション項目（既定値なし）
    config.PlcName = GetOptionalValue(excel, "PlcName", null) ?? config.PlcId;

    return config;
}

private T GetRequiredValue<T>(ExcelData excel, string key)
{
    var value = excel.GetValue<T>(key);
    if (value == null)
    {
        throw new ArgumentException($"必須項目 '{key}' が設定ファイルに存在しません。");
    }
    return value;
}

private T GetOptionalValue<T>(ExcelData excel, string key, T defaultValue)
{
    return excel.TryGetValue(key, out T value) ? value : defaultValue;
}
```

### 3.2 ヘルパーメソッド詳細

#### ParseIntOrDefault
```csharp
private int ParseIntOrDefault(string value, int defaultValue)
{
    if (string.IsNullOrWhiteSpace(value))
        return defaultValue;

    return int.TryParse(value, out int result) ? result : defaultValue;
}
```

#### ParseBoolOrDefault
```csharp
private bool ParseBoolOrDefault(string value, bool defaultValue)
{
    if (string.IsNullOrWhiteSpace(value))
        return defaultValue;

    if (bool.TryParse(value, out bool result))
        return result;

    // "1"/"0" 形式のサポート
    if (value == "1" || value.ToLower() == "true")
        return true;
    if (value == "0" || value.ToLower() == "false")
        return false;

    return defaultValue;
}
```

#### Timeoutミリ秒→SLMP単位変換
```csharp
// SLMPのTimeoutは250ms単位（例: 8000ms = 32単位）
private ushort ConvertTimeoutToSlmpUnits(int timeoutMs)
{
    return (ushort)(timeoutMs / 250);
}
```

---

## 4. TDD実装手順（Phase別）

**⚠️ 重要: 本プロジェクトはTDD（Test-Driven Development）を採用しています**

各Phaseで以下のサイクルを厳守してください：
1. **Red**: 失敗するテストを先に書く
2. **Green**: テストを通すための最小限のコードを実装
3. **Refactor**: 動作を保ったままコードを改善

### Phase 1: 既定値の定義（TDD）

**目的**: 既定値を定数として定義し、コード全体で統一的に使用

#### Step 1-1: Red - テストを先に書く

**テストファイル**: `Tests/Unit/Core/Constants/DefaultValuesTests.cs`

```csharp
using Xunit;
using Andon.Core.Constants;

namespace Andon.Tests.Unit.Core.Constants
{
    public class DefaultValuesTests
    {
        [Fact]
        public void ConnectionMethod_ShouldBeUDP()
        {
            Assert.Equal("UDP", DefaultValues.ConnectionMethod);
        }

        [Fact]
        public void FrameVersion_ShouldBe4E()
        {
            Assert.Equal("4E", DefaultValues.FrameVersion);
        }

        [Fact]
        public void TimeoutMs_ShouldBe1000()
        {
            Assert.Equal(1000, DefaultValues.TimeoutMs);
        }

        [Fact]
        public void TimeoutSlmp_ShouldBe4()
        {
            Assert.Equal((ushort)4, DefaultValues.TimeoutSlmp);
        }

        [Fact]
        public void IsBinary_ShouldBeTrue()
        {
            Assert.True(DefaultValues.IsBinary);
        }

        [Fact]
        public void MonitoringIntervalMs_ShouldBe1000()
        {
            Assert.Equal(1000, DefaultValues.MonitoringIntervalMs);
        }
    }
}
```

**実行**: テストを実行 → **失敗することを確認**（Redステップ完了）

#### Step 1-2: Green - 最小限の実装

**実装ファイル**: `andon/Core/Constants/DefaultValues.cs`

```csharp
namespace Andon.Core.Constants
{
    public static class DefaultValues
    {
        // 接続設定
        public const string ConnectionMethod = "UDP";

        // SLMP設定
        public const string FrameVersion = "4E";
        public const int TimeoutMs = 1000;  // ミリ秒
        public const ushort TimeoutSlmp = 4;  // SLMP単位（1000ms / 250）
        public const bool IsBinary = true;

        // データ処理設定
        public const int MonitoringIntervalMs = 1000;
    }
}
```

**実行**: テストを実行 → **成功することを確認**（Greenステップ完了）

#### Step 1-3: Refactor - リファクタリング

- コメントの追加・整理
- 定数のグルーピング確認
- 命名規則の統一

**実行**: テストを実行 → **引き続き成功することを確認**（Refactorステップ完了）

#### 成功条件
- [x] 失敗するテストを先に書いた（Red）
- [x] テストを通す最小実装を行った（Green）
- [x] リファクタリングを実施した（Refactor）
- [x] 全テストがパス
- [x] ビルドが成功

---

### Phase 2: 設定読み込みロジックの実装（TDD）

**目的**: ConfigurationLoaderExcelを拡張し、B10-B15セルから追加項目を読み込む

#### Step 2-1: Red - テストを先に書く

**テストファイル**: `Tests/Unit/Infrastructure/Configuration/ConfigurationLoaderExcelTests.cs`

```csharp
using Xunit;
using Andon.Infrastructure.Configuration;
using Moq;

namespace Andon.Tests.Unit.Infrastructure.Configuration
{
    public class ConfigurationLoaderExcelTests
    {
        [Fact]
        public void LoadFromExcel_WhenConnectionMethodIsEmpty_ShouldUseDefaultUDP()
        {
            // Arrange
            var mockExcelData = CreateMockExcelData(connectionMethod: "");
            var loader = new ConfigurationLoaderExcel();

            // Act
            var config = loader.LoadFromExcel(mockExcelData);

            // Assert
            Assert.Equal("UDP", config.ConnectionMethod);
        }

        [Fact]
        public void LoadFromExcel_WhenFrameVersionIsEmpty_ShouldUseDefault4E()
        {
            // Arrange
            var mockExcelData = CreateMockExcelData(frameVersion: "");
            var loader = new ConfigurationLoaderExcel();

            // Act
            var config = loader.LoadFromExcel(mockExcelData);

            // Assert
            Assert.Equal("4E", config.FrameVersion);
        }

        [Fact]
        public void LoadFromExcel_WhenTimeoutIsEmpty_ShouldUseDefault1000Ms()
        {
            // Arrange
            var mockExcelData = CreateMockExcelData(timeout: "");
            var loader = new ConfigurationLoaderExcel();

            // Act
            var config = loader.LoadFromExcel(mockExcelData);

            // Assert
            Assert.Equal(1000, config.Timeout * 250); // SLMP単位からミリ秒に変換
        }

        [Fact]
        public void LoadFromExcel_WhenIsBinaryIsEmpty_ShouldUseDefaultTrue()
        {
            // Arrange
            var mockExcelData = CreateMockExcelData(isBinary: "");
            var loader = new ConfigurationLoaderExcel();

            // Act
            var config = loader.LoadFromExcel(mockExcelData);

            // Assert
            Assert.True(config.IsBinary);
        }

        [Fact]
        public void LoadFromExcel_WhenMonitoringIntervalMsIsEmpty_ShouldUseDefault1000Ms()
        {
            // Arrange
            var mockExcelData = CreateMockExcelData(monitoringIntervalMs: "");
            var loader = new ConfigurationLoaderExcel();

            // Act
            var config = loader.LoadFromExcel(mockExcelData);

            // Assert
            Assert.Equal(1000, config.MonitoringIntervalMs);
        }

        [Fact]
        public void LoadFromExcel_ShouldGeneratePlcIdFromIpAndPort()
        {
            // Arrange
            var mockExcelData = CreateMockExcelData(ipAddress: "192.168.1.10", port: "8192");
            var loader = new ConfigurationLoaderExcel();

            // Act
            var config = loader.LoadFromExcel(mockExcelData);

            // Assert
            Assert.Equal("192.168.1.10_8192", config.PlcId);
        }

        [Fact]
        public void LoadFromExcel_WhenPlcNameIsEmpty_ShouldUsePlcId()
        {
            // Arrange
            var mockExcelData = CreateMockExcelData(ipAddress: "192.168.1.10", port: "8192", plcName: "");
            var loader = new ConfigurationLoaderExcel();

            // Act
            var config = loader.LoadFromExcel(mockExcelData);

            // Assert
            Assert.Equal(config.PlcId, config.PlcName);
        }

        [Fact]
        public void ParseIntOrDefault_WhenValueIsEmpty_ShouldReturnDefault()
        {
            // Arrange
            var loader = new ConfigurationLoaderExcel();

            // Act
            var result = loader.ParseIntOrDefault("", 1000);

            // Assert
            Assert.Equal(1000, result);
        }

        [Fact]
        public void ParseBoolOrDefault_WhenValueIs1_ShouldReturnTrue()
        {
            // Arrange
            var loader = new ConfigurationLoaderExcel();

            // Act
            var result = loader.ParseBoolOrDefault("1", false);

            // Assert
            Assert.True(result);
        }

        [Fact]
        public void ParseBoolOrDefault_WhenValueIs0_ShouldReturnFalse()
        {
            // Arrange
            var loader = new ConfigurationLoaderExcel();

            // Act
            var result = loader.ParseBoolOrDefault("0", true);

            // Assert
            Assert.False(result);
        }

        private MockExcelData CreateMockExcelData(
            string ipAddress = "192.168.1.10",
            string port = "8192",
            string connectionMethod = "UDP",
            string frameVersion = "4E",
            string timeout = "1000",
            string isBinary = "true",
            string monitoringIntervalMs = "1000",
            string plcName = "TestPLC")
        {
            // モックExcelデータを作成
            return new MockExcelData
            {
                ["B8"] = ipAddress,
                ["B9"] = port,
                ["B10"] = connectionMethod,
                ["B11"] = frameVersion,
                ["B12"] = timeout,
                ["B13"] = isBinary,
                ["B14"] = monitoringIntervalMs,
                ["B15"] = plcName
            };
        }
    }
}
```

**実行**: テストを実行 → **失敗することを確認**（Redステップ完了）

#### Step 2-2: Green - 最小限の実装

**実装ファイル**: `andon/Infrastructure/Configuration/ConfigurationLoaderExcel.cs`

```csharp
// GetRequiredValue / GetOptionalValue メソッドを追加
private T GetRequiredValue<T>(ExcelWorksheet sheet, string cellAddress, string itemName)
{
    var value = sheet.Cells[cellAddress].Text;
    if (string.IsNullOrWhiteSpace(value))
    {
        throw new ArgumentException($"必須項目 '{itemName}' が設定ファイルに存在しません。");
    }
    return (T)Convert.ChangeType(value, typeof(T));
}

private T GetOptionalValue<T>(ExcelWorksheet sheet, string cellAddress, T defaultValue)
{
    var value = sheet.Cells[cellAddress].Text;
    if (string.IsNullOrWhiteSpace(value))
        return defaultValue;

    try
    {
        return (T)Convert.ChangeType(value, typeof(T));
    }
    catch
    {
        return defaultValue;
    }
}

// ヘルパーメソッド追加
public int ParseIntOrDefault(string value, int defaultValue)
{
    if (string.IsNullOrWhiteSpace(value))
        return defaultValue;

    return int.TryParse(value, out int result) ? result : defaultValue;
}

public bool ParseBoolOrDefault(string value, bool defaultValue)
{
    if (string.IsNullOrWhiteSpace(value))
        return defaultValue;

    if (bool.TryParse(value, out bool result))
        return result;

    // "1"/"0" 形式のサポート
    if (value == "1" || value.ToLower() == "true")
        return true;
    if (value == "0" || value.ToLower() == "false")
        return false;

    return defaultValue;
}

// LoadFromExcel メソッドを拡張
private PlcConfiguration LoadFromExcel(string filePath)
{
    // ... 既存コード ...

    // 【新規追加】追加項目の読み込み
    string connectionMethod = GetOptionalValue(settingsSheet, "B10", DefaultValues.ConnectionMethod);
    string frameVersion = GetOptionalValue(settingsSheet, "B11", DefaultValues.FrameVersion);
    int timeoutMs = ParseIntOrDefault(settingsSheet.Cells["B12"].Text, DefaultValues.TimeoutMs);
    bool isBinary = ParseBoolOrDefault(settingsSheet.Cells["B13"].Text, DefaultValues.IsBinary);
    int monitoringIntervalMs = ParseIntOrDefault(settingsSheet.Cells["B14"].Text, DefaultValues.MonitoringIntervalMs);
    string? plcName = settingsSheet.Cells["B15"].Text;

    // PlcIdの自動生成
    string plcId = $"{ipAddress}_{port}";

    var config = new PlcConfiguration
    {
        IpAddress = ipAddress,
        Port = port,
        ConnectionMethod = connectionMethod,
        FrameVersion = frameVersion,
        Timeout = (ushort)(timeoutMs / 250),  // SLMP単位に変換
        IsBinary = isBinary,
        MonitoringIntervalMs = monitoringIntervalMs,
        PlcId = plcId,
        PlcName = string.IsNullOrWhiteSpace(plcName) ? plcId : plcName,
        Devices = ReadDevices(devicesSheet, filePath)
    };

    return config;
}
```

**実行**: テストを実行 → **成功することを確認**（Greenステップ完了）

#### Step 2-3: Refactor - リファクタリング

- 重複コードの削除
- メソッドの分離
- エラーハンドリングの改善

**実行**: テストを実行 → **引き続き成功することを確認**（Refactorステップ完了）

#### 成功条件
- [x] 失敗するテストを先に書いた（Red）
- [x] テストを通す最小実装を行った（Green）
- [x] リファクタリングを実施した（Refactor）
- [x] 全テストがパス
- [x] ビルドが成功

---

### Phase 3: 検証ロジックの実装（TDD）

**目的**: 設定値の妥当性を検証し、エラーメッセージを統一管理

#### Step 3-1: Red - テストを先に書く

**テストファイル**: `Tests/Unit/Infrastructure/Configuration/SettingsValidatorTests.cs`

```csharp
using Xunit;
using Andon.Infrastructure.Configuration;
using System;

namespace Andon.Tests.Unit.Infrastructure.Configuration
{
    public class SettingsValidatorTests
    {
        private readonly SettingsValidator _validator;

        public SettingsValidatorTests()
        {
            _validator = new SettingsValidator();
        }

        [Theory]
        [InlineData("192.168.1.10")]
        [InlineData("172.30.40.15")]
        [InlineData("10.0.0.1")]
        public void ValidateIpAddress_WhenValidFormat_ShouldNotThrow(string ipAddress)
        {
            // Act & Assert
            var exception = Record.Exception(() => _validator.ValidateIpAddress(ipAddress));
            Assert.Null(exception);
        }

        [Theory]
        [InlineData("")]
        [InlineData(null)]
        [InlineData("   ")]
        public void ValidateIpAddress_WhenEmpty_ShouldThrowArgumentException(string ipAddress)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => _validator.ValidateIpAddress(ipAddress));
            Assert.Contains("必須項目 'IPAddress'", exception.Message);
        }

        [Theory]
        [InlineData("999.999.999.999")]
        [InlineData("abc.def.ghi.jkl")]
        [InlineData("192.168.1")]
        public void ValidateIpAddress_WhenInvalidFormat_ShouldThrowArgumentException(string ipAddress)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => _validator.ValidateIpAddress(ipAddress));
            Assert.Contains("IPAddressの形式が不正です", exception.Message);
        }

        [Fact]
        public void ValidateIpAddress_When0000_ShouldThrowArgumentException()
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => _validator.ValidateIpAddress("0.0.0.0"));
            Assert.Contains("IPAddress '0.0.0.0' は使用できません", exception.Message);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(8192)]
        [InlineData(65535)]
        public void ValidatePort_WhenInRange_ShouldNotThrow(int port)
        {
            // Act & Assert
            var exception = Record.Exception(() => _validator.ValidatePort(port));
            Assert.Null(exception);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(-1)]
        [InlineData(70000)]
        public void ValidatePort_WhenOutOfRange_ShouldThrowArgumentException(int port)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => _validator.ValidatePort(port));
            Assert.Contains("Portの値が範囲外です", exception.Message);
        }

        [Theory]
        [InlineData("TCP")]
        [InlineData("UDP")]
        [InlineData("tcp")]
        [InlineData("udp")]
        public void ValidateConnectionMethod_WhenValid_ShouldNotThrow(string connectionMethod)
        {
            // Act & Assert
            var exception = Record.Exception(() => _validator.ValidateConnectionMethod(connectionMethod));
            Assert.Null(exception);
        }

        [Theory]
        [InlineData("HTTP")]
        [InlineData("FTP")]
        [InlineData("")]
        public void ValidateConnectionMethod_WhenInvalid_ShouldThrowArgumentException(string connectionMethod)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => _validator.ValidateConnectionMethod(connectionMethod));
            Assert.Contains("ConnectionMethodの値が不正です", exception.Message);
        }

        [Theory]
        [InlineData("3E")]
        [InlineData("4E")]
        [InlineData("3e")]
        [InlineData("4e")]
        public void ValidateFrameVersion_WhenValid_ShouldNotThrow(string frameVersion)
        {
            // Act & Assert
            var exception = Record.Exception(() => _validator.ValidateFrameVersion(frameVersion));
            Assert.Null(exception);
        }

        [Theory]
        [InlineData("5E")]
        [InlineData("2E")]
        [InlineData("")]
        public void ValidateFrameVersion_WhenInvalid_ShouldThrowArgumentException(string frameVersion)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => _validator.ValidateFrameVersion(frameVersion));
            Assert.Contains("FrameVersionの値が不正です", exception.Message);
        }

        [Theory]
        [InlineData(100)]
        [InlineData(1000)]
        [InlineData(30000)]
        public void ValidateTimeout_WhenInRange_ShouldNotThrow(int timeoutMs)
        {
            // Act & Assert
            var exception = Record.Exception(() => _validator.ValidateTimeout(timeoutMs));
            Assert.Null(exception);
        }

        [Theory]
        [InlineData(50)]
        [InlineData(40000)]
        public void ValidateTimeout_WhenOutOfRange_ShouldThrowArgumentException(int timeoutMs)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => _validator.ValidateTimeout(timeoutMs));
            Assert.Contains("Timeoutの値が範囲外です", exception.Message);
        }

        [Theory]
        [InlineData(100)]
        [InlineData(1000)]
        [InlineData(60000)]
        public void ValidateMonitoringIntervalMs_WhenInRange_ShouldNotThrow(int intervalMs)
        {
            // Act & Assert
            var exception = Record.Exception(() => _validator.ValidateMonitoringIntervalMs(intervalMs));
            Assert.Null(exception);
        }

        [Theory]
        [InlineData(50)]
        [InlineData(70000)]
        public void ValidateMonitoringIntervalMs_WhenOutOfRange_ShouldThrowArgumentException(int intervalMs)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => _validator.ValidateMonitoringIntervalMs(intervalMs));
            Assert.Contains("MonitoringIntervalMsの値が範囲外です", exception.Message);
        }
    }
}
```

**実行**: テストを実行 → **失敗することを確認**（Redステップ完了）

#### Step 3-2: Green - 最小限の実装

**実装ファイル**: `andon/Infrastructure/Configuration/SettingsValidator.cs`

```csharp
using System;
using System.Linq;
using System.Net;

namespace Andon.Infrastructure.Configuration
{
    public class SettingsValidator
    {
        public void ValidateIpAddress(string ipAddress)
        {
            if (string.IsNullOrWhiteSpace(ipAddress))
                throw new ArgumentException("必須項目 'IPAddress' が設定ファイルに存在しません。");

            if (!IPAddress.TryParse(ipAddress, out var parsedIp))
                throw new ArgumentException($"IPAddressの形式が不正です: '{ipAddress}'");

            if (parsedIp.ToString() == "0.0.0.0")
                throw new ArgumentException("IPAddress '0.0.0.0' は使用できません。");
        }

        public void ValidatePort(int port)
        {
            if (port < 1 || port > 65535)
                throw new ArgumentException($"Portの値が範囲外です: {port} (許可範囲: 1～65535)");
        }

        public void ValidateConnectionMethod(string connectionMethod)
        {
            var validMethods = new[] { "TCP", "UDP" };
            if (!validMethods.Contains(connectionMethod.ToUpper()))
                throw new ArgumentException($"ConnectionMethodの値が不正です: '{connectionMethod}' (許可値: TCP, UDP)");
        }

        public void ValidateFrameVersion(string frameVersion)
        {
            var validVersions = new[] { "3E", "4E" };
            if (!validVersions.Contains(frameVersion.ToUpper()))
                throw new ArgumentException($"FrameVersionの値が不正です: '{frameVersion}' (許可値: 3E, 4E)");
        }

        public void ValidateTimeout(int timeoutMs)
        {
            if (timeoutMs < 100 || timeoutMs > 30000)
                throw new ArgumentException($"Timeoutの値が範囲外です: {timeoutMs} (推奨範囲: 100～30000)");
        }

        public void ValidateMonitoringIntervalMs(int intervalMs)
        {
            if (intervalMs < 100 || intervalMs > 60000)
                throw new ArgumentException($"MonitoringIntervalMsの値が範囲外です: {intervalMs} (推奨範囲: 100～60000)");
        }
    }
}
```

**実行**: テストを実行 → **成功することを確認**（Greenステップ完了）

#### Step 3-3: Refactor - リファクタリング

- エラーメッセージの定数化
- 検証ルールの共通化
- コードの可読性向上

**実行**: テストを実行 → **引き続き成功することを確認**（Refactorステップ完了）

#### 成功条件
- [x] 失敗するテストを先に書いた（Red）
- [x] テストを通す最小実装を行った（Green）
- [x] リファクタリングを実施した（Refactor）
- [x] 全テストがパス
- [x] ビルドが成功

---

### Phase 4: 既存コードの修正（TDD）

**目的**: ハードコード箇所を設定ファイル読み込みに変更

#### Step 4-1: Red - テストを先に書く

**テストファイル**: `Tests/Unit/Core/Managers/ConfigToFrameManagerTests.cs`

```csharp
using Xunit;
using Andon.Core.Managers;
using Andon.Core.Models.ConfigModels;
using System.Collections.Generic;

namespace Andon.Tests.Unit.Core.Managers
{
    public class ConfigToFrameManagerTests
    {
        [Fact]
        public void BuildReadRandomFrameFromConfig_ShouldUseFrameVersionFromConfig()
        {
            // Arrange
            var config = new PlcConfiguration
            {
                FrameVersion = "3E",
                Timeout = 4,
                Devices = new List<DeviceSpecification>()
            };
            var manager = new ConfigToFrameManager();

            // Act
            var frame = manager.BuildReadRandomFrameFromConfig(config);

            // Assert
            // 3Eフレームの場合、サブヘッダは0x50, 0x00
            Assert.Equal(0x50, frame[0]);
            Assert.Equal(0x00, frame[1]);
        }

        [Fact]
        public void BuildReadRandomFrameFromConfig_ShouldUseTimeoutFromConfig()
        {
            // Arrange
            var config = new PlcConfiguration
            {
                FrameVersion = "4E",
                Timeout = 8,  // 2000ms
                Devices = new List<DeviceSpecification>()
            };
            var manager = new ConfigToFrameManager();

            // Act
            var frame = manager.BuildReadRandomFrameFromConfig(config);

            // Assert
            // タイムアウト値が正しく設定されているか確認
            // 4Eフレームの場合、タイムアウトは13-14バイト目
            Assert.Equal(0x08, frame[13]);
            Assert.Equal(0x00, frame[14]);
        }

        [Fact]
        public void BuildReadRandomFrameFromConfigAscii_ShouldUseFrameVersionFromConfig()
        {
            // Arrange
            var config = new PlcConfiguration
            {
                FrameVersion = "3E",
                Timeout = 4,
                Devices = new List<DeviceSpecification>()
            };
            var manager = new ConfigToFrameManager();

            // Act
            var asciiFrame = manager.BuildReadRandomFrameFromConfigAscii(config);

            // Assert
            // 3EフレームASCII形式の場合、サブヘッダは"50"
            Assert.StartsWith("50", asciiFrame);
        }

        [Fact]
        public void BuildReadRandomFrameFromConfigAscii_ShouldUseTimeoutFromConfig()
        {
            // Arrange
            var config = new PlcConfiguration
            {
                FrameVersion = "4E",
                Timeout = 8,  // 2000ms
                Devices = new List<DeviceSpecification>()
            };
            var manager = new ConfigToFrameManager();

            // Act
            var asciiFrame = manager.BuildReadRandomFrameFromConfigAscii(config);

            // Assert
            // タイムアウト値が正しく設定されているか確認
            Assert.Contains("0008", asciiFrame);
        }
    }
}
```

**実行**: テストを実行 → **失敗することを確認**（Redステップ完了）

#### Step 4-2: Green - 最小限の実装

**実装ファイル1**: `andon/Core/Models/ConfigModels/PlcConfiguration.cs`

```csharp
public class PlcConfiguration
{
    // 接続設定
    public string IpAddress { get; set; } = string.Empty;
    public int Port { get; set; }
    public string ConnectionMethod { get; set; } = "UDP";

    // SLMP設定
    public string FrameVersion { get; set; } = "4E";
    public ushort Timeout { get; set; } = 4;  // SLMP単位（1000ms / 250）
    public bool IsBinary { get; set; } = true;

    // PLC識別情報
    public string PlcId { get; set; } = string.Empty;
    public string? PlcName { get; set; }

    // データ処理設定
    public int MonitoringIntervalMs { get; set; } = 1000;

    // 既存プロパティ
    public int DataReadingFrequency { get; set; }
    public string PlcModel { get; set; } = string.Empty;
    public string SavePath { get; set; } = string.Empty;
    public string SourceExcelFile { get; set; } = string.Empty;
    public string ConfigurationName { get; }
    public List<DeviceSpecification> Devices { get; set; } = new();
}
```

**実装ファイル2**: `andon/Core/Managers/ConfigToFrameManager.cs`

```csharp
public byte[] BuildReadRandomFrameFromConfig(PlcConfiguration config)
{
    // PlcConfigurationから取得（ハードコード削除）
    byte[] frame = SlmpFrameBuilder.BuildReadRandomRequest(
        config.Devices,
        frameType: config.FrameVersion,  // ← Excel設定から取得
        timeout: config.Timeout          // ← Excel設定から取得
    );
    return frame;
}

public string BuildReadRandomFrameFromConfigAscii(PlcConfiguration config)
{
    // PlcConfigurationから取得（ハードコード削除）
    string asciiFrame = SlmpFrameBuilder.BuildReadRandomRequestAscii(
        config.Devices,
        frameType: config.FrameVersion,  // ← Excel設定から取得
        timeout: config.Timeout          // ← Excel設定から取得
    );
    return asciiFrame;
}
```

**実行**: テストを実行 → **成功することを確認**（Greenステップ完了）

#### Step 4-3: Refactor - リファクタリング

- Priorityプロパティの削除（不要項目）
- プロパティの整理
- コメントの改善

**実行**: テストを実行 → **引き続き成功することを確認**（Refactorステップ完了）

#### 成功条件
- [x] 失敗するテストを先に書いた（Red）
- [x] テストを通す最小実装を行った（Green）
- [x] リファクタリングを実施した（Refactor）
- [x] 全テストがパス
- [x] 既存テストも引き続き全てパス
- [x] ビルドが成功

---

### Phase 5: 統合テスト（TDD）

**目的**: 全Phase統合後の動作確認

#### Step 5-1: Red - 統合テストを先に書く

**テストファイル**: `Tests/Integration/HardcodeReplacement_IntegrationTests.cs`

```csharp
using Xunit;
using Andon.Infrastructure.Configuration;
using Andon.Core.Managers;
using System.IO;

namespace Andon.Tests.Integration
{
    public class HardcodeReplacement_IntegrationTests
    {
        [Fact]
        public void EndToEnd_LoadConfigFromExcel_BuildFrame_ShouldUseConfigValues()
        {
            // Arrange
            var testExcelPath = Path.Combine("TestData", "test_config.xlsx");
            var loader = new ConfigurationLoaderExcel();
            var frameManager = new ConfigToFrameManager();

            // Act
            var config = loader.LoadFromExcel(testExcelPath);
            var frame = frameManager.BuildReadRandomFrameFromConfig(config);

            // Assert
            Assert.NotNull(config);
            Assert.Equal("192.168.1.10", config.IpAddress);
            Assert.Equal(8192, config.Port);
            Assert.Equal("UDP", config.ConnectionMethod);
            Assert.Equal("4E", config.FrameVersion);
            Assert.Equal((ushort)4, config.Timeout);
            Assert.True(config.IsBinary);
            Assert.Equal(1000, config.MonitoringIntervalMs);
            Assert.Equal("192.168.1.10_8192", config.PlcId);

            Assert.NotNull(frame);
            Assert.NotEmpty(frame);
        }

        [Fact]
        public void EndToEnd_LoadConfigWithEmptyOptionalValues_ShouldUseDefaults()
        {
            // Arrange
            var testExcelPath = Path.Combine("TestData", "test_config_minimal.xlsx");
            var loader = new ConfigurationLoaderExcel();

            // Act
            var config = loader.LoadFromExcel(testExcelPath);

            // Assert
            Assert.Equal("UDP", config.ConnectionMethod);  // デフォルト値
            Assert.Equal("4E", config.FrameVersion);       // デフォルト値
            Assert.Equal((ushort)4, config.Timeout);       // デフォルト値（1000ms / 250）
            Assert.True(config.IsBinary);                   // デフォルト値
            Assert.Equal(1000, config.MonitoringIntervalMs); // デフォルト値
        }

        [Fact]
        public void EndToEnd_LoadConfigWithInvalidIpAddress_ShouldThrowException()
        {
            // Arrange
            var testExcelPath = Path.Combine("TestData", "test_config_invalid_ip.xlsx");
            var loader = new ConfigurationLoaderExcel();

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => loader.LoadFromExcel(testExcelPath));
            Assert.Contains("IPAddressの形式が不正です", exception.Message);
        }
    }
}
```

**実行**: テストを実行 → **失敗することを確認**（Redステップ完了）

#### Step 5-2: Green - 統合確認

- Phase 1-4の実装が正しく統合されていることを確認
- 必要に応じて調整

**実行**: テストを実行 → **成功することを確認**（Greenステップ完了）

#### Step 5-3: Refactor - 最終調整

- パフォーマンス最適化
- エラーハンドリングの改善
- ドキュメントの更新

**実行**: テストを実行 → **引き続き成功することを確認**（Refactorステップ完了）

#### 成功条件
- [x] 統合テストを先に書いた（Red）
- [x] 統合テストがパスした（Green）
- [x] 最終調整を実施した（Refactor）
- [x] 全テスト（単体テスト + 統合テスト）がパス
- [x] 既存テストも引き続き全てパス
- [x] ビルドが成功

---

## 5. TDD Phase別実装状況

### Phase 1: 既定値の定義（TDD）

**実装状況**: ⚠️ **未実装**

**TDD実装チェック**:
- [ ] Red: 失敗するテストを先に書いた
- [ ] Green: テストを通す最小実装を行った
- [ ] Refactor: リファクタリングを実施した

**影響**:
- 既定値がコード内に散在している状態
- 統一的な管理ができていない
- **TDD原則**: テストファーストでの開発が必要

**次のアクション**:
1. `Tests/Unit/Core/Constants/DefaultValuesTests.cs` を作成（Red）
2. テストが失敗することを確認
3. `andon/Core/Constants/DefaultValues.cs` を実装（Green）
4. テストがパスすることを確認
5. リファクタリング実施（Refactor）

---

### Phase 2: 設定読み込みロジックの実装（TDD）

**実装状況**: ⚠️ **未実装**

**TDD実装チェック**:
- [ ] Red: 失敗するテストを先に書いた
- [ ] Green: テストを通す最小実装を行った
- [ ] Refactor: リファクタリングを実施した

**当初計画**:
- B10-B15セルから追加項目を読み込み
- ParseIntOrDefault/ParseBoolOrDefaultヘルパーメソッド追加

**実際の実装**:
- B8, B9, B11-B13のみ読み込み中（ただし用途が当初計画と異なる）
- B10, B14, B15は未使用
- ヘルパーメソッドは未実装

**影響**:
- PlcConfigurationに拡張プロパティが無いため、読み込む必要がない状態
- Excel設定ファイルの構造が当初計画と異なる
- **TDD原則**: テストファーストでの開発が必要

**次のアクション**:
1. `Tests/Unit/Infrastructure/Configuration/ConfigurationLoaderExcelTests.cs` を作成（Red）
2. テストが失敗することを確認
3. ConfigurationLoaderExcel.cs を拡張（Green）
4. テストがパスすることを確認
5. リファクタリング実施（Refactor）

---

### Phase 3: 検証ロジックの実装（TDD）

**実装状況**: ⚠️ **未実装**

**TDD実装チェック**:
- [ ] Red: 失敗するテストを先に書いた
- [ ] Green: テストを通す最小実装を行った
- [ ] Refactor: リファクタリングを実施した

**影響**:
- 不正な設定値のチェックができていない
- エラーメッセージが統一されていない
- **TDD原則**: テストファーストでの開発が必要

**次のアクション**:
1. `Tests/Unit/Infrastructure/Configuration/SettingsValidatorTests.cs` を作成（Red）
2. テストが失敗することを確認
3. SettingsValidator.cs を実装（Green）
4. テストがパスすることを確認
5. リファクタリング実施（Refactor）

---

### Phase 4: 既存コードの修正（TDD）

**実装状況**: 🟡 **部分実装**

**TDD実装チェック**:
- [ ] Red: 失敗するテストを先に書いた
- [ ] Green: テストを通す最小実装を行った
- [ ] Refactor: リファクタリングを実施した

**実装済み**:
- ✅ TargetDeviceConfig版: ハードコード解消済み（config.FrameType, config.Timeout使用）
- ⚠️ **テストファーストでの実装ではない可能性**

**未実装**:
- ⚠️ PlcConfiguration版: ハードコード継続中（固定値"4E", 32使用）

**理由**:
- PlcConfigurationにFrameVersion/Timeoutプロパティが存在しないため
- Phase 1が未完了のため、Phase 4のPlcConfiguration版対応ができない状態
- **TDD原則違反**: テストを先に書いていない可能性

**次のアクション**:
1. `Tests/Unit/Core/Managers/ConfigToFrameManagerTests.cs` を作成（Red）
2. テストが失敗することを確認
3. PlcConfiguration.cs にプロパティ追加（Green）
4. ConfigToFrameManager.cs のハードコード削除（Green）
5. テストがパスすることを確認
6. リファクタリング実施（Refactor）

---

### Phase 5: 統合テスト（TDD）

**実装状況**: ⚠️ **未実装**

**TDD実装チェック**:
- [ ] Red: 統合テストを先に書いた
- [ ] Green: 統合テストがパスした
- [ ] Refactor: 最終調整を実施した

**理由**:
- Phase 1-4が未完了のため、統合テストも未実施
- **TDD原則**: 統合テストもテストファーストで実施する必要がある

**次のアクション**:
1. `Tests/Integration/HardcodeReplacement_IntegrationTests.cs` を作成（Red）
2. テストが失敗することを確認
3. Phase 1-4の実装を統合（Green）
4. テストがパスすることを確認
5. 最終調整実施（Refactor）

---

### TDD実装の重要ポイント

**⚠️ 必ず守ること**:
1. **テストファースト**: 実装前に必ずテストを書く
2. **Red-Green-Refactorサイクル**: 各ステップを確実に実施
3. **小さなステップ**: 一度に一つの機能のみ実装
4. **テストで保護**: リファクタリング前後でテストが通ることを確認
5. **境界値テスト**: 境界付近の値でのバグを防ぐ

**実装時の注意**:
- 実装を始める前に、必ずテストを書いてRedステートを確認する
- テストがパスしたら（Green）、すぐにリファクタリング（Refactor）を検討する
- 既存テストが引き続き全てパスすることを確認する

---

## 6. ハードコード状況サマリー

### 6.1 ハードコード箇所一覧

| 対象メソッド | ファイル | 行番号 | ハードコード値 | 状況 |
|------------|---------|--------|--------------|------|
| BuildReadRandomFrameFromConfig(TargetDeviceConfig) | ConfigToFrameManager.cs | - | なし | ✅ 解消済み |
| BuildReadRandomFrameFromConfigAscii(TargetDeviceConfig) | ConfigToFrameManager.cs | - | なし | ✅ 解消済み |
| BuildReadRandomFrameFromConfig(PlcConfiguration) | ConfigToFrameManager.cs | 123, 124 | frameType: "4E", timeout: 32 | ⚠️ 継続中 |
| BuildReadRandomFrameFromConfigAscii(PlcConfiguration) | ConfigToFrameManager.cs | 149, 150 | frameType: "4E", timeout: 32 | ⚠️ 継続中 |

### 6.2 重複定義箇所

| 項目 | 箇所1 | 箇所2 | 状況 |
|-----|-------|-------|------|
| MonitoringIntervalMs = 5000 | DataProcessingConfig.cs:11 | DependencyInjectionConfigurator.cs:27 | ⚠️ 要対応 |

**対応方針**: 両方とも1000msに変更し、Excelファイルから取得された値で更新可能にする

---

## 7. 設計外クラス・メソッドの確認結果

### 7.1 設計文書との整合性

**プロジェクト構造設計.md との照合結果**:

| クラス名 | 設計文書記載 | 実装状況 | 備考 |
|---------|------------|---------|------|
| PlcConfiguration | ✅ あり（line 304） | ✅ 実装済み | 設計通り |
| TargetDeviceConfig | ✅ あり（line 306） | ✅ 実装済み | 設計通り |
| DeviceEntry | ✅ あり（line 308） | ✅ 実装済み | 設計通り |
| DeviceEntryInfo | ✅ あり（line 310） | ✅ 実装済み | 設計通り |
| PlcConnectionConfig | ✅ あり（line 319） | ✅ 実装済み | 複数PLC対応用として設計通り |
| MultiPlcConfig | ✅ あり（line 318） | ✅ 実装済み | 設計通り |
| ParallelProcessingConfig | ✅ あり（line 318） | ✅ 実装済み | 設計通り |
| **BitExpansionSettings** | ❌ なし | ✅ 実装済み | **設計外クラス**（ConMoni互換機能） |

### 7.2 設計外クラスの詳細

#### BitExpansionSettings

**実装ファイル**: `andon/Core/Models/ConfigModels/BitExpansionSettings.cs`

**目的**:
- ConMoniアプリケーションとの互換性確保
- ビット展開機能の設定

**プロパティ**:
```csharp
public class BitExpansionSettings
{
    public bool Enabled { get; set; }
    public ushort SelectionMask { get; set; }
    public Dictionary<int, double> ConversionFactors { get; set; }
}
```

**判定**: ⚠️ **設計外クラス**
- プロジェクト構造設計.md、クラス設計.md のいずれにも記載なし
- ConMoni互換機能として追加されたと推測

**推奨対応**:
- 設計文書に追記してドキュメント化
- または、機能が不要であれば削除を検討

---

## 8. 今後の実装方針（選択肢）

### 選択肢1: 現状維持＋ドキュメント更新

**方針**:
- TargetDeviceConfigとPlcConfigurationの2クラス併用を正式な設計として承認
- PlcConfiguration版ConfigToFrameManagerのハードコード値を残す
- 設計文書を現状に合わせて更新

**メリット**:
- 既存の動作を維持できる
- 追加実装が不要

**デメリット**:
- PlcConfiguration版がハードコード継続
- 設計の一貫性が低い

### 選択肢2: 当初計画通り実装（推奨）

**方針**:
- PlcConfigurationにFrameVersion, Timeout等のプロパティを追加（Phase 1-4実施）
- ConfigurationLoaderExcelを拡張してB10-B15を読み込み
- PlcConfiguration版ConfigToFrameManagerのハードコード解消

**メリット**:
- 設計の一貫性が高い
- ハードコード完全解消
- 既定値・検証ルールが明確

**デメリット**:
- 追加実装が必要（Phase 1-5）
- TargetDeviceConfigとの役割分担の再整理が必要

**推定工数**: 5-8時間

### 選択肢3: TargetDeviceConfig統一

**方針**:
- PlcConfigurationからFrameVersion/Timeoutの責務を完全にTargetDeviceConfigに移譲
- PlcConfiguration版ConfigToFrameManagerを廃止または、内部でTargetDeviceConfigに変換

**メリット**:
- 責務が明確に分離される
- ハードコード完全解消（既に達成済み）

**デメリット**:
- PlcConfiguration版ConfigToFrameManagerの利用箇所を調査・修正が必要
- 設計変更が大きい

---

## 9. TDD実装完了基準

### 9.1 Phase別TDD完了基準

#### Phase 1: 既定値の定義
- [ ] **Red**: DefaultValuesTests.cs を作成し、テストが失敗することを確認
- [ ] **Green**: DefaultValues.cs を実装し、テストがパスすることを確認
- [ ] **Refactor**: リファクタリングを実施し、テストが引き続きパスすることを確認
- [ ] **完了判定**: 全テストがパス、ビルドが成功

#### Phase 2: 設定読み込みロジックの実装
- [ ] **Red**: ConfigurationLoaderExcelTests.cs を作成し、テストが失敗することを確認
- [ ] **Green**: ConfigurationLoaderExcel.cs を拡張し、テストがパスすることを確認
- [ ] **Refactor**: リファクタリングを実施し、テストが引き続きパスすることを確認
- [ ] **完了判定**: 全テストがパス、ビルドが成功

#### Phase 3: 検証ロジックの実装
- [ ] **Red**: SettingsValidatorTests.cs を作成し、テストが失敗することを確認
- [ ] **Green**: SettingsValidator.cs を実装し、テストがパスすることを確認
- [ ] **Refactor**: リファクタリングを実施し、テストが引き続きパスすることを確認
- [ ] **完了判定**: 全テストがパス、ビルドが成功

#### Phase 4: 既存コードの修正
- [ ] **Red**: ConfigToFrameManagerTests.cs を作成し、テストが失敗することを確認
- [ ] **Green**: PlcConfiguration.cs と ConfigToFrameManager.cs を修正し、テストがパスすることを確認
- [ ] **Refactor**: リファクタリングを実施し、テストが引き続きパスすることを確認
- [x] **部分完了**: TargetDeviceConfig版ハードコード解消（⚠️テストファースト未実施）
- [ ] **完了判定**: 全テストがパス、既存テストも全てパス、ビルドが成功

#### Phase 5: 統合テスト
- [ ] **Red**: HardcodeReplacement_IntegrationTests.cs を作成し、テストが失敗することを確認
- [ ] **Green**: Phase 1-4の実装を統合し、テストがパスすることを確認
- [ ] **Refactor**: 最終調整を実施し、テストが引き続きパスすることを確認
- [ ] **完了判定**: 全テスト（単体 + 統合）がパス、ビルドが成功

### 9.2 TDD原則の遵守確認

**⚠️ 各Phase実装時に必ず確認すること**:
- [ ] テストを先に書いた（Red）
- [ ] 実装を後から行った（Green）
- [ ] リファクタリングを実施した（Refactor）
- [ ] 小さなステップで進めた
- [ ] 境界値テストを含めた
- [ ] 既存テストが引き続き全てパスしている

### 9.2 ハードコード状況

| 対象メソッド | ハードコード箇所 | 状況 |
|------------|----------------|------|
| BuildReadRandomFrameFromConfig(TargetDeviceConfig) | なし | ✅ 解消済み |
| BuildReadRandomFrameFromConfigAscii(TargetDeviceConfig) | なし | ✅ 解消済み |
| BuildReadRandomFrameFromConfig(PlcConfiguration) | frameType: "4E", timeout: 32 | ⚠️ 継続中 |
| BuildReadRandomFrameFromConfigAscii(PlcConfiguration) | frameType: "4E", timeout: 32 | ⚠️ 継続中 |

### 9.3 設計外クラス

- [ ] BitExpansionSettings のドキュメント化または削除判断

---

## 10. 参照ドキュメント

### 10.1 設計文書

- `documents/design/ハードコード実装置き換え対応/ハードコード状況確認.md`
- `documents/design/プロジェクト構造設計.md`
- `documents/design/クラス設計.md`

### 10.2 実装ファイル

- `andon/Core/Models/ConfigModels/PlcConfiguration.cs`
- `andon/Core/Models/ConfigModels/TargetDeviceConfig.cs`
- `andon/Core/Models/ConfigModels/PlcConnectionConfig.cs`
- `andon/Core/Models/ConfigModels/BitExpansionSettings.cs`
- `andon/Infrastructure/Configuration/ConfigurationLoaderExcel.cs`
- `andon/Core/Managers/ConfigToFrameManager.cs`

---

## 11. 変更履歴

| 日付 | バージョン | 変更内容 |
|------|-----------|---------|
| 2025-11-28 | 1.0 | 初版作成（現状反映版） |
| 2025-11-28 | 2.0 | 完全版作成（既定値・検証ルール・実装例を統合） |
| 2025-11-28 | 2.1 | 実装整合性チェック結果を反映（PlcConnectionConfig.Timeout型修正、デフォルト値設計意図追記） |
| 2025-11-28 | 2.2 | 正式な既定値仕様（ハードコード状況確認.md）を反映。FrameVersion="4E", Timeout=1000msが正式な既定値であることを明記 |
| 2025-11-28 | 2.3 | TimeoutConfig項目の既定値を追加（ConnectTimeoutMs=3000ms, SendTimeoutMs=500ms, ReceiveTimeoutMs=500ms, SendIntervalMs=100ms） |
| 2025-11-28 | 3.0 | **TDD準拠版**: Red-Green-Refactorサイクルに基づく実装手順に全面改訂。各Phaseに具体的なテストコード例を追加し、テストファースト開発を明示 |

---

## 12. 補足: クラス間のデフォルト値の違いについて

本プロジェクトでは、使用目的に応じて3つの設定クラスが存在し、それぞれ異なるデフォルト値を持っています:

### 12.1 クラス別のデフォルト値比較表（実装状況）

| 項目 | TargetDeviceConfig | PlcConnectionConfig | PlcConfiguration | **正式な既定値** |
|-----|-------------------|-------------------|-----------------|----------------|
| **FrameVersion/FrameType** | "4E" ✅ | "3E" ⚠️ | （未実装） | **"4E"** |
| **Timeout** | 32 (SLMP単位) ⚠️ | 8000ms ⚠️ | （未実装） | **1000ms (SLMP単位: 4)** |
| **状況** | FrameType正常 / Timeout要修正 | 両方とも要修正 | 未実装 | ハードコード状況確認.md参照 |

### 12.2 正式な既定値仕様（ハードコード状況確認.md）

**⚠️ 重要**: 以下の既定値が正式な仕様であり、厳守する必要があります。

#### 正式な既定値
- **FrameVersion**: `"4E"` （3Eではない）
- **Timeout**: `1000ms` （8000msではない）
  - SLMP単位換算: `4` （1000ms ÷ 250ms = 4）
  - 現在の実装値32 (8000ms相当)は暫定値

#### 現在の実装との差異

**TargetDeviceConfig**:
- `FrameType = "4E"` ✅ 正式な既定値と一致
- `Timeout = 32` ⚠️ 正式な既定値は4 (1000ms相当)、要修正

**PlcConnectionConfig**:
- `FrameVersion = "3E"` ⚠️ 正式な既定値は"4E"、要修正
- `Timeout = 8000` ⚠️ 正式な既定値は1000ms、要修正

**PlcConfiguration**:
- 未実装（Phase 1-4で実装予定）
- 実装時は必ず正式な既定値"4E"/1000msを使用すること

### 12.3 修正が必要な理由

**デバッグ効率化のため**:
- 意図しない既定値が混在すると、問題の切り分けが困難になる
- 全クラスで統一された既定値"4E"/1000msを使用することで、予期しない動作の原因特定が容易になる

**今後の対応**:
1. TargetDeviceConfig.Timeout: 32 → 4 に変更
2. PlcConnectionConfig.FrameVersion: "3E" → "4E" に変更
3. PlcConnectionConfig.Timeout: 8000 → 1000 に変更

---

**以上**
