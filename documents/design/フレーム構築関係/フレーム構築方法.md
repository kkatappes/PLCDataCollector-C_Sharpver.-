## 要求フレーム

### 3Eフレーム

| Idx | 長さ | 名称 | 内容(例) |
|-----|------|------|----------|
| 0 | 2 | サブヘッダ | 50 00（標準3E） |
| 2 | 1 | ネットワーク番号 | 00 |
| 3 | 1 | PC番号 | FF（全局） |
| 4 | 2 | ユニットI/O番号 | FF 03（LE） |
| 6 | 1 | 局番 | 00 |
| 7 | 2 | データ長 | 0C 00（12バイト、LE） |
| 9 | 2 | 監視タイマ | 00 00（無制限） |
| 11 | 2 | コマンド | 01 04（一括読出し、LE） |
| 13 | 2 | サブコマンド | 00 00（ワード単位、LE） |
| 15 | 1 | デバイスコード | B4（W:リンクレジスタ） |
| 16 | 3 | 開始デバイス | 00 00 00（W0、LE） |
| 19 | 2 | 読出し点数 | 01 00（1点、LE） |

### 4Eフレーム

| Idx | 長さ | 名称 | 内容(例) |
|-----|------|------|----------|
| 0 | 2 | サブヘッダ | 54 00（4E相当、固定） |
| 2 | 2 | シリアル | 00 00（予約） |
| 4 | 2 | 予約 | 00 00 |
| 6 | 1 | ネットワーク番号 | 00 |
| 7 | 1 | 局番 | FF（全局） |
| 8 | 2 | I/O番号 | FF 03（LE） |
| 10 | 1 | マルチドロップ | 00 |
| 11 | 2 | データ長 | 48 00（72バイト、LE） |
| 13 | 2 | 監視タイマ | 20 00（32=8秒、LE） |
| 15 | 2 | コマンド | 03 04（ランダム読出、LE） |
| 17 | 2 | サブコマンド | 00 00 |
| 19 | 1 | ワード点数 | 10（16点） |
| 20 | 1 | Dword点数 | 00（0点） |




## 応答フレーム

### 3Eフレーム（Binary形式）

| Idx | 長さ | 名称 | 内容(例) |
|-----|------|------|----------|
| 0 | 2 | サブヘッダ | D0 00（0xD0, 0x00: 3E Binary応答） |
| 2 | 1 | ネットワーク番号 | xx（設定値による） |
| 3 | 1 | PC番号 | FF |
| 4 | 2 | I/O番号 | FF 03（LE: 0x03FF） |
| 6 | 1 | 局番(マルチドロップ番号) | 00 |
| 7 | 2 | データ長 | 62 00（98バイト、LE） |
| 9 | 2 | 終了コード | 00 00（正常終了） |
| 11 | n | 読出しデータ | 96バイト（データ長98 - 終了コード2バイト） |

**パース時の注意**:
- ヘッダー部分: 0～8バイト目（9バイト = ネットワーク番号(1) + PC番号(1) + I/O番号(2) + 局番(1) + データ長(2) + 終了コード(2)）
- データ部開始位置: 11バイト目（サブヘッダ2バイト + ヘッダー9バイト）
- 実データ長 = データ長フィールド値 - 2（終了コード分を除く）

### 3Eフレーム（ASCII形式）

| Idx | 長さ | 名称 | 内容(例) |
|-----|------|------|----------|
| 0 | 2 | サブヘッダ | "D0"（ASCII: 3E応答） |
| 2 | 2 | ネットワーク番号 | "xx"（16進数2文字） |
| 4 | 2 | PC番号 | "FF" |
| 6 | 4 | I/O番号 | "03FF"（16進数4文字） |
| 10 | 2 | 局番(マルチドロップ番号) | "00" |
| 12 | 4 | データ長 | "0062"（16進数4文字、98バイト相当） |
| 16 | 4 | 終了コード | "0000"（正常終了） |
| 20 | n | 読出しデータ | 16進数文字列（データ長-4文字分） |

**パース時の注意**:
- ヘッダー部分: 2～19文字目（18文字 = ネットワーク(2) + PC(2) + I/O(4) + 局番(2) + データ長(4) + 終了コード(4)）
- データ部開始位置: 20文字目（サブヘッダ2文字 + ヘッダー18文字）
- 実データ長 = データ長フィールド値 - 4（終了コード4文字分を除く）

### 4Eフレーム（Binary形式）

| Idx | 長さ | 名称 | 内容(例) |
|-----|------|------|----------|
| 0 | 2 | サブヘッダ | D4 00（0xD4, 0x00: 4E Binary応答） |
| 2 | 2 | シーケンス番号 | 00 01（LE: 要求のエコーバック） |
| 4 | 2 | 予約 | 00 00（固定） |
| 6 | 1 | ネットワーク番号 | xx（設定値による） |
| 7 | 1 | PC番号 | FF |
| 8 | 2 | I/O番号 | FF 03（LE: 0x03FF） |
| 10 | 1 | 局番(マルチドロップ番号) | 00 |
| 11 | 2 | データ長 | 04 00（4バイト、LE） |
| 13 | 2 | 終了コード | 00 00（正常終了） |
| 15 | n | 読出しデータ | 2バイト（データ長4 - 終了コード2バイト） |

**パース時の注意**:
- ヘッダー部分: 6～14バイト目（9バイト = ネットワーク番号(1) + PC番号(1) + I/O番号(2) + 局番(1) + データ長(2) + 終了コード(2)）
- **データ部開始位置: 15バイト目**（サブヘッダ2バイト + シーケンス2バイト + 予約2バイト + ヘッダー9バイト）
- **実データ長 = データ長フィールド値 - 2（終了コード2バイト分を除く）**
- シーケンス番号を使用して要求-応答の対応付けを行う
- ⚠️ **重要**: 応答フレームには監視タイマフィールドは含まれない（要求フレームのみ）

### 4Eフレーム（ASCII形式）

| Idx | 長さ | 名称 | 内容(例) |
|-----|------|------|----------|
| 0 | 2 | サブヘッダ | "D4"（ASCII: 4E応答） |
| 2 | 2 | 予約1 | "00"（固定） |
| 4 | 4 | シーケンス番号 | "0001"（16進数4文字、要求のエコーバック） |
| 8 | 4 | 予約2 | "0000"（固定） |
| 12 | 2 | ネットワーク番号 | "xx"（16進数2文字） |
| 14 | 2 | PC番号 | "FF" |
| 16 | 4 | I/O番号 | "03FF"（16進数4文字） |
| 20 | 2 | 局番(マルチドロップ番号) | "00" |
| 22 | 4 | データ長 | "0004"（16進数4文字、4バイト相当） |
| 26 | 4 | 終了コード | "0000"（正常終了） |
| 30 | n | 読出しデータ | 16進数文字列（データ長-4文字分、実質4文字） |

**パース時の注意**:
- ヘッダー部分: 12～29文字目（18文字 = ネットワーク(2) + PC(2) + I/O(4) + 局番(2) + データ長(4) + 終了コード(4)）
- **データ部開始位置: 30文字目**（サブヘッダ2文字 + 予約1(2文字) + シーケンス4文字 + 予約2(4文字) + ヘッダー18文字）
- **実データ長 = データ長フィールド値 - 4（終了コード4文字分を除く）**
- シーケンス番号を使用して要求-応答の対応付けを行う
- ⚠️ **重要**: 応答フレームには監視タイマフィールドは含まれない（要求フレームのみ）

---

## パース処理の重要ポイント

### 共通事項
1. **データ長フィールドの意味**:
   - **3Eフレーム応答**: 終了コードを含む全データ長（終了コード以降のバイト数）
   - **4Eフレーム応答**: 終了コードを含む全データ長（終了コード以降のバイト数）
   - ⚠️ **重要**: 応答フレームのデータ長には監視タイマは含まれない
2. **実データ長の計算**:
   - **3Eフレーム Binary**: データ長 - 2（終了コード2バイト分）
   - **3Eフレーム ASCII**: データ長 - 4（終了コード4文字分）
   - **4Eフレーム Binary**: データ長 - 2（終了コード2バイト分）✅ 修正済み
   - **4Eフレーム ASCII**: データ長 - 4（終了コード4文字分）✅ 修正済み
3. **不完全フレーム対策**: 受信データが不足している場合は次回の受信データと結合する（特にTCP通信時）

### 3Eフレームと4Eフレームの違い
- **3Eフレーム**: シーケンス番号なし（seq=0固定）、単純な要求-応答
- **4Eフレーム**: シーケンス番号あり（要求と応答で一致）、複数の要求-応答を並行処理可能
- ⚠️ **注意**: 応答フレームに監視タイマフィールドは存在しない（要求フレームのみ）

---

## 実機データ検証結果（4E Binary応答）

### 検証データ
```
D4 00 04 00 00 00 00 FF FF 03 00 04 00 00 00 21 05
```

### バイト単位解析

| バイト位置 | 値 | 名称 | 説明 |
|----------|-----|------|------|
| 0-1 | `D4 00` | サブヘッダ | 4E Binary応答 ✅ |
| 2-3 | `04 00` | シーケンス番号 | 0x0004 (LE) = 4 |
| 4-5 | `00 00` | 予約 | 固定値 |
| 6 | `00` | ネットワーク番号 | 0 |
| 7 | `FF` | PC番号 | 255 (全局) |
| 8-9 | `FF 03` | I/O番号 | 0x03FF (LE) = 1023 |
| 10 | `00` | 局番 | 0 |
| 11-12 | `04 00` | **データ長** | 0x0004 (LE) = **4バイト** |
| 13-14 | `00 00` | **終了コード** | 0x0000 = 正常終了 ✅ |
| 15-16 | `21 05` | **デバイスデータ** | 0x0521 (LE) = **1313** |

### 解析結果

#### andon (C#) の解釈 ✅ 正確
```csharp
// Parse4EFrameStructure() による解析
フレームタイプ: Frame4E
シーケンス番号: 4
データ長: 4バイト
終了コード: 0x0000 (正常)
データ開始位置: 15バイト目 ✅
実データ長: 4 - 2(終了コード) = 2バイト
デバイス値: 0x21 | (0x05 << 8) = 0x0521 = 1313 ✅
```

#### PySLMPClient の解釈 ✅ 正確
```python
# __recv() による解析
buf[0:2] == b"\xd4\x00"  # 4E Binary判定 ✅
seq = struct.unpack("<H", buf[2:4])[0]  # seq=4
buf = buf[6:]  # サブヘッダ+シーケンス+予約をスキップ
network_num, pc_num, io_num, m_drop_num, length, term_code = \
    struct.unpack("<BBHBHH", buf[:9])
# length=4, term_code=0x0000
data = buf[9:]  # 13バイト目以降
new_length = length - 2  # 4 - 2 = 2バイト（終了コード除外）
device_data = data[:new_length]  # [0x21, 0x05]
result = struct.unpack("<H", device_data)[0]  # 0x0521 = 1313 ✅
```

#### 誤った解釈の例（ConMoniの13バイトオフセット） ❌
```python
# ❌ 13バイト目から読み取る場合
resRaw[13:15] = ['00', '00']  # ← 終了コードを読んでいる！
int('0000', 16) = 0  # ← 誤った値

# 正しくは15バイト目から読み取るべき
resRaw[15:17] = ['21', '05']
int('0521', 16) = 1313  # ✅ 正しい値
```

### 重要な発見
1. **4E応答フレームに監視タイマフィールドは存在しない**
2. **データ長 = 終了コード(2) + 実データ(n)**
3. **実データ開始位置 = 15バイト目**（13バイト目ではない）
4. **andon (C#)とPySLMPClientの実装は標準仕様に準拠** ✅