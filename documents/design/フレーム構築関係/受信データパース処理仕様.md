# SLMP受信データパース処理仕様書（C#移植用）

## 概要

PySLMPClientにおける受信データのパース処理のロジックと分岐構造を、C#移植のために文書化したものです。

---

## 1. パース処理の全体構造

### 1.1 処理フロー概要

```
ソケット受信
    ↓
__recv() メソッド: フレームヘッダーのパース
    ↓
受信キュー[seq]に格納 (network_num, pc_num, io_num, m_drop_num, term_code, data)
    ↓
__recv_loop(seq): キューからデータ取得
    ↓
各readメソッド: データ部の型別パース・変換
    ↓
アプリケーションへ返却
```

### 1.2 主要な分岐軸

1. **通信形式**: ASCII / Binary
2. **フレームバージョン**: 3Eフレーム / 4Eフレーム
3. **データ型**: bit / word / dword

---

## 2. __recv() メソッド - フレームヘッダーのパース

### 2.1 受信バッファ管理

```python
# 不完全な受信データは self.__rest に保存
buf = self.__rest + buf  # 前回の残データと結合
self.__rest = b""        # リセット
```

**C#実装のポイント**:
- `byte[]` または `List<byte>` で受信バッファを管理
- 不完全なフレームは次回の受信と結合する必要あり

### 2.2 メイン分岐: 先頭バイトによる形式判定

```python
if buf[0] == ord("D"):  # 0x44 = ASCII
    # ASCII形式のパース
elif buf[0] in (0xD0, 0xD4):  # Binary
    # Binary形式のパース
else:
    raise RuntimeError(buf)
```

---

## 3. ASCII形式のパース処理

### 3.1 フレームバージョン判定

```python
if buf[1] == ord("0"):  # '0' = 3Eフレーム
    buf = buf[4:]       # 4バイトスキップ
    seq = 0
elif buf[1] == ord("4"):  # '4' = 4Eフレーム
    seq = int(buf[4:8].decode("ascii"), base=16)  # シーケンス番号抽出
    buf = buf[12:]      # 12バイトスキップ
```

**ASCII形式のフレーム構造**:
- 3Eフレーム: `"D0" + ヘッダー(18文字) + データ部`
- 4Eフレーム: `"D4" + "00" + シーケンス(4文字) + "0000" + ヘッダー(18文字) + データ部`

### 3.2 ヘッダー情報の抽出

```python
network_num = int(buf[0:2].decode("ascii"), base=16)      # 2文字
pc_num = int(buf[2:4].decode("ascii"), base=16)           # 2文字
io_num = int(buf[4:8].decode("ascii"), base=16)           # 4文字
m_drop_num = int(buf[8:10].decode("ascii"), base=16)      # 2文字
length = int(buf[10:14].decode("ascii"), base=16)         # 4文字
term_code = int(buf[14:18].decode("ascii"), base=16)      # 4文字
```

**C#実装のポイント**:
```csharp
// ASCII文字列 → 16進数変換
int networkNum = Convert.ToInt32(Encoding.ASCII.GetString(buf, 0, 2), 16);
int pcNum = Convert.ToInt32(Encoding.ASCII.GetString(buf, 2, 2), 16);
int ioNum = Convert.ToInt32(Encoding.ASCII.GetString(buf, 4, 4), 16);
int mDropNum = Convert.ToInt32(Encoding.ASCII.GetString(buf, 8, 2), 16);
int length = Convert.ToInt32(Encoding.ASCII.GetString(buf, 10, 4), 16);
int termCode = Convert.ToInt32(Encoding.ASCII.GetString(buf, 14, 4), 16);
```

### 3.3 データ部の抽出

```python
data = buf[18:]                      # ヘッダー以降
new_length = length - 4              # term_code分を除く
data = data[:new_length]             # 必要な長さだけ取得
self.__rest = data[new_length:]      # 余剰分は次回用に保存
data = data.decode("ascii")          # ASCII文字列として扱う
```

---

## 4. Binary形式のパース処理

### 4.1 フレームバージョン判定

```python
if buf[0] == 0xD0:  # 3E Binary
    assert buf[1] == 0x00
    buf = buf[2:]   # 2バイトスキップ
    seq = 0
elif buf[0] == 0xD4:  # 4E Binary
    assert buf[:2] == b"\xd4\x00"
    (seq,) = struct.unpack("<H", buf[2:4])  # シーケンス番号
    assert buf[4:6] == b"\x00\x00"
    buf = buf[6:]   # 6バイトスキップ
```

**Binary形式のフレーム構造**:
- 3Eフレーム: `0xD000 + ヘッダー(9バイト) + データ部`
- 4Eフレーム: `0xD400 + シーケンス(2バイト) + 0x0000 + ヘッダー(9バイト) + データ部`

### 4.2 ヘッダー情報の抽出（struct.unpack使用）

```python
tmp = struct.unpack("<BBHBHH", buf[:9])
network_num, pc_num, io_num, m_drop_num, length, term_code = tmp
```

**C#実装のポイント**:
```csharp
// リトルエンディアンでバイト配列から構造体へ変換
byte networkNum = buf[0];              // 1バイト
byte pcNum = buf[1];                   // 1バイト
ushort ioNum = BitConverter.ToUInt16(buf, 2);     // 2バイト
byte mDropNum = buf[4];                // 1バイト
ushort length = BitConverter.ToUInt16(buf, 5);    // 2バイト
ushort termCode = BitConverter.ToUInt16(buf, 7);  // 2バイト
```

### 4.3 データ部の抽出

```python
data = buf[9:]                       # ヘッダー以降
new_length = length - 2              # term_code分(2バイト)を除く
data = data[:new_length]             # 必要な長さだけ取得
self.__rest = data[new_length:]      # 余剰分は次回用に保存
# dataはbytesのまま扱う
```

---

## 5. 受信キューへの格納

```python
with self.__lock:
    self.__recv_queue[seq] = (
        network_num,
        pc_num,
        io_num,
        m_drop_num,
        term_code,
        data,  # ASCII: str型、Binary: bytes型
    )
```

**C#実装のポイント**:
- `Dictionary<int, ReceivedData>` でキュー管理
- スレッドセーフな実装（`lock`または`ConcurrentDictionary`）
- `data`は `string` (ASCII) または `byte[]` (Binary)

---

## 6. データ型別パース処理

### 6.1 ビットデバイスの読み取り (read_bit_devices)

```python
if isinstance(data[5], str):  # ASCII
    ret = tuple(x == "1" for x in data[5])  # "0"/"1"文字列をboolに変換
else:  # Binary
    ret = tuple(x == 1 for x in util.decode_bcd(list(data[5])))
    if count % 2 == 1:
        ret = ret[:-1]  # 奇数個の場合、最後の余分なビットを削除
```

**C#実装のポイント**:
```csharp
if (data is string strData)  // ASCII
{
    return strData.Select(c => c == '1').ToArray();
}
else if (data is byte[] byteData)  // Binary
{
    var decoded = DecodeBcd(byteData);
    var result = decoded.Select(b => b == 1).ToArray();
    if (count % 2 == 1)
        result = result.Take(result.Length - 1).ToArray();
    return result;
}
```

### 6.2 ワードデバイスの読み取り (read_word_devices)

```python
if isinstance(data[5], str):  # ASCII
    ret = array('H', [
        int(data[5][x:][:4], base=16)
        for x in range(0, len(data[5]), 4)
    ])
else:  # Binary
    ret = array('H', data[5])
```

**C#実装のポイント**:
```csharp
if (data is string strData)  // ASCII
{
    var result = new ushort[strData.Length / 4];
    for (int i = 0; i < strData.Length; i += 4)
    {
        result[i / 4] = Convert.ToUInt16(strData.Substring(i, 4), 16);
    }
    return result;
}
else if (data is byte[] byteData)  // Binary
{
    var result = new ushort[byteData.Length / 2];
    Buffer.BlockCopy(byteData, 0, result, 0, byteData.Length);
    return result;
}
```

### 6.3 ランダム読み取り (read_random_devices)

**ASCII形式**:
```python
bytes_buf = util.str2bytes_buf(buf)  # 16進数文字列 → バイト列
bytes_buf.reverse()
word_data = list()
dword_data = list()
for _ in range(len(word_list)):
    d1 = bytes_buf.pop()
    d2 = bytes_buf.pop()
    word_data.append(bytes([d2, d1]))  # エンディアン変換
for _ in range(len(dword_list)):
    d1 = bytes_buf.pop()
    d2 = bytes_buf.pop()
    d3 = bytes_buf.pop()
    d4 = bytes_buf.pop()
    dword_data.append(bytes([d4, d3, d2, d1]))  # エンディアン変換
```

**Binary形式**:
```python
split_pos = len(word_list) * 2
dword_data, word_data = util.extracts_word_dword_data(buf, split_pos)
```

---

## 7. ユーティリティ関数

### 7.1 decode_bcd() - 4bit BCD配列のデコード

```python
def decode_bcd(data):
    """
    [0x12, 0x34] → [1, 2, 3, 4]
    """
    data = np.asarray(data, dtype=np.uint8)
    bin_array_h = (data >> 4) & 0x0F  # 上位4bit
    bin_array_l = data & 0x0F         # 下位4bit

    bin_array = np.empty(data.size * 2, "u1")
    bin_array[::2] = bin_array_h
    bin_array[1::2] = bin_array_l

    return list(bin_array)
```

**C#実装例**:
```csharp
public static byte[] DecodeBcd(byte[] data)
{
    var result = new byte[data.Length * 2];
    for (int i = 0; i < data.Length; i++)
    {
        result[i * 2] = (byte)((data[i] >> 4) & 0x0F);      // 上位4bit
        result[i * 2 + 1] = (byte)(data[i] & 0x0F);         // 下位4bit
    }
    return result;
}
```

### 7.2 unpack_bits() - ビット配列の展開

```python
def unpack_bits(data):
    """
    [0x85] → [1, 0, 1, 0, 0, 0, 0, 1]  # LSBから順
    """
    data = np.asarray(data, dtype=np.uint8)
    byte_array2d = data.reshape((data.size, 1))
    byte_array2d_bin = np.unpackbits(byte_array2d, axis=1)
    return list(byte_array2d_bin[:, ::-1].flatten())
```

**C#実装例**:
```csharp
public static bool[] UnpackBits(byte[] data)
{
    var result = new bool[data.Length * 8];
    for (int i = 0; i < data.Length; i++)
    {
        for (int bit = 0; bit < 8; bit++)
        {
            result[i * 8 + bit] = ((data[i] >> bit) & 1) == 1;  // LSBから
        }
    }
    return result;
}
```

### 7.3 str2bytes_buf() - 16進数文字列からバイト列へ

```python
def str2bytes_buf(data):
    """
    "1A2B" → [0x1A, 0x2B]
    """
    buf = list(data)
    buf.reverse()
    bytes_buf = list()
    while buf:
        s1 = buf.pop()
        s2 = buf.pop()
        bytes_buf.append(int(s1 + s2, base=16))
    return bytearray(bytes_buf)
```

**C#実装例**:
```csharp
public static byte[] Str2BytesBuf(string data)
{
    var result = new byte[data.Length / 2];
    for (int i = 0; i < data.Length; i += 2)
    {
        result[i / 2] = Convert.ToByte(data.Substring(i, 2), 16);
    }
    return result;
}
```

### 7.4 extracts_word_dword_data() - Word/Dwordデータの分離

```python
def extracts_word_dword_data(buf, split_pos):
    """
    バイナリデータを2バイトデータと4バイトデータに分離
    """
    word_data = list()
    dword_data = list()
    word_buf = bytearray(buf[:split_pos])
    dword_buf = bytearray(buf[split_pos:])
    word_buf.reverse()
    dword_buf.reverse()
    while word_buf:
        d1 = word_buf.pop()
        d2 = word_buf.pop()
        word_data.append(bytes([d1, d2]))
    while dword_buf:
        d1 = dword_buf.pop()
        d2 = dword_buf.pop()
        d3 = dword_buf.pop()
        d4 = dword_buf.pop()
        dword_data.append(bytes([d1, d2, d3, d4]))
    return dword_data, word_data
```

**C#実装例**:
```csharp
public static (List<byte[]> dwordData, List<byte[]> wordData)
    ExtractsWordDwordData(byte[] buf, int splitPos)
{
    var wordData = new List<byte[]>();
    var dwordData = new List<byte[]>();

    // Wordデータ抽出
    for (int i = 0; i < splitPos; i += 2)
    {
        wordData.Add(new byte[] { buf[i], buf[i + 1] });
    }

    // Dwordデータ抽出
    for (int i = splitPos; i < buf.Length; i += 4)
    {
        dwordData.Add(new byte[] { buf[i], buf[i + 1], buf[i + 2], buf[i + 3] });
    }

    return (dwordData, wordData);
}
```

---

## 8. エラーハンドリング

### 8.1 データ長不足の処理

```python
if len(buf) < 11:  # 最小ヘッダー長に満たない
    with self.__lock:
        self.__rest = buf  # 次回に持ち越し
    return
```

### 8.2 終了コードのチェック

```python
end_code = util.EndCode(data[4])
if end_code != util.EndCode.Success:
    raise util.SLMPCommunicationError(end_code)
```

**C#実装のポイント**:
- `EndCode` enum定義
- `SLMPCommunicationException`を継承したカスタム例外

---

## 9. スレッドセーフ実装

### 9.1 受信スレッド

```python
def __worker(self):
    while self.__socket:
        try:
            self.__recv()
        except RuntimeError as e:
            self.logger.error(e)
```

### 9.2 ロック処理

```python
with self.__lock:
    self.__recv_queue[seq] = (...)
```

**C#実装のポイント**:
- `Task.Run()` または `Thread`で受信スレッドを実装
- `lock(syncObject)` または `ConcurrentDictionary<int, ReceivedData>`

---

## 10. 主要な分岐条件まとめ

| 分岐ポイント | 条件 | 処理内容 |
|------------|------|---------|
| 通信形式 | `buf[0] == 0x44 ('D')` | ASCII形式パース |
| 通信形式 | `buf[0] in (0xD0, 0xD4)` | Binary形式パース |
| フレームバージョン (ASCII) | `buf[1] == '0'` | 3Eフレーム (seq=0) |
| フレームバージョン (ASCII) | `buf[1] == '4'` | 4Eフレーム (seqを抽出) |
| フレームバージョン (Binary) | `buf[0] == 0xD0` | 3Eフレーム (seq=0) |
| フレームバージョン (Binary) | `buf[0] == 0xD4` | 4Eフレーム (seqを抽出) |
| データ型 | `isinstance(data[5], str)` | ASCIIデータとして処理 |
| データ型 | `isinstance(data[5], bytes)` | Binaryデータとして処理 |
| デバイス種別 | `sub_cmd & 0x01` | ビットデバイス |
| デバイス種別 | `sub_cmd & 0x01 == 0` | ワードデバイス |

---

## 11. C#移植時の設計推奨事項

### 11.1 クラス構成案

```csharp
// パース結果を格納する構造体
public struct ReceivedFrame
{
    public byte NetworkNum;
    public byte PcNum;
    public ushort IoNum;
    public byte MDropNum;
    public ushort TermCode;
    public object Data;  // string (ASCII) or byte[] (Binary)
}

// パーサークラス
public class SlmpFrameParser
{
    private byte[] _restBuffer = Array.Empty<byte>();

    public bool TryParse(byte[] receivedData, out int seq, out ReceivedFrame frame)
    {
        // パース処理実装
    }
}

// 受信キュー管理
public class ReceiveQueue
{
    private ConcurrentDictionary<int, ReceivedFrame> _queue = new();

    public void Enqueue(int seq, ReceivedFrame frame) { }
    public ReceivedFrame Dequeue(int seq, int timeoutMs) { }
}
```

### 11.2 列挙型定義

```csharp
public enum FrameType
{
    Binary3E = 0xD0,
    Binary4E = 0xD4,
    Ascii3E = 'D' << 8 | '0',
    Ascii4E = 'D' << 8 | '4'
}

public enum EndCode : ushort
{
    Success = 0x0000,
    // その他のエラーコード
}
```

### 11.3 非同期I/O対応

```csharp
public async Task ReceiveLoopAsync(CancellationToken cancellationToken)
{
    while (!cancellationToken.IsCancellationRequested)
    {
        var buffer = new byte[512];
        var received = await _socket.ReceiveAsync(buffer, SocketFlags.None);

        if (TryParse(buffer.Take(received).ToArray(), out int seq, out var frame))
        {
            _receiveQueue.Enqueue(seq, frame);
        }
    }
}
```

---

## 12. テストケース推奨項目

1. **ASCII 3Eフレーム**: 最小構成の受信データ
2. **ASCII 4Eフレーム**: シーケンス番号付き
3. **Binary 3Eフレーム**: バイナリ形式
4. **Binary 4Eフレーム**: バイナリ+シーケンス番号
5. **不完全フレーム**: データが途中で切れた場合のバッファリング
6. **複数フレーム結合**: 1回の受信で複数フレームが到着
7. **ビットデバイス**: 奇数個/偶数個の読み取り
8. **ワードデバイス**: エンディアン変換確認
9. **エラー応答**: 終了コードが異常値の場合

---

## 付録: Pythonとの主要な違い

| 項目 | Python | C# |
|-----|--------|-----|
| バイト配列操作 | `buf[2:4]`, `buf[:9]` | `buf.Skip(2).Take(2)`, `new Span<byte>(buf, 0, 9)` |
| 構造体アンパック | `struct.unpack("<BBHBHH", buf)` | `BitConverter.ToUInt16()` など個別変換 |
| エンディアン | `struct`が自動処理 | `BitConverter.IsLittleEndian`チェックが必要 |
| スレッド同期 | `with self.__lock:` | `lock(syncObject) { }` |
| 型判定 | `isinstance(data, str)` | `data is string` |
| リスト逆順 | `buf.reverse()` | `Array.Reverse(buf)` |

---

以上、PySLMPClientの受信データパース処理仕様書でした。
