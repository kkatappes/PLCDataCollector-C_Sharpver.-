# 実装チェックリストと注意事項

**作成日**: 2025-11-28
**実装方針**: TDD（Test-Driven Development）

---

## 全体実装チェックリスト

### Phase 1: ExecuteMultiPlcCycleAsync_Internal 実装

- [x] **TDDサイクル1**: 単一PLC基本サイクル【完了: 2025-11-28】
  - [x] Red: テスト作成 (ExecutionOrchestratorTests.cs) - TC122追加
  - [x] Green: 最小限実装 - 1つ目のPLCのみ処理
  - [x] Refactor: エラーハンドリング追加 - 入力検証、例外処理
  - [x] テスト実行・パス確認 - ✅ 1 passed, 0 failed

- [x] **TDDサイクル2**: 複数PLC対応【完了: 2025-11-28】
  - [x] Red: テスト作成 - TC123追加（3台のPLC検証）
  - [x] Green: forループ実装 - 全PLC順次処理
  - [x] Refactor: キャンセルチェック、エラーハンドリング強化
  - [x] テスト実行・パス確認 - ✅ 2 passed (TC122, TC123), 0 failed

- [x] **TDDサイクル3**: Step2フレーム構築統合【完了: 2025-11-28】
  - [x] Red: テスト作成 - TC124追加（フレーム構築検証）
  - [x] Green: ConfigToFrameManager 統合 - BuildReadRandomFrameFromConfig()呼び出し
  - [x] Refactor: リグレッションテスト実行
  - [x] テスト実行・パス確認 - ✅ 3 passed (TC122, TC123, TC124), 0 failed
  - [x] IConfigToFrameManagerインターフェース整備（4メソッドシグネチャ追加）
  - [x] 実際のSLMP ReadRandomフレーム構築稼働確認

- [x] **TDDサイクル4**: Step7データ出力統合【完了: 2025-11-28】
  - [x] Red: テスト作成 - TC125追加（データ出力検証）
  - [x] Green: DataOutputManager 統合 - OutputToJson()呼び出し実装
  - [x] Refactor: リグレッションテスト実行（全8テスト合格）
  - [x] テスト実行・パス確認 - ✅ 8 passed (TC122, TC123, TC124, TC125 + 既存4), 0 failed
  - [x] 成功条件判定実装（result.IsSuccess && ProcessedData != null）
  - [x] IPアドレスとポート番号の正しい渡し方実装

### Phase 2: ApplicationController 初期化実装

- [x] **TDDサイクル1**: 単一PLC Manager生成【完了: 2025-12-01】
  - [x] Red: テスト作成 (ApplicationControllerTests.cs) - TC126追加
  - [x] Green: 最小限実装 - PlcCommunicationManager生成処理実装
  - [x] Refactor: GetPlcManagers()テストアクセサ追加
  - [x] テスト実行・パス確認 - ✅ 1 passed, 0 failed

- [x] **TDDサイクル2**: 複数PLC Manager生成【完了: 2025-12-01】
  - [x] Red: テスト作成 - TC127追加（3台のPLC検証）
  - [x] Green: foreach実装（既にサイクル1で実装済み）
  - [x] Refactor: リグレッションテスト実行
  - [x] テスト実行・パス確認 - ✅ 2 passed (TC126, TC127), 0 failed

- [x] **TDDサイクル3**: 初期化失敗ハンドリング【完了: 2025-12-01】
  - [x] 既存のtry-catchで対応済みと判断
  - [x] MultiPlcConfigManager.GetAllConfigurations()非virtualのためモック不可
  - [x] エラーハンドリング実装確認（既存try-catch+ログ出力）

### Phase 3: 統合テスト

- [x] **統合テスト1**: Step1 → 周期実行フロー【完了: 2025-12-01】
  - [x] テスト作成 (ContinuousMode_IntegrationTests.cs) - TC128追加
  - [x] Step1初期化成功確認
  - [x] _plcManagers生成確認
  - [x] _plcConfigs保持確認
  - [x] RunContinuousDataCycleAsync()呼び出し確認
  - [x] テスト実行・パス確認 - ✅ 1 passed, 0 failed

- [x] **統合テスト2**: エラーリカバリー【完了: 2025-12-01】
  - [x] テスト作成 - TC129追加（2台のPLC、エラーハンドリング検証）
  - [x] 複数PLC環境でのエラーハンドリング確認
  - [x] 1つのPLC失敗時も処理継続確認
  - [x] foreachループのtry-catch動作確認
  - [x] テスト実行・パス確認 - ✅ 1 passed, 0 failed

- [x] **統合テスト3**: 複数PLC順次実行【完了: 2025-12-01】
  - [x] テスト作成 - TC130追加（3台のPLC、TCP/UDP混在）
  - [x] 3つのPlcManager生成確認
  - [x] TCP/UDP混在環境動作確認
  - [x] 各PLCの独立動作確認
  - [x] テスト実行・パス確認 - ✅ 1 passed, 0 failed

- [ ] **統合テスト4**: 周期実行間隔検証【Skip - 実装予定】
  - [x] テスト作成 - TC131追加（Skip指定）
  - [ ] MonitoringIntervalMs設定値通りの実行間隔検証（実時間テストのため後回し）

### Phase 4: コードレビューとドキュメント更新

- [ ] コードレビュー実施
- [ ] ドキュメント更新
  - [ ] アプリケーション動作フロー.md
  - [ ] クラス設計.md
  - [ ] 各ステップio.md
- [ ] リファクタリング

---

## 実装時の注意事項

### TDD実践のポイント

1. **必ずテストを先に書く**
   - 実装前にテストを書くことで、インターフェースと期待動作を明確化
   - テストが失敗（Red）することを確認

2. **最小限の実装でテストを通す**
   - ハードコードでも良いので、まずテストを通す（Green）
   - 過度な設計を避ける

3. **動作するコードができてからリファクタリング**
   - テストが通ってから、コードを改善（Refactor）
   - テストが常にパスすることを確認しながら進める

4. **1つのテストで1つの機能**
   - テストケースを細かく分割
   - 失敗時の原因特定を容易にする

### コード品質の維持

- **各Phaseでの全テスト実行**
  - 新しいコード追加後、既存テストが壊れていないか確認
  - リグレッションテストの徹底

- **継続的なリファクタリング**
  - 重複コードの排除
  - 命名の改善
  - 複雑度の低減

- **ログ出力の充実**
  - 各処理ステップでログ出力
  - エラー時の詳細情報記録

---

## テスト用publicメソッドの取り扱い

### 概要

TDD実装のため、以下のテスト専用publicメソッドを追加しています。これらは設計文書に記載されていませんが、TDD実践上の標準的な手法です。

### 追加されるテスト用メソッド

**ApplicationController.cs**:
```csharp
/// <summary>
/// テスト用: PlcManagers リストへのアクセサ
/// </summary>
/// <remarks>
/// 本番コード: internal または条件付きコンパイルに変更予定
/// テスト目的: ExecuteStep1InitializationAsync() の検証
/// </remarks>
public List<IPlcCommunicationManager> GetPlcManagers()
    => _plcManagers ?? new List<IPlcCommunicationManager>();
```

**ExecutionOrchestrator.cs**:
```csharp
/// <summary>
/// テスト用: ExecuteMultiPlcCycleAsync_Internal() の公開ラッパー
/// </summary>
/// <remarks>
/// 本番コード: internal または削除予定
/// テスト目的: 周期実行ロジックの単体テスト
/// Phase 1-3時点: Option 3設計でPlcConfigurationリストも受け取る
/// </remarks>
public async Task ExecuteSingleCycleAsync(
    List<PlcConfiguration> plcConfigs,
    List<IPlcCommunicationManager> plcManagers,
    CancellationToken cancellationToken)
{
    await ExecuteMultiPlcCycleAsync_Internal(plcConfigs, plcManagers, cancellationToken);
}
```

### 実装後の対応方針

**オプション1: internal アクセス修飾子への変更**
```csharp
// テストプロジェクトから参照可能、外部からは非公開
[assembly: InternalsVisibleTo("andon.Tests")]

internal List<IPlcCommunicationManager> GetPlcManagers()
    => _plcManagers ?? new List<IPlcCommunicationManager>();
```

**オプション2: 条件付きコンパイル**
```csharp
#if DEBUG
/// <summary>
/// テスト専用メソッド（DEBUGビルド時のみ有効）
/// </summary>
public List<IPlcCommunicationManager> GetPlcManagers()
    => _plcManagers ?? new List<IPlcCommunicationManager>();
#endif
```

**オプション3: そのまま維持**
- publicのまま維持（インターフェースに含めない）
- ドキュメントで「テスト専用」と明記
- コードレビュー時に使用箇所を確認

### 推奨される対応

**Phase 3 統合テスト完了後**:
1. すべてのテストがパスすることを確認
2. テスト用メソッドを `internal` に変更
3. `AssemblyInfo.cs` に `InternalsVisibleTo` 属性を追加
4. テストが引き続きパスすることを確認

```csharp
// AssemblyInfo.cs または ApplicationController.cs の冒頭
[assembly: InternalsVisibleTo("andon.Tests")]
```

### 設計文書への記載について

これらのメソッドは以下の理由により、設計文書への記載は不要と判断：
- **一時的な存在**: TDD実装のための一時的な措置
- **テスト専用**: 本番コードからは使用されない
- **標準的手法**: TDDでは一般的に使用される手法
- **将来的に変更**: internal 化または削除予定

---

## コーディング規約チェック

### 命名規則

- [ ] クラス名はPascalCase
- [ ] メソッド名はPascalCase
- [ ] プライベートフィールドは_camelCase
- [ ] ローカル変数はcamelCase
- [ ] 定数はPascalCase

### コメント

- [ ] パブリックメソッドにXMLドキュメントコメント
- [ ] 複雑なロジックにコメント
- [ ] TODOコメントは明確な担当者・期限

### エラーハンドリング

- [ ] 適切なtry-catch-finally
- [ ] カスタム例外の使用（必要に応じて）
- [ ] エラーログ出力

### 非同期処理

- [ ] async/await の適切な使用
- [ ] CancellationToken の適切な伝播
- [ ] ConfigureAwait(false) の使用（必要に応じて）

### リソース管理

- [ ] using ステートメントの使用
- [ ] IDisposable の実装（必要に応じて）
- [ ] メモリリークの防止

---

## デバッグとトラブルシューティング

### よくある問題

1. **テストが通らない**
   - モックの設定を確認
   - 戻り値の型を確認
   - 非同期メソッドの待機を確認

2. **NullReferenceException**
   - DIコンテナへの登録を確認
   - コンストラクタでの初期化を確認
   - null チェックの追加

3. **タイムアウト**
   - CancellationToken の適切な使用
   - タイムアウト設定の確認
   - デッドロックの可能性を確認

### デバッグのヒント

- ブレークポイントを適切に設置
- ログ出力を活用
- テストを小さく分割
- 1つずつ問題を解決
