# 受信データ解析機能 3プロジェクト比較レポート

分析日時: 2025-11-14（実機データ検証: 2025-01-17）
対象プロジェクト: andon (C#), ConMoni (Python), PySLMPClient (Python)

**重要**: 本レポートは実機通信データ（PLC: 172.30.40.15:8192）の解析結果に基づいて修正されています。

---

## 1. 受信データ処理ロジック（大枠）フロー比較

### 1.1 andon (C#プロジェクト)

#### 処理フロー全体
```
┌──────────────────────────────────────────────────────────┐
│ ProcessReceivedRawData() メソッド                         │
│   ↓                                                       │
│ 1. 入力検証 + パフォーマンス計測開始                        │
│   ↓                                                       │
│ 2. フレームタイプ自動検出 (DetectFrameTypeFromSubheader)   │
│   │  - サブヘッダ 0xD0 0x00 → 3E                          │
│   │  - サブヘッダ 0xD4 0x00 → 4E                          │
│   ↓                                                       │
│ 3. SLMP構造検証 (ValidateSlmpFrameStructure)             │
│   ↓                                                       │
│ 4. フレーム解析 (動的分岐)                                 │
│   ├─ 3E → Parse3EFrameStructure()                        │
│   └─ 4E → Parse4EFrameStructure()                        │
│   ↓                                                       │
│ 5. 終了コード確認 (0x0000 = 正常)                         │
│   ↓                                                       │
│ 6. デバイス値抽出 (ExtractDeviceValues)                   │
│   │  - リトルエンディアン対応                              │
│   │  - 2バイト単位で読み取り                               │
│   ↓                                                       │
│ 7. ProcessedDeviceリスト構築                             │
│   ↓                                                       │
│ 8. 処理時間計測 + ログ出力                                 │
└──────────────────────────────────────────────────────────┘
        ↓ (別メソッドへ)
┌──────────────────────────────────────────────────────────┐
│ ParseRawToStructuredData() メソッド                       │
│   ↓                                                       │
│ 1. 構造化設定検証 (StructureDefinitions)                  │
│   ↓                                                       │
│ 2. 複数構造体定義の順次処理                                │
│   │  - 各構造体に対してProcessSingleStructure呼出          │
│   │  - フィールド単位でデータマッピング                      │
│   ↓                                                       │
│ 3. StructuredDeviceリスト構築                             │
│   ↓                                                       │
│ 4. 解析ステップ記録 + エラー/警告管理                       │
└──────────────────────────────────────────────────────────┘
```

#### 特徴
- **動的フレームタイプ検出**: サブヘッダから3E/4E自動判定
- **強固な検証**: 各段階でデータ整合性チェック
- **エラーハンドリング**: 多層的な例外処理とログ出力
- **2段階処理**: Raw → ProcessedDevice → StructuredDevice
- **拡張性**: 構造体定義による柔軟なデータマッピング


### 1.2 ConMoni (Pythonプロジェクト)

#### 処理フロー全体
```
┌──────────────────────────────────────────────────────────┐
│ getPlcData() メソッド (GetPlcData.py: 280-327)           │
│   ↓                                                       │
│ 1. 要求送信                                                │
│   │  self.sock.send(bytes(self.settingData["accessPlcSetting"])) │
│   ↓                                                       │
│ 2. 応答受信                                                │
│   │  res = self.sock.recv(self.BUFSIZE)                  │
│   │  resRaw = [format(i,'02X') for i in res]  # バイト→HEX文字列化 │
│   ↓                                                       │
│ 3. 前回値比較（不連続モード時のみ）                          │
│   │  if resRaw == self.previousData: return None          │
│   ↓                                                       │
│ 4. デバイス値抽出（単純ループ処理）                          │
│   │  for x in range(0, accessPlcSetting[19]+1):          │
│   │      tmpDeviceData = int(''.join(resRaw[13+2*x:15+2*x][::-1]),16) │
│   │      tmpData.append(tmpDeviceData)                    │
│   ↓                                                       │
│ 5. 桁数変換 + ビット展開                                    │
│   │  calcTempData = np.array(tmpData) * self.digitControl │
│   │  for r, flag in zip(calcTempData, accessBitDataLoc):  │
│   │      if flag == 1:                                    │
│   │          binary = format(r.astype(np.uint16), '016b') │
│   │          binary = binary[::-1]  # ビット順反転         │
│   │          final_result.extend(binary_list)             │
│   │      else:                                            │
│   │          final_result.append(r)                       │
│   ↓                                                       │
│ 6. タイムスタンプ付与 + データ蓄積                          │
│   │  final_result.insert(0, datetime.now())               │
│   │  self.writeData.append(final_result)                  │
│   ↓                                                       │
│ 7. 定周期CSV出力（60回分バッファ蓄積後）                    │
└──────────────────────────────────────────────────────────┘
```

#### 特徴
- **フレーム形式固定**: ~~3Eフレーム~~ **4Eフレーム** バイナリ専用（要求サブヘッダ 0x54 0x00 = 4E標準要求）
- **最小限の検証**: 終了コードチェックなし、データ長検証なし
- **高速処理**: 直接インデックスアクセス（resRaw[13+2*x:15+2*x]）
  - **注意**: ConMoniのコード上は13バイト目から読み取りとなっているが、実機データでは4E応答の標準オフセット（15バイト目）と一致していない可能性
- **ビット展開対応**: 16ビット単位でワード→ビット配列変換
- **前回値比較**: 不連続データ収集モード対応
- **バッファリング**: 60回分まとめてCSV書き込み（メモリ効率優先）


### 1.3 PySLMPClient (Pythonライブラリ)

#### 処理フロー全体
```
┌──────────────────────────────────────────────────────────┐
│ __recv() メソッド (pyslmpclient/__init__.py: 165-255)    │
│   ↓                                                       │
│ 1. データ受信 (ノンブロッキング)                            │
│   │  buf = self.__socket.recv(512)                       │
│   │  buf = self.__rest + buf  # 前回残りデータ連結         │
│   ↓                                                       │
│ 2. 最小長チェック (11バイト以上)                           │
│   ↓                                                       │
│ 3. フレーム形式判定 (動的・マルチ対応)                      │
│   ├─ buf[0] == ord("D") → ASCII形式                      │
│   │   ├─ buf[1] == ord("0") → 3E ASCII                   │
│   │   └─ buf[1] == ord("4") → 4E ASCII                   │
│   │                                                       │
│   └─ buf[0] == 0xD0 → 3E Binary                          │
│       buf[0] == 0xD4 → 4E Binary                          │
│   ↓                                                       │
│ 4. バージョン別解析 (ASCII / Binary)                       │
│   ├─ ASCII:                                              │
│   │   network_num = int(buf[0:2].decode("ascii"), base=16) │
│   │   data = buf[18:].decode("ascii")                    │
│   │                                                       │
│   └─ Binary:                                             │
│       tmp = struct.unpack("<BBHBHH", buf[:9])            │
│       network_num, pc_num, io_num, ... = tmp             │
│       data = buf[9:]                                     │
│   ↓                                                       │
│ 5. データ長検証 + 残データ処理                             │
│   │  if len(buf) < length + 7:                           │
│   │      self.__rest = buf  # 不足データは次回へ           │
│   ↓                                                       │
│ 6. 受信キューへ格納                                        │
│   │  self.__recv_queue[seq] = (network_num, pc_num, ..., data) │
└──────────────────────────────────────────────────────────┘
        ↓ (呼び出し元で)
┌──────────────────────────────────────────────────────────┐
│ read_word_devices() / read_bit_devices()                 │
│   ↓                                                       │
│ 1. コマンド送信 (__cmd_format)                             │
│   ↓                                                       │
│ 2. 応答待機 (__recv_loop)                                 │
│   ↓                                                       │
│ 3. 終了コード検証 (EndCode.Success確認)                    │
│   ↓                                                       │
│ 4. データ型別デコード                                       │
│   ├─ Word: array('H', data[5])                           │
│   └─ Bit: decode_bcd(list(data[5]))                      │
└──────────────────────────────────────────────────────────┘
```

#### 特徴
- **完全マルチ対応**: 3E/4E × Binary/ASCII 全組み合わせ自動判定
- **非同期受信**: 別スレッドで受信、キュー管理
- **データ残存処理**: 不完全パケット対応（self.__rest管理）
- **終了コード検証**: EndCodeクラスで厳密チェック
- **汎用ライブラリ**: 多様なコマンド対応（Random/Block読み書き等）
- **エラー伝播**: SLMPCommunicationError例外で詳細通知


---

## 2. 3E/4E、Binary/ASCII 各種組み合わせの解析ロジック比較

### 2.1 フレームタイプ判定方式

| プロジェクト | 判定タイミング | 判定ロジック | 対応形式 |
|------------|--------------|------------|---------|
| **andon** | 受信直後 | 応答サブヘッダ固定値チェック<br>- 0xD0 0x00 → 3E<br>- 0xD4 0x00 → 4E | **Binary専用**<br>(ASCII未対応) |
| **ConMoni** | 設定により事前決定 | 判定なし（4E Binary固定）<br>要求サブヘッダ: 0x54 0x00（4E標準要求）<br>応答サブヘッダ: 0xD4 0x00（実機確認） | **4E Binary専用**<br>実機データで確認済み |
| **PySLMPClient** | 受信直後 | 先頭1バイト判定<br>- ord("D") → ASCII<br>  - buf[1] → "0"=3E, "4"=4E<br>- 0xD0 → 3E Binary<br>- 0xD4 → 4E Binary | **全組み合わせ対応**<br>3E/4E × Binary/ASCII |


### 2.2 フレーム構造解析の詳細

#### 2.2.1 andon: 3Eフレーム Binary解析

```csharp
// Parse3EFrameStructure() (行番号: 1330-1370)
private (ushort EndCode, byte[] DeviceData) Parse3EFrameStructure(byte[] rawData)
{
    // 3E Binary応答フレーム構造:
    // Idx 0-1: サブヘッダ (0xD0 0x00)
    // Idx 2: ネットワーク番号
    // Idx 3: PC番号 (0xFF)
    // Idx 4-5: I/O番号 (0xFF 0x03)
    // Idx 6: マルチドロップ局番 (0x00)
    // Idx 7-8: データ長 (LE)
    // Idx 9-10: 終了コード (LE, 0x0000=正常)
    // Idx 11~: デバイスデータ

    ushort dataLength = (ushort)(rawData[7] | (rawData[8] << 8));
    ushort endCode = (ushort)(rawData[9] | (rawData[10] << 8));

    byte[] deviceData = new byte[rawData.Length - 11];
    Array.Copy(rawData, 11, deviceData, 0, rawData.Length - 11);

    return (endCode, deviceData);
}
```

**特徴**:
- **固定オフセット**: デバイスデータ開始位置が11バイト目（固定）
- **リトルエンディアン処理**: `rawData[7] | (rawData[8] << 8)`
- **検証**: 終了コード抽出（呼び出し元で0x0000チェック）
- **メモリ効率**: Array.Copyで必要部分のみ抽出


#### 2.2.2 andon: 4Eフレーム Binary解析

```csharp
// Parse4EFrameStructure() (類似構造、シリアル番号対応)
private (ushort EndCode, byte[] DeviceData) Parse4EFrameStructure(byte[] rawData)
{
    // 4E Binary応答フレーム構造:
    // Idx 0-1: サブヘッダ (0xD4 0x00)
    // Idx 2-3: シリアル番号 (LE)
    // Idx 4-5: 予約 (0x00 0x00)
    // Idx 6: ネットワーク番号
    // Idx 7: PC番号 (0xFF)
    // Idx 8-9: I/O番号 (0xFF 0x03)
    // Idx 10: マルチドロップ局番 (0x00)
    // Idx 11-12: データ長 (LE)
    // Idx 13-14: 終了コード (LE)
    // Idx 15~: デバイスデータ

    ushort serialNumber = (ushort)(rawData[2] | (rawData[3] << 8));
    ushort dataLength = (ushort)(rawData[11] | (rawData[12] << 8));
    ushort endCode = (ushort)(rawData[13] | (rawData[14] << 8));

    byte[] deviceData = new byte[rawData.Length - 15];
    Array.Copy(rawData, 15, deviceData, 0, rawData.Length - 15);

    return (endCode, deviceData);
}
```

**特徴**:
- **シリアル番号対応**: 4Eフレーム特有の2バイトシリアル番号処理
- **オフセット調整**: デバイスデータ開始位置が15バイト目（3Eより4バイト増）
- **同一インターフェース**: 戻り値は3Eと同じ構造（呼び出し元から透過的）


#### 2.2.3 ConMoni: 4Eフレーム Binary解析（簡易版）

```python
# getPlcData() (行番号: 280-327)
# 応答受信
res = self.sock.recv(self.BUFSIZE)
resRaw = [format(i,'02X') for i in res]  # バイト配列→HEX文字列リスト

# デバイス点数取得（要求フレーム内の点数情報を使用）
device_count = self.settingData["accessPlcSetting"][19] + 1

# デバイス値抽出（13バイト目から2バイトずつ）
for x in range(0, device_count):
    # リトルエンディアン変換: [下位, 上位] → int
    tmpDeviceData = int(''.join(resRaw[13+2*x:15+2*x][::-1]), 16)
    tmpData.append(tmpDeviceData)

# ビット展開処理
calcTempData = np.array(tmpData) * self.digitControl
final_result = []
for r, flag in zip(calcTempData, self.settingData["accessBitDataLoc"]):
    if flag == 1:  # ビットデバイスの場合
        binary = format(r.astype(np.uint16), '016b')
        binary = binary[::-1]  # ビット順反転 (LSB first)
        binary_list = list(map(int, binary))
        final_result.extend(binary_list)
    else:  # ワードデバイスの場合
        final_result.append(r)
```

**特徴**:
- **フレーム検証なし**: 終了コード・データ長チェックなし
- **固定オフセット**: コード上は13バイト目から開始（HEX文字列リストのインデックス）
  - ⚠️ **実機データとの不一致**: 4E応答フレームの標準オフセットは15バイト目
  - ⚠️ **要検証**: HEX文字列化処理でインデックスがずれている可能性、またはコードと実際の動作が異なる可能性
- **HEX文字列処理**: バイナリ→HEX文字列変換後に結合・逆転してint化
- **ビット展開機能**: 16ビット単位でワード値をビット配列に展開
- **前処理依存**: デバイス点数は設定ファイルから取得（応答内検証なし）


#### 2.2.4 PySLMPClient: 全形式対応解析

##### Binary形式解析
```python
# __recv() (行番号: 219-243)
elif buf[0] in (0xD0, 0xD4):  # Binary
    if buf[0] == 0xD0:  # 3E Binary
        assert buf[1] == 0x00, buf[:2]
        buf = buf[2:]  # サブヘッダスキップ
    elif buf[0] == 0xD4:  # 4E Binary
        assert buf[:2] == b"\xd4\x00", buf[:2]
        (seq,) = struct.unpack("<H", buf[2:4])  # シリアル番号抽出
        assert buf[4:6] == b"\x00\x00", buf[:6]
        buf = buf[6:]  # サブヘッダ+シリアル+予約スキップ

    # 共通ヘッダ解析
    tmp = struct.unpack("<BBHBHH", buf[:9])
    network_num, pc_num, io_num, m_drop_num, length, term_code = tmp

    # データ部抽出
    data = buf[9:]
    new_length = length - 2  # 終了コード分除く
    data = data[:new_length]

    # 残データ管理
    with self.__lock:
        self.__rest = data[new_length:]
```

##### ASCII形式解析
```python
# __recv() (行番号: 186-218)
if buf[0] == ord("D"):  # ASCII
    if buf[1] == ord("0"):  # 3E ASCII
        buf = buf[4:]  # ヘッダスキップ
    elif buf[1] == ord("4"):  # 4E ASCII
        seq = int(buf[4:8].decode("ascii"), base=16)  # シリアル番号
        buf = buf[12:]  # ヘッダスキップ

    # 共通ヘッダ解析（HEX文字列→int変換）
    network_num = int(buf[0:2].decode("ascii"), base=16)
    pc_num = int(buf[2:4].decode("ascii"), base=16)
    io_num = int(buf[4:8].decode("ascii"), base=16)
    m_drop_num = int(buf[8:10].decode("ascii"), base=16)
    length = int(buf[10:14].decode("ascii"), base=16)
    term_code = int(buf[14:18].decode("ascii"), base=16)

    # データ部抽出
    data = buf[18:]
    new_length = length - 4  # 終了コード分除く
    data = data[:new_length]
    data = data.decode("ascii")  # ASCII文字列化
```

**特徴**:
- **動的分岐**: 先頭バイト判定後、3E/4E、Binary/ASCIIで処理分岐
- **struct活用**: Binary形式は`struct.unpack`で高速パース
- **エンコーディング対応**: ASCII形式は16進文字列→int変換
- **データ残存管理**: `self.__rest`で分割受信対応
- **assert検証**: 予期しないフォーマット時に即座にエラー検出


### 2.3 固定/動的決定の比較表

| 項目 | andon | ConMoni | PySLMPClient |
|-----|-------|---------|--------------|
| **フレーム形式** | **動的検出**<br>サブヘッダから自動判定 | **固定**<br>4E Binary専用（実機確認） | **動的検出**<br>先頭バイトから全形式判定 |
| **サブヘッダ検証** | **動的**<br>0xD0/0xD4で3E/4E判定 | **固定**<br>要求: 0x54 0x00（4E標準要求）<br>応答: 0xD4 0x00（実機確認） | **動的**<br>0xD0/0xD4/0x44判定 |
| **データ開始オフセット** | **動的決定**<br>3E→11, 4E→15<br>**✅ 標準仕様準拠** | **固定**<br>コード上: 13バイト目<br>**⚠️ 標準仕様(15)と不一致** | **動的決定**<br>形式により可変<br>**✅ 標準仕様準拠** |
| **終了コード検証** | **動的**<br>パース後に検証 | **なし**<br>検証スキップ | **動的**<br>EndCodeクラスで検証 |
| **デバイス点数** | **動的**<br>実データ長から計算 | **固定**<br>設定ファイルから取得 | **動的**<br>length値から計算 |
| **エンディアン処理** | **明示的**<br>`rawData[0] \| (rawData[1] << 8)` | **文字列反転**<br>`[::-1]`で実現 | **struct使用**<br>`"<H"` (リトルエンディアン) |
| **ビット展開** | **未実装**<br>ワード値のみ | **実装済**<br>16ビット単位展開 | **ユーティリティ関数**<br>`util.unpack_bits()` |


---

## 3. 各プロジェクトの特徴・強み

### 3.1 andon (C#)

**強み**:
- ✅ **堅牢な検証**: 多段階のデータ整合性チェック
- ✅ **動的フレーム判定**: 3E/4E自動対応
- ✅ **構造化処理**: 2段階パイプライン（Raw → Processed → Structured）
- ✅ **拡張性**: 構造体定義による柔軟なマッピング
- ✅ **詳細ログ**: 各処理段階でログ出力、トラブルシューティング容易

**弱み**:
- ⚠️ Binary専用（ASCII未対応）
- ⚠️ ビット展開機能未実装
- ⚠️ 処理段階が多く、単純な読み取りには冗長


### 3.2 ConMoni (Python)

**強み**:
- ✅ **高速処理**: 最小限の検証、直接インデックスアクセス
- ✅ **ビット展開対応**: 16点単位でワード→ビット変換
- ✅ **メモリ効率**: バッファリングによるCSV書き込み最適化
- ✅ **不連続データ対応**: 前回値比較で差分検出
- ✅ **実績**: 本番環境で長期稼働実績

**弱み**:
- ⚠️ 3E Binary専用（変則サブヘッダ 0x54 0x00）
- ⚠️ 検証なし（終了コード、データ長チェックなし）
- ⚠️ エラー耐性低い（異常データ時のハンドリング不足）


### 3.3 PySLMPClient (Python)

**強み**:
- ✅ **完全マルチ対応**: 3E/4E × Binary/ASCII 全組み合わせ
- ✅ **汎用性**: 多様なコマンド対応（Random/Block/Monitor等）
- ✅ **非同期処理**: 別スレッド受信、キュー管理
- ✅ **分割受信対応**: データ残存管理（self.__rest）
- ✅ **ライブラリ品質**: PyPI公開、ドキュメント整備

**弱み**:
- ⚠️ ライブラリ依存（単独利用前提）
- ⚠️ 高レベルAPI（低レベル制御困難）
- ⚠️ オーバーヘッド（汎用性のため処理が重い）


---

## 4. andonへの移植推奨事項

### 4.1 ConMoniから採用すべき機能

#### ✅ ビット展開ロジック
ConMoniの`getPlcData()`で実装されている16ビット展開処理をC#に移植:

```csharp
// ConMoniのビット展開ロジック移植案
public static List<bool> ExpandWordToBits(ushort wordValue)
{
    var bits = new List<bool>(16);
    for (int i = 0; i < 16; i++)
    {
        bits.Add((wordValue & (1 << i)) != 0); // LSB first
    }
    return bits;
}
```

#### ✅ 変換係数対応
ConMoniの`digitControl`（桁数変換係数）をandonに統合:

```csharp
// ProcessedDeviceに変換係数フィールド追加
public class ProcessedDevice
{
    public double ConversionFactor { get; set; } = 1.0;
    public double ConvertedValue => Value * ConversionFactor;
}
```


### 4.2 PySLMPClientから採用すべき機能

#### ✅ ASCII形式対応
現在Binary専用のandonに、ASCII形式サポートを追加:

```csharp
// ASCII形式パーサー追加
private (ushort EndCode, byte[] DeviceData) Parse3EFrameStructureAscii(byte[] rawData)
{
    string response = Encoding.ASCII.GetString(rawData);

    // "D000" で開始するASCII応答
    if (!response.StartsWith("D0"))
        throw new FormatException("Invalid ASCII response");

    string hexEndCode = response.Substring(14, 4);
    ushort endCode = Convert.ToUInt16(hexEndCode, 16);

    // データ部抽出（18文字目以降）
    string dataHex = response.Substring(18);
    byte[] deviceData = ConvertHexStringToBytes(dataHex);

    return (endCode, deviceData);
}
```

#### ✅ データ残存管理
分割受信対応のため、PySLMPClientの`self.__rest`ロジックを移植:

```csharp
// PlcCommunicationManagerにフィールド追加
private byte[] _receiveBuffer = Array.Empty<byte>();

private async Task<byte[]> ReceiveCompleteFrameAsync(CancellationToken ct)
{
    // 前回残データと今回受信データを連結
    byte[] newData = await networkStream.ReadAsync(buffer, ct);
    byte[] combined = _receiveBuffer.Concat(newData).ToArray();

    // フレーム完全性チェック
    if (IsFrameComplete(combined))
    {
        _receiveBuffer = Array.Empty<byte>();
        return combined;
    }
    else
    {
        _receiveBuffer = combined; // 次回に持ち越し
        return null; // フレーム未完成
    }
}
```


### 4.3 改善推奨項目

#### ⚠️ サブヘッダの標準化
- **現状**: 0xD0 0x00 / 0xD4 0x00のみ対応
- **推奨**: ConMoniの変則サブヘッダ 0x54 0x00 も試験的にサポート
  - PLC機種によっては標準サブヘッダでエラーになる場合がある
  - 設定で切り替え可能にする

```csharp
// appsettings.jsonに設定項目追加
"AlternativeSubheader": {
    "Enabled": true,
    "Frame3E": "0x5400",  // 変則サブヘッダ
    "Frame4E": "0x5400"
}
```


#### ⚠️ エラーコードマッピング強化
PySLMPClientの`EndCode`クラスのような詳細エラーマッピングを追加:

```csharp
public static class SlmpErrorCodes
{
    public static readonly Dictionary<ushort, string> ErrorMessages = new()
    {
        { 0x0000, "正常終了" },
        { 0xC050, "アスキー変換エラー" },
        { 0xC051, "不正なデバイスコード" },
        { 0xC056, "デバイス範囲超過" },
        { 0xC059, "データ長不一致" },
        // ... (PySLMPClientのEndCode定義を参考に拡張)
    };
}
```


---

## 5. 技術的知見まとめ

### 5.1 共通仕様

| 項目 | 仕様 | 3プロジェクト対応状況 |
|-----|------|---------------------|
| **リトルエンディアン** | 2バイト以上の数値は下位バイト先 | ✅ 全プロジェクト対応 |
| **デバイスデータ配置** | 2バイト単位で連続配置 | ✅ 全プロジェクト対応 |
| **ビット順序** | ワード内はLSB first | ✅ ConMoni, PySLMPClientのみ |
| **終了コード位置** | 3E→9-10バイト目<br>4E→13-14バイト目 | andon, PySLMPClientのみ検証 |


### 5.2 実装パターン分類

| パターン | 適用例 | 長所 | 短所 |
|---------|-------|------|------|
| **固定オフセット直接アクセス** | ConMoni | 高速、シンプル | 柔軟性低、エラー脆弱 |
| **動的検証パイプライン** | andon | 堅牢、デバッグ容易 | 処理コスト高 |
| **汎用ライブラリアプローチ** | PySLMPClient | 再利用性高、多機能 | カスタマイズ困難 |


### 5.3 ビット展開処理の違い

#### ConMoniのビット展開
```python
binary = format(r.astype(np.uint16), '016b')  # 16ビット文字列化
binary = binary[::-1]  # 文字列反転 (LSB first化)
binary_list = list(map(int, binary))  # [1,0,1,0,...]
```

#### PySLMPClientのビット展開
```python
data = np.asarray(data, dtype=np.uint8)
byte_array2d = data.reshape((data.size, 1))
byte_array2d_bin = np.unpackbits(byte_array2d, axis=1)
return list(byte_array2d_bin[:, ::-1].flatten())  # NumPy高速処理
```

**andon移植推奨**:
- C#の`BitArray`またはビット演算を使用
- NumPyのような配列操作ライブラリはないため、ループ処理で実装
- パフォーマンス重視ならSIMD命令活用も検討


---

## 6. 結論

### 各プロジェクトの位置づけ

- **andon**:
  - 業務用途に特化、堅牢性重視
  - 移植先として最も拡張余地がある

- **ConMoni**:
  - 現場稼働実績あり、実用性が実証済み
  - ビット展開・桁数変換などの実用機能を参考にすべき

- **PySLMPClient**:
  - 技術的完成度が最も高い
  - ASCII対応、全フレーム対応など、andonの将来的な拡張目標

### 移植優先順位

1. **高優先**: ConMoniのビット展開ロジック（即座に必要）
2. **中優先**: PySLMPClientのASCII対応（互換性向上）
3. **低優先**: データ残存管理（TCP環境で顕在化する場合のみ）

---

## 7. 詳細処理フロー（ステップ分解）

### 7.1 andon: ProcessReceivedRawData() 詳細フロー

#### Step-1 初期検証と準備
1. 入力パラメータ検証（rawData == null?）
2. nullまたは空配列の場合はArgumentExceptionスロー
3. processedRequestInfo == null?
4. nullの場合はArgumentExceptionスロー
5. 処理開始時刻記録（DateTime.Now）
6. パフォーマンス計測開始（Stopwatch.Start）
7. ログ出力
   - データ長（rawData.Length）
   - デバイス情報（DeviceType、StartAddress）
   - 開始時刻（HH:mm:ss.fff）
8. BasicProcessedResponseDataオブジェクト生成
   - IsSuccess = true
   - ProcessedDevices = 空リスト
   - Errors/Warnings = 空リスト
   - ProcessedAt = startTime
   - TotalDataSizeBytes = rawData.Length

#### Step-2 フレームタイプ自動判定
1. DetectFrameTypeFromSubheader()呼び出し
2. サブヘッダ先頭2バイトチェック（rawData[0], rawData[1]）
3. サブヘッダ判定
   - 0xD0 0x00 → FrameType.Frame3E
   - 0xD4 0x00 → FrameType.Frame4E
   - その他 → FormatExceptionスロー
4. 判定成功ログ出力（フレームタイプ）
5. 判定失敗時はエラーログ出力後に例外再スロー
6. 要求フレームタイプとの一致確認（processedRequestInfo.FrameType == detectedFrameType?）
7. 不一致の場合は警告メッセージ生成
   - 警告内容を result.Warnings に追加
   - 検出値を優先して処理継続

#### Step-3 SLMP構造検証
1. ValidateSlmpFrameStructure()呼び出し
2. 最小フレーム長チェック
   - 3E: 11バイト以上?
   - 4E: 15バイト以上?
3. 長さ不足時はfalse返却
4. フレームタイプ別検証
   - 3E: サブヘッダ 0xD0 0x00確認
   - 4E: サブヘッダ 0xD4 0x00確認、予約領域 0x00 0x00確認
5. 検証失敗時はFormatExceptionスロー（"無効なRawDataフォーマット"）

#### Step-4 フレーム構造解析（動的分岐）
1. フレームタイプ判定（detectedFrameType == FrameType.Frame4E?）
2. **4Eフレームの場合**: Parse4EFrameStructure()呼び出し
   - サブヘッダスキップ（2バイト）
   - シリアル番号抽出（rawData[2] | rawData[3] << 8）
   - 予約領域スキップ（2バイト）
   - ネットワーク番号、PC番号、I/O番号、マルチドロップ局番読み取り
   - データ長抽出（rawData[11] | rawData[12] << 8）
   - 終了コード抽出（rawData[13] | rawData[14] << 8）
   - デバイスデータ抽出（15バイト目以降、Array.Copy使用）
   - (EndCode, DeviceData)タプル返却
3. **3Eフレームの場合**: Parse3EFrameStructure()呼び出し
   - サブヘッダスキップ（2バイト）
   - ネットワーク番号、PC番号、I/O番号、マルチドロップ局番読み取り
   - データ長抽出（rawData[7] | rawData[8] << 8）
   - 終了コード抽出（rawData[9] | rawData[10] << 8）
   - デバイスデータ抽出（11バイト目以降、Array.Copy使用）
   - (EndCode, DeviceData)タプル返却

#### Step-5 終了コード確認
1. 終了コードチェック（frameData.EndCode == 0x0000?）
2. 0x0000以外の場合はInvalidOperationExceptionスロー
   - エラーメッセージ: "無効な終了コード: {EndCode:X4}"
3. 正常時は処理継続

#### Step-6 デバイス値抽出
1. ExtractDeviceValues()呼び出し
   - 入力: frameData.DeviceData, processedRequestInfo, startTime
2. デバイス点数計算（DeviceData.Length / 2）
3. 2バイトずつループ処理
   - リトルエンディアン変換（下位バイト | 上位バイト << 8）
   - ProcessedDeviceオブジェクト生成
     - DeviceName: "{DeviceType}{StartAddress + index}"
     - Value: 変換後の値
     - DataType: "Word" または "DWord"
     - ReadAt: startTime
4. ProcessedDeviceリスト返却

#### Step-7 結果構築とログ出力
1. 抽出デバイスをループ処理
2. 各デバイスを result.ProcessedDevices に追加
3. デバッグログ出力（デバイス名、値、データ型）
4. 処理デバイス数カウント（result.ProcessedDeviceCount = ProcessedDevices.Count）
5. ストップウォッチ停止（stopwatch.Stop）
6. 処理時間記録（result.ProcessingTimeMs = Math.Max(ElapsedMilliseconds, 1)）
7. 完了ログ出力
   - 処理デバイス数
   - 所要時間（ms）
8. result返却

#### Step-8 エラーハンドリング
1. 例外キャッチ（ArgumentException, FormatException, InvalidOperationException, NotSupportedException, Exception）
2. HandleProcessingError()呼び出し
   - ストップウォッチ停止
   - 処理時間記録
   - result.IsSuccess = false設定
   - 例外メッセージを result.Errors に追加
   - エラーログ出力（例外タイプ、メッセージ）
3. エラー状態の result 返却


### 7.2 andon: ParseRawToStructuredData() 詳細フロー

#### Step-1 初期検証
1. processedData == null?
2. null時はArgumentExceptionスロー
3. processedRequestInfo == null?
4. null時はArgumentExceptionスロー
5. processedData.IsSuccess == true?
6. false時はInvalidOperationExceptionスロー（"失敗状態で構造化処理不可"）

#### Step-2 処理準備
1. 開始時刻記録（DateTime.UtcNow）
2. ストップウォッチ開始（Stopwatch.Start）
3. 情報ログ出力
   - 処理済みデバイス数（processedData.TotalProcessedDevices）
   - 構造定義数（ParseConfiguration.StructureDefinitions.Count）
4. StructuredDataオブジェクト生成
   - IsSuccess = true
   - StructuredDevices = 空リスト
   - ProcessedAt = startTime
   - FrameInfo = CreateFrameInfo()呼び出し結果
   - ParseSteps, Errors, Warnings = 空リスト

#### Step-3 キャンセレーション確認
1. cancellationToken.ThrowIfCancellationRequested()
2. キャンセル要求時はOperationCanceledExceptionスロー

#### Step-4 フレーム解析開始
1. フレームタイプ取得（result.FrameInfo.FrameType）
2. 解析ステップ記録（"{FrameType}フレーム解析開始"）

#### Step-5 構造化設定検証
1. 構造定義存在チェック（ParseConfiguration.StructureDefinitions.Any() == true?）
2. 定義なしの場合:
   - 警告追加（"構造定義が指定されていません"）
   - 解析ステップ記録（"基本構造化処理完了（構造定義なし）"）
   - ストップウォッチ停止
   - 処理時間記録
   - 警告ログ出力
   - result返却（早期終了）
3. 定義ありの場合: 次ステップ継続

#### Step-6 構造体定義ループ処理
1. StructureDefinitionsをforeachループ
2. 各構造定義に対して:
   - キャンセレーション確認
   - デバッグログ出力（構造体名、フィールド数）
   - ProcessSingleStructure()呼び出し
     - 入力: structureDef, processedData, startTime, cancellationToken
     - 処理内容:
       - StructuredDeviceオブジェクト生成
       - 各フィールド定義ループ
       - processedData内の該当デバイス検索
       - フィールド値マッピング
       - StructuredFieldリスト構築
     - 返却: StructuredDeviceオブジェクト
   - 成功時:
     - result.AddStructuredDevice()で結果追加
     - 解析ステップ記録（"構造化データ '{Name}' の解析完了"）
     - デバッグログ出力（構造体名、フィールド数）
   - 例外発生時:
     - エラーメッセージ生成
     - result.Warnings に追加
     - 解析ステップ記録（"構造体 '{Name}' の解析失敗"）
     - 警告ログ出力
     - 処理継続（次の構造定義へ）

#### Step-7 解析完了処理
1. 解析ステップ記録（"全構造体解析完了"）
2. ストップウォッチ停止（stopwatch.Stop）
3. 処理時間記録（result.ProcessingTimeMs = Math.Max(ElapsedMilliseconds, 1)）
4. 完了ログ出力
   - 構造化デバイス数（StructuredDevices.Count）
   - 解析ステップ数（ParseSteps.Count）
   - 所要時間（ms）
5. result返却

#### Step-8 例外ハンドリング
1. **OperationCanceledExceptionキャッチ**:
   - ストップウォッチ停止
   - 処理時間記録
   - IsSuccess = false設定
   - エラー追加（"構造化処理がキャンセルされました"）
   - 警告ログ出力
   - 例外再スロー
2. **一般Exceptionキャッチ**:
   - ストップウォッチ停止
   - 処理時間記録
   - IsSuccess = false設定
   - エラー追加（"構造化処理エラー: {Message}"）
   - エラーログ出力
   - result返却（例外スロー無し）


### 7.3 ConMoni: getPlcData() 詳細フロー

#### Step-1 リクエスト送信
1. 接続状態確認（self.sock != None?）
2. 未接続時は例外スロー
3. 送信フレーム取得（self.settingData["accessPlcSetting"]）
4. bytes型変換
5. ソケット送信（self.sock.send(bytes(...))）
6. 送信完了確認（返却値 > 0?）
7. 送信失敗時は例外スロー
8. 送信統計記録
   - 送信フレーム数 +1
   - 送信バイト数加算
   - 送信時刻記録（datetime.now()）

#### Step-2 データ受信
1. PLCレスポンス待機（self.sock.recv(self.BUFSIZE)）
2. タイムアウト設定確認（デフォルト2秒）
3. タイムアウト内で受信確認（len(res) > 0?）
4. タイムアウト時:
   - メッセージ出力（"時間内に受信なし"）
   - None返却（早期終了）
5. 受信統計記録
   - 受信フレーム数 +1
   - 受信バイト数加算（len(res)）
   - 受信時刻記録（datetime.now()）
6. HEX文字列変換
   - resRaw = [format(i,'02X') for i in res]
   - バイト配列 → ['D0','00','00',...] 形式

#### Step-3 前回値比較（不連続モード時）
1. モード確認（self.mode == "discontinuous"?）
2. 不連続モード時:
   - 前回データ取得（self.previousData）
   - 現在データとの比較（resRaw == self.previousData?）
   - 一致時:
     - None返却（差分なし、データ更新なし）
   - 不一致時:
     - 処理継続
3. 連続モード時: このステップスキップ

#### Step-4 デバイス値抽出
1. デバイス点数取得（accessPlcSetting[19] + 1）
2. 空リスト初期化（tmpData = []）
3. デバイス点数分ループ（for x in range(0, device_count)）
   - 開始インデックス計算（13 + 2*x）
   - 2バイト抽出（resRaw[13+2*x:15+2*x]）
   - リトルエンディアン変換（[::-1]で反転）
   - HEX文字列結合（''.join(...)）
   - int変換（int(..., 16)）
   - tmpDataリストに追加
4. デバイス値リスト完成（tmpData）

#### Step-5 桁数変換
1. 変換係数取得（self.digitControl）
2. NumPy配列変換（np.array(tmpData)）
3. スカラー乗算（array * digitControl）
4. 変換結果保存（calcTempData）

#### Step-6 ビット展開処理
1. 空リスト初期化（final_result = []）
2. ビット展開フラグ取得（self.settingData["accessBitDataLoc"]）
3. 変換済みデータとフラグをzip（zip(calcTempData, accessBitDataLoc)）
4. 各値に対してループ処理:
   - **ビット展開フラグ == 1の場合**:
     - 16ビットバイナリ文字列変換（format(r.astype(np.uint16), '016b')）
     - ビット順反転（binary[::-1]、LSB first化）
     - 文字リストをint変換（list(map(int, binary))）
     - final_resultにextend（16要素追加）
   - **ビット展開フラグ == 0の場合**:
     - ワード値そのまま追加（final_result.append(r)）
5. 最終結果リスト完成（final_result）

#### Step-7 タイムスタンプ付与
1. 現在時刻取得（datetime.now()）
2. リスト先頭に挿入（final_result.insert(0, timestamp)）

#### Step-8 データ蓄積
1. 蓄積バッファ追加（self.writeData.append(final_result)）
2. バッファ長確認（len(self.writeData) >= 60?）
3. **60回分蓄積済みの場合**:
   - CSV書き込み処理起動
   - ファイルパス生成
   - pandas DataFrameに変換
   - CSV出力（to_csv()）
   - バッファクリア（self.writeData.clear()）
   - 出力ログ記録
4. **60回未満の場合**:
   - 次回まで蓄積継続
5. final_result返却


### 7.4 PySLMPClient: __recv() 詳細フロー

#### Step-1 データ受信（ノンブロッキング）
1. ソケット受信呼び出し（self.__socket.recv(512)）
2. 受信データ長確認（len(buf) > 0?）
3. 0バイト受信時:
   - 接続切断と判定
   - 例外スロー（"Connection closed"）
4. 前回残データ結合（buf = self.__rest + buf）
5. 結合後データ長確認（len(buf) >= 11?）
6. 11バイト未満時:
   - 残データ保存（self.__rest = buf）
   - None返却（フレーム未完成、次回継続）

#### Step-2 フレーム形式判定（動的・マルチ対応）
1. **先頭バイト判定**:
   - **buf[0] == ord("D")** → ASCII形式
   - **buf[0] == 0xD0** → 3E Binary形式
   - **buf[0] == 0xD4** → 4E Binary形式
   - **その他** → 不明形式エラー

#### Step-3-A ASCII形式解析（buf[0] == ord("D")の場合）
1. 2バイト目判定（buf[1]）:
   - **buf[1] == ord("0")** → 3E ASCII
     - ヘッダスキップ（buf = buf[4:]）
   - **buf[1] == ord("4")** → 4E ASCII
     - シリアル番号抽出（buf[4:8].decode("ascii")、16進変換）
     - ヘッダスキップ（buf = buf[12:]）
2. 共通ヘッダ解析（ASCII 16進文字列→int変換）:
   - network_num = int(buf[0:2], base=16)
   - pc_num = int(buf[2:4], base=16)
   - io_num = int(buf[4:8], base=16)
   - m_drop_num = int(buf[8:10], base=16)
   - length = int(buf[10:14], base=16)
   - term_code = int(buf[14:18], base=16)
3. データ部抽出:
   - 開始位置: 18文字目
   - 実データ長計算（length - 4、終了コード分除外）
   - data = buf[18:18+new_length]
   - ASCII文字列デコード（data.decode("ascii")）
4. 残データ管理:
   - 残データ = buf[18+new_length:]
   - ロックして保存（self.__rest = 残データ）

#### Step-3-B Binary形式解析（buf[0] == 0xD0 or 0xD4の場合）
1. **3E Binary判定（buf[0] == 0xD0）**:
   - サブヘッダ検証（buf[1] == 0x00?）
   - 検証失敗時はassertエラー
   - ヘッダスキップ（buf = buf[2:]）
2. **4E Binary判定（buf[0] == 0xD4）**:
   - サブヘッダ検証（buf[:2] == b"\xd4\x00"?）
   - 検証失敗時はassertエラー
   - シリアル番号抽出（struct.unpack("<H", buf[2:4])）
   - 予約領域検証（buf[4:6] == b"\x00\x00"?）
   - ヘッダスキップ（buf = buf[6:]）
3. 共通ヘッダ解析（struct.unpack使用）:
   - tmp = struct.unpack("<BBHBHH", buf[:9])
   - network_num, pc_num, io_num, m_drop_num, length, term_code = tmp
4. データ部抽出:
   - data = buf[9:]
   - 実データ長計算（length - 2、終了コード分除外）
   - data = data[:new_length]
5. 残データ管理:
   - 残データ = data[new_length:]
   - ロックして保存（self.__rest = 残データ）

#### Step-4 データ長検証
1. 実際のデータ長チェック（len(data) >= new_length?）
2. データ不足時:
   - バッファ全体を残データ保存（self.__rest = buf）
   - None返却（次回受信待ち）
3. データ充足時: 次ステップ継続

#### Step-5 受信キューへ格納
1. シーケンス番号取得（seqまたはデフォルト値）
2. 受信データタプル生成:
   - (network_num, pc_num, io_num, m_drop_num, length, term_code, data)
3. ロック取得（self.__lock）
4. キューへ格納（self.__recv_queue[seq] = タプル）
5. ロック解放
6. 格納完了ログ出力（デバッグレベル）


### 7.5 PySLMPClient: read_word_devices() 詳細フロー

#### Step-1 入力パラメータ検証
1. デバイスコード確認（device in DeviceConstants?）
2. 未定義デバイス時は例外スロー（"Invalid device code"）
3. 読み取り点数確認（size > 0?）
4. 0点以下時は例外スロー（"Invalid size"）
5. 開始アドレス確認（start_address >= 0?）
6. 負値時は例外スロー（"Invalid start address"）

#### Step-2 コマンドフレーム構築
1. __cmd_format()呼び出し
   - コマンドコード設定（0x0401、一括読み出し）
   - サブコマンド設定（0x0000、ワードデバイス）
   - デバイスコード変換（device → 16進）
   - 開始アドレス設定（リトルエンディアン）
   - 読み取り点数設定（リトルエンディアン）
2. フレーム形式分岐:
   - **Binary形式**:
     - struct.pack("<HH", cmd, subcmd) + address_bytes + size_bytes
   - **ASCII形式**:
     - f"{cmd:04X}{subcmd:04X}{address:06X}{size:04X}"
3. シーケンス番号インクリメント（self.__seq += 1）
4. ヘッダ付与:
   - 3E: サブヘッダ + ネットワーク情報 + データ長 + コマンド
   - 4E: サブヘッダ + シリアル + 予約 + ネットワーク情報 + データ長 + コマンド
5. 送信フレーム完成

#### Step-3 コマンド送信
1. ソケット接続確認（self.__socket != None?）
2. 未接続時は例外スロー（"Not connected"）
3. 送信実行（self.__socket.send(frame)）
4. 送信バイト数確認（返却値 == len(frame)?）
5. 送信失敗時は例外スロー（"Send failed"）
6. 送信統計記録
   - 送信フレーム数 +1
   - 送信バイト数加算
   - 送信時刻記録

#### Step-4 応答待機
1. __recv_loop()呼び出し（別スレッドで受信継続）
2. シーケンス番号でキュー監視
3. タイムアウト設定確認（デフォルト2秒）
4. **タイムアウト内で応答受信**:
   - self.__recv_queue[seq]取得
   - (network_num, pc_num, io_num, m_drop_num, length, term_code, data)展開
5. **タイムアウト発生**:
   - SLMPCommunicationError例外スロー（"Response timeout"）

#### Step-5 終了コード検証
1. 終了コード取得（term_code）
2. EndCode.Success（0x0000）との比較
3. **成功時（0x0000）**:
   - 処理継続
4. **エラー時（0x0000以外）**:
   - エラーコードマッピング（EndCodeクラス参照）
   - SLMPCommunicationError例外スロー
   - エラーメッセージ: "PLC returned error: {error_name}({term_code:04X})"

#### Step-6 データ型別デコード
1. データ部取得（data[5:]、先頭5バイトはヘッダ情報）
2. **Binary形式の場合**:
   - array.array('H', data[5:])でuint16配列化
   - リトルエンディアン自動変換
   - リスト返却（list(array_data)）
3. **ASCII形式の場合**:
   - 4文字ずつループ処理
   - 各チャンクを16進→int変換
   - リスト構築
4. データ点数確認（len(result) == size?）
5. 不一致時は警告ログ出力
6. デバイス値リスト返却

#### Step-7 統計情報更新
1. 受信統計記録
   - 成功読み取り回数 +1
   - 読み取りデバイス総数 += size
   - 平均応答時間更新
2. デバッグログ出力
   - デバイスコード、開始アドレス、読み取り点数
   - 応答時間（ms）
   - 先頭データ値（プレビュー）

---

## 8. 実機通信データ検証結果

### 8.1 検証環境

| 項目 | 内容 |
|-----|------|
| PLC機種 | 三菱電機製（型番未確認） |
| PLC IP | 172.30.40.15 |
| PLC Port | 8192 |
| プロトコル | UDP |
| 使用フレーム | 4E Binary |
| コマンド | 0x0403（ランダム読出し） |

### 8.2 実機データ詳細

#### 送信フレーム（要求）

```
0000: 54 00 00 00 00 00 00 FF FF 03 00 C8 00 20 00 03  T............ ..
0010: 04 00 00 30 00 48 EE 00 A8 4B EE 00 A8 52 EE 00  ...0.H...K...R..
...
```

**フレーム解析**:
- サブヘッダ: `0x54 0x00`（4E標準要求） ✅
- シーケンス番号: `0x0000`
- データ長: `0x00C8`（200バイト）
- 監視タイマ: `0x0020`（32 = 8秒）
- コマンド: `0x0403`（ランダム読出し）
- ワード点数: `0x30`（48点）

#### 応答フレーム（受信）

```
0000: D4 00 00 00 00 00 00 FF FF 03 00 62 00 00 00 FF  ...........b....
0010: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF  ................
...
```

**フレーム解析**:
- サブヘッダ: `0xD4 0x00`（4E標準応答） ✅
- シーケンス番号: `0x0000`
- データ長: `0x0062`（98バイト）
- 終了コード: `0x0000`（正常終了） ✅
- **デバイスデータ開始位置**: **15バイト目（Idx 15）** ✅ **標準仕様通り**

#### バイト配置詳細

```
Idx  0-1:  D4 00        ← サブヘッダ
Idx  2-3:  00 00        ← シーケンス番号
Idx  4-5:  00 00        ← 予約
Idx  6:    00           ← ネットワーク番号
Idx  7:    FF           ← PC番号
Idx  8-9:  FF 03        ← I/O番号
Idx  10:   00           ← 局番
Idx  11-12: 62 00       ← データ長（98バイト）
Idx  13-14: 00 00       ← 終了コード ⚠️ ConMoniはここから読み取り？
Idx  15~:  FF FF ...    ← デバイスデータ ✅ 標準仕様の開始位置
```

### 8.3 検証結果まとめ

| 項目 | 標準仕様 | 実機データ | andon実装 | ConMoni実装 | 評価 |
|-----|---------|----------|----------|------------|------|
| **要求サブヘッダ** | 0x54 0x00 | 0x54 0x00 | 未実装 | 0x54 0x00 | ✅ ConMoni正確 |
| **応答サブヘッダ** | 0xD4 0x00 | 0xD4 0x00 | 0xD4 0x00 | 0xD4 0x00 | ✅ 全て正確 |
| **データオフセット** | 15バイト目 | 15バイト目 | 15バイト目 | 13バイト目（コード上） | ⚠️ ConMoni要検証 |
| **終了コード位置** | 13-14バイト | 13-14バイト | 13-14バイト | 検証なし | ✅ andon正確 |
| **データ長計算** | 98バイト | 98バイト | 動的計算 | 固定値 | ✅ andon柔軟性高 |

### 8.4 ConMoniの13バイトオフセットについて

**疑問点**: ConMoniのコードでは `resRaw[13+2*x:15+2*x]` となっており、13バイト目から読み取っているが、標準仕様では15バイト目が正しい。

**考えられる理由**:
1. **HEX文字列リストのインデックス計算誤差**: バイト配列 → HEX文字列リスト変換時に何らかのオフセットが発生
2. **終了コードを最初のデバイス値として読んでいる**: 13-14バイト目は終了コード `0x00 0x00`
3. **実際には正しく動作している**: コードと実際の動作が異なる可能性（要デバッグ確認）

**andon実装への影響**: ConMoniの13バイト方式は採用せず、標準仕様の15バイト目を使用すべき。

---

## 9. andon実装推奨方針（最終版）

### 9.1 基本方針

**目標**: 標準SLMP仕様に準拠した、堅牢で拡張性の高いフレーム解析機能の実装

**設計哲学**:
1. **標準仕様優先**: SLMP仕様書に準拠した実装
2. **動的判定**: フレーム形式の自動検出
3. **多層検証**: データ整合性の複数段階チェック
4. **実績機能の選択的採用**: ConMoniのビット展開機能など実用的機能を取り込み
5. **段階的拡張**: Binary → ASCII、3E/4E全対応へ段階実装

### 9.2 優先度別実装計画

#### 🔴 Phase 1: ASCII形式対応（最優先）

**目標**: PySLMPClient方式の完全実装

##### 1-1. フレーム自動判定機能

```csharp
/// <summary>
/// 応答フレームタイプの自動判定（Binary/ASCII、3E/4E）
/// </summary>
private FrameType DetectResponseFrameType(byte[] rawData)
{
    if (rawData.Length < 2)
        throw new ArgumentException("Data too short for frame detection");

    // ASCII判定（PySLMPClient方式）
    if (rawData[0] == 0x44) // 'D'
    {
        return rawData[1] switch
        {
            0x30 => FrameType.Frame3E_ASCII,  // "D0"
            0x34 => FrameType.Frame4E_ASCII,  // "D4"
            _ => throw new FormatException(
                $"Invalid ASCII response subheader: D{(char)rawData[1]}")
        };
    }

    // Binary判定
    return (rawData[0], rawData[1]) switch
    {
        (0xD0, 0x00) => FrameType.Frame3E_Binary,
        (0xD4, 0x00) => FrameType.Frame4E_Binary,
        _ => throw new FormatException(
            $"Unknown response subheader: 0x{rawData[0]:X2} 0x{rawData[1]:X2}")
    };
}
```

**実装要件**:
- ✅ 実機データで動作確認（4E Binary）
- 🔲 ASCII形式の追加実装
- 🔲 単体テストケース作成

##### 1-2. データオフセット決定（標準仕様準拠）

```csharp
/// <summary>
/// フレームタイプに応じたデバイスデータ開始位置を取得
/// </summary>
private int GetDeviceDataOffset(FrameType frameType) => frameType switch
{
    // Binary形式（実機確認済み）
    FrameType.Frame3E_Binary => 11,   // 標準仕様 ✅
    FrameType.Frame4E_Binary => 15,   // 標準仕様 ✅ 実機データで確認

    // ASCII形式（文字位置）
    FrameType.Frame3E_ASCII => 20,    // 標準仕様（20文字目～）
    FrameType.Frame4E_ASCII => 30,    // 標準仕様（30文字目～）

    _ => throw new NotSupportedException(
        $"Unsupported frame type: {frameType}")
};
```

**実装要件**:
- ✅ Binary形式は既に実装済み
- 🔲 ASCII形式オフセットの追加
- 🔲 境界チェック強化

##### 1-3. ASCII形式パーサー実装

```csharp
/// <summary>
/// 3E ASCII応答フレームの解析
/// </summary>
private (ushort EndCode, byte[] DeviceData) Parse3EFrameStructureAscii(byte[] rawData)
{
    string response = Encoding.ASCII.GetString(rawData);

    // "D0" で開始確認
    if (!response.StartsWith("D0"))
        throw new FormatException("Invalid 3E ASCII response");

    // ヘッダ解析（2文字目～19文字目）
    string hexEndCode = response.Substring(16, 4);  // 終了コード
    ushort endCode = Convert.ToUInt16(hexEndCode, 16);

    // データ部抽出（20文字目以降）
    string dataHex = response.Substring(20);

    // HEX文字列 → バイト配列変換（2文字ずつ）
    byte[] deviceData = new byte[dataHex.Length / 4];
    for (int i = 0; i < deviceData.Length; i++)
    {
        string wordHex = dataHex.Substring(i * 4, 4);
        deviceData[i * 2] = Convert.ToByte(wordHex.Substring(2, 2), 16);     // 下位
        deviceData[i * 2 + 1] = Convert.ToByte(wordHex.Substring(0, 2), 16); // 上位
    }

    return (endCode, deviceData);
}

/// <summary>
/// 4E ASCII応答フレームの解析
/// </summary>
private (ushort EndCode, byte[] DeviceData) Parse4EFrameStructureAscii(byte[] rawData)
{
    string response = Encoding.ASCII.GetString(rawData);

    // "D4" で開始確認
    if (!response.StartsWith("D4"))
        throw new FormatException("Invalid 4E ASCII response");

    // シーケンス番号抽出（4文字目～7文字目）
    string hexSeq = response.Substring(4, 4);
    ushort sequenceNumber = Convert.ToUInt16(hexSeq, 16);

    // ヘッダ解析（12文字目～29文字目）
    string hexEndCode = response.Substring(26, 4);  // 終了コード
    ushort endCode = Convert.ToUInt16(hexEndCode, 16);

    // データ部抽出（30文字目以降）
    string dataHex = response.Substring(30);

    // HEX文字列 → バイト配列変換
    byte[] deviceData = new byte[dataHex.Length / 4];
    for (int i = 0; i < deviceData.Length; i++)
    {
        string wordHex = dataHex.Substring(i * 4, 4);
        deviceData[i * 2] = Convert.ToByte(wordHex.Substring(2, 2), 16);
        deviceData[i * 2 + 1] = Convert.ToByte(wordHex.Substring(0, 2), 16);
    }

    return (endCode, deviceData);
}
```

**実装要件**:
- 🔲 3E/4E ASCII形式パーサー実装
- 🔲 エラーハンドリング強化
- 🔲 単体テストケース作成

#### 🟡 Phase 2: ビット展開機能（高優先）

**目標**: ConMoni互換のビット展開機能実装

##### 2-1. ビット展開ユーティリティ

```csharp
/// <summary>
/// ConMoni互換のビット展開ユーティリティ
/// </summary>
public static class BitExpansionUtility
{
    /// <summary>
    /// ワード値を16ビット配列に展開（LSB first）
    /// </summary>
    public static bool[] ExpandWordToBits(ushort wordValue)
    {
        var bits = new bool[16];
        for (int i = 0; i < 16; i++)
        {
            bits[i] = (wordValue & (1 << i)) != 0;  // LSB first
        }
        return bits;
    }

    /// <summary>
    /// 選択的ビット展開（ConMoniの accessBitDataLoc 互換）
    /// </summary>
    public static List<object> ExpandWithSelectionMask(
        ushort[] wordValues,
        bool[] bitExpansionMask,
        double[]? conversionFactors = null)
    {
        if (wordValues.Length != bitExpansionMask.Length)
            throw new ArgumentException("Mask length mismatch");

        var result = new List<object>();

        for (int i = 0; i < wordValues.Length; i++)
        {
            double convertedValue = wordValues[i];

            // 変換係数適用（ConMoniの digitControl 互換）
            if (conversionFactors != null && i < conversionFactors.Length)
                convertedValue = wordValues[i] * conversionFactors[i];

            if (bitExpansionMask[i])
            {
                // ビット展開
                var bits = ExpandWordToBits((ushort)convertedValue);
                result.AddRange(bits.Cast<object>());
            }
            else
            {
                // ワード値そのまま
                result.Add(convertedValue);
            }
        }

        return result;
    }
}
```

**実装要件**:
- 🔲 ビット展開ロジック実装
- 🔲 変換係数対応
- 🔲 ProcessedDeviceクラスへの統合

#### 🟢 Phase 3: 検証機能強化（中優先）

##### 3-1. デバイス点数多層検証

```csharp
/// <summary>
/// デバイス点数の多層検証
/// </summary>
private (int DeviceCount, List<string> ValidationWarnings) ValidateDeviceCount(
    byte[] rawData,
    FrameType frameType,
    int expectedCountFromRequest)
{
    var warnings = new List<string>();

    // 方法1: データ長フィールドから計算
    int dataLengthFromHeader = ExtractDataLengthField(rawData, frameType);
    int deviceCountFromHeader = (dataLengthFromHeader - 2) / 2;

    // 方法2: 実データ長から計算
    int deviceDataOffset = GetDeviceDataOffset(frameType);
    int deviceDataLength = rawData.Length - deviceDataOffset;
    int deviceCountFromActualData = deviceDataLength / 2;

    // 検証1: ヘッダ値と実データの一致
    if (deviceCountFromHeader != deviceCountFromActualData)
    {
        warnings.Add(
            $"[WARNING] Device count mismatch: " +
            $"FromHeader={deviceCountFromHeader}, " +
            $"FromActualData={deviceCountFromActualData}");
    }

    // 検証2: 要求値との照合
    if (deviceCountFromActualData != expectedCountFromRequest &&
        expectedCountFromRequest > 0)
    {
        warnings.Add(
            $"[INFO] Device count differs from request: " +
            $"Actual={deviceCountFromActualData}, " +
            $"Expected={expectedCountFromRequest}");
    }

    // 実データ長を最優先
    return (deviceCountFromActualData, warnings);
}
```

##### 3-2. 詳細エラーコードマッピング

```csharp
/// <summary>
/// SLMP終了コード詳細マッピング（PySLMPClient互換）
/// </summary>
public static class SlmpErrorCodes
{
    public static readonly Dictionary<ushort, SlmpErrorInfo> ErrorCatalog = new()
    {
        // 正常系
        { 0x0000, new("Success", "正常終了", ErrorSeverity.None) },

        // コマンド関連エラー
        { 0xC050, new("AsciiConversionError", "ASCII変換エラー", ErrorSeverity.Critical) },
        { 0xC051, new("InvalidDeviceCode", "不正なデバイスコード", ErrorSeverity.Error) },
        { 0xC056, new("DeviceRangeExceeded", "デバイス範囲超過", ErrorSeverity.Error) },
        { 0xC059, new("DataLengthMismatch", "データ長不一致", ErrorSeverity.Error) },
        { 0xC05B, new("InvalidCommand", "不正なコマンド", ErrorSeverity.Error) },

        // PLC状態エラー
        { 0xC100, new("PlcRunMode", "PLC RUNモード中", ErrorSeverity.Warning) },
        { 0xC101, new("PlcStopMode", "PLC STOPモード中", ErrorSeverity.Warning) },

        // 通信エラー
        { 0xC200, new("CommunicationTimeout", "通信タイムアウト", ErrorSeverity.Critical) },
        { 0xC201, new("CommunicationError", "通信エラー", ErrorSeverity.Critical) },
    };

    public static SlmpErrorInfo GetErrorInfo(ushort endCode)
    {
        return ErrorCatalog.TryGetValue(endCode, out var info)
            ? info
            : new SlmpErrorInfo("UnknownError",
                $"不明なエラー (0x{endCode:X4})",
                ErrorSeverity.Critical);
    }
}

public record SlmpErrorInfo(string Code, string Description, ErrorSeverity Severity);

public enum ErrorSeverity
{
    None,       // 正常
    Warning,    // 警告（処理継続可能）
    Error,      // エラー（処理失敗）
    Critical    // 致命的（接続切断推奨）
}
```

**実装要件**:
- 🔲 エラーコード辞書実装
- 🔲 重大度別処理ロジック
- 🔲 統計記録機能

##### 3-3. データ残存管理（TCP対応）

**目標**: PySLMPClient方式の分割受信対応

```csharp
/// <summary>
/// TCP通信用のデータ残存管理機能
/// PySLMPClientの self.__rest 互換
/// </summary>
public class TcpFrameBufferManager
{
    private byte[] _receiveBuffer = Array.Empty<byte>();
    private readonly object _bufferLock = new object();

    /// <summary>
    /// 受信データを前回の残存データと結合し、完全なフレームを抽出
    /// </summary>
    public (byte[]? CompleteFrame, bool IsComplete) ProcessReceivedData(byte[] newData)
    {
        lock (_bufferLock)
        {
            // 前回残データと今回受信データを連結
            byte[] combined = _receiveBuffer.Concat(newData).ToArray();

            // フレーム完全性チェック
            if (!IsFrameComplete(combined, out int frameLength))
            {
                // フレーム未完成 - バッファに保存して次回待機
                _receiveBuffer = combined;
                return (null, false);
            }

            // 完全なフレームを抽出
            byte[] completeFrame = new byte[frameLength];
            Array.Copy(combined, 0, completeFrame, 0, frameLength);

            // 残りデータを保存
            int remainingLength = combined.Length - frameLength;
            if (remainingLength > 0)
            {
                _receiveBuffer = new byte[remainingLength];
                Array.Copy(combined, frameLength, _receiveBuffer, 0, remainingLength);
            }
            else
            {
                _receiveBuffer = Array.Empty<byte>();
            }

            return (completeFrame, true);
        }
    }

    /// <summary>
    /// フレームが完全かどうかを判定
    /// </summary>
    private bool IsFrameComplete(byte[] data, out int frameLength)
    {
        frameLength = 0;

        // 最小フレーム長チェック
        if (data.Length < 11) // 3Eフレームの最小長
            return false;

        try
        {
            // フレームタイプ判定
            FrameType frameType = DetectResponseFrameType(data);

            // データ長フィールドの位置と値を取得
            int dataLengthOffset = frameType switch
            {
                FrameType.Frame3E_Binary => 7,
                FrameType.Frame4E_Binary => 11,
                FrameType.Frame3E_ASCII => 10,  // 文字位置
                FrameType.Frame4E_ASCII => 22,  // 文字位置
                _ => throw new NotSupportedException()
            };

            // データ長抽出
            int dataLength;
            if (frameType == FrameType.Frame3E_ASCII || frameType == FrameType.Frame4E_ASCII)
            {
                // ASCII形式: 16進文字列
                if (data.Length < dataLengthOffset + 4)
                    return false;

                string hexLength = Encoding.ASCII.GetString(data, dataLengthOffset, 4);
                dataLength = Convert.ToInt32(hexLength, 16);

                // ASCII形式: 文字数計算
                int headerLength = frameType == FrameType.Frame3E_ASCII ? 20 : 30;
                frameLength = headerLength + dataLength;
            }
            else
            {
                // Binary形式
                if (data.Length < dataLengthOffset + 2)
                    return false;

                dataLength = data[dataLengthOffset] | (data[dataLengthOffset + 1] << 8);

                // Binary形式: バイト数計算
                int headerLength = frameType == FrameType.Frame3E_Binary ? 9 : 13;
                frameLength = headerLength + dataLength;
            }

            // 実際のデータ長がフレーム長以上か確認
            return data.Length >= frameLength;
        }
        catch
        {
            // フレーム判定エラー時は未完成とみなす
            return false;
        }
    }

    /// <summary>
    /// バッファをクリア（接続リセット時に使用）
    /// </summary>
    public void ClearBuffer()
    {
        lock (_bufferLock)
        {
            _receiveBuffer = Array.Empty<byte>();
        }
    }

    /// <summary>
    /// 現在のバッファサイズを取得（デバッグ用）
    /// </summary>
    public int BufferSize
    {
        get
        {
            lock (_bufferLock)
            {
                return _receiveBuffer.Length;
            }
        }
    }
}
```

**使用例**:

```csharp
// PlcCommunicationManagerでの使用
private TcpFrameBufferManager? _tcpBufferManager;

private async Task<byte[]> ReceiveCompleteFrameAsync(CancellationToken ct)
{
    if (_connectionConfig.Protocol == ProtocolType.Tcp)
    {
        _tcpBufferManager ??= new TcpFrameBufferManager();

        while (!ct.IsCancellationRequested)
        {
            byte[] buffer = new byte[4096];
            int bytesRead = await _networkStream.ReadAsync(buffer, 0, buffer.Length, ct);

            if (bytesRead == 0)
                throw new IOException("Connection closed by remote host");

            byte[] receivedData = new byte[bytesRead];
            Array.Copy(buffer, 0, receivedData, 0, bytesRead);

            var (completeFrame, isComplete) = _tcpBufferManager.ProcessReceivedData(receivedData);

            if (isComplete && completeFrame != null)
            {
                _logger.LogDebug(
                    $"Complete frame received: {completeFrame.Length} bytes, " +
                    $"Buffer remaining: {_tcpBufferManager.BufferSize} bytes");
                return completeFrame;
            }

            _logger.LogDebug(
                $"Incomplete frame, waiting for more data. " +
                $"Current buffer: {_tcpBufferManager.BufferSize} bytes");
        }

        throw new OperationCanceledException();
    }
    else
    {
        // UDP: 従来通り1回の受信で完結
        byte[] buffer = new byte[4096];
        int bytesRead = await _socket.ReceiveAsync(buffer, ct);
        byte[] receivedData = new byte[bytesRead];
        Array.Copy(buffer, 0, receivedData, 0, bytesRead);
        return receivedData;
    }
}
```

**実装要件**:
- 🔲 TcpFrameBufferManagerクラス実装
- 🔲 フレーム完全性判定ロジック
- 🔲 UDP/TCP自動切替機能
- 🔲 接続リセット時のバッファクリア
- 🔲 単体テストケース作成

##### 3-4. 統計記録機能

```csharp
/// <summary>
/// 通信統計情報の記録と管理
/// </summary>
public class CommunicationStatistics
{
    // フレームタイプ使用統計
    private readonly Dictionary<FrameType, int> _frameTypeUsage = new();

    // エラーコード発生統計
    private readonly Dictionary<ushort, int> _errorCodeFrequency = new();

    // デバイス点数不一致統計
    private int _deviceCountMismatchCount = 0;

    // 処理時間統計
    private readonly List<double> _processingTimes = new();

    // TCP分割受信統計
    private int _fragmentedFrameCount = 0;
    private int _totalFragments = 0;

    public void RecordFrameType(FrameType frameType)
    {
        lock (_frameTypeUsage)
        {
            if (!_frameTypeUsage.ContainsKey(frameType))
                _frameTypeUsage[frameType] = 0;
            _frameTypeUsage[frameType]++;
        }
    }

    public void RecordErrorCode(ushort errorCode)
    {
        lock (_errorCodeFrequency)
        {
            if (!_errorCodeFrequency.ContainsKey(errorCode))
                _errorCodeFrequency[errorCode] = 0;
            _errorCodeFrequency[errorCode]++;
        }
    }

    public void RecordDeviceCountMismatch()
    {
        Interlocked.Increment(ref _deviceCountMismatchCount);
    }

    public void RecordProcessingTime(double milliseconds)
    {
        lock (_processingTimes)
        {
            _processingTimes.Add(milliseconds);

            // メモリ節約: 最新1000件のみ保持
            if (_processingTimes.Count > 1000)
                _processingTimes.RemoveAt(0);
        }
    }

    public void RecordFragmentedFrame(int fragmentCount)
    {
        Interlocked.Increment(ref _fragmentedFrameCount);
        Interlocked.Add(ref _totalFragments, fragmentCount);
    }

    public string GetStatisticsReport()
    {
        var report = new StringBuilder();
        report.AppendLine("=== PLC Communication Statistics ===");

        // フレームタイプ統計
        report.AppendLine("\n[Frame Type Usage]");
        lock (_frameTypeUsage)
        {
            foreach (var (frameType, count) in _frameTypeUsage.OrderByDescending(x => x.Value))
            {
                report.AppendLine($"  {frameType}: {count} times");
            }
        }

        // エラーコード統計
        report.AppendLine("\n[Error Code Frequency]");
        lock (_errorCodeFrequency)
        {
            foreach (var (errorCode, count) in _errorCodeFrequency.OrderByDescending(x => x.Value))
            {
                var errorInfo = SlmpErrorCodes.GetErrorInfo(errorCode);
                report.AppendLine($"  0x{errorCode:X4} ({errorInfo.Description}): {count} times");
            }
        }

        // 処理時間統計
        report.AppendLine("\n[Processing Time Statistics]");
        lock (_processingTimes)
        {
            if (_processingTimes.Any())
            {
                report.AppendLine($"  Average: {_processingTimes.Average():F2} ms");
                report.AppendLine($"  Min: {_processingTimes.Min():F2} ms");
                report.AppendLine($"  Max: {_processingTimes.Max():F2} ms");
            }
        }

        // TCP分割受信統計
        if (_fragmentedFrameCount > 0)
        {
            report.AppendLine("\n[TCP Fragmentation Statistics]");
            report.AppendLine($"  Fragmented Frames: {_fragmentedFrameCount}");
            report.AppendLine($"  Total Fragments: {_totalFragments}");
            report.AppendLine($"  Avg Fragments per Frame: {(double)_totalFragments / _fragmentedFrameCount:F2}");
        }

        // その他統計
        report.AppendLine("\n[Other Statistics]");
        report.AppendLine($"  Device Count Mismatches: {_deviceCountMismatchCount}");

        return report.ToString();
    }
}
```

**実装要件**:
- 🔲 CommunicationStatisticsクラス実装
- 🔲 統計情報の永続化（CSV/JSON出力）
- 🔲 定期的な統計レポート出力

### 9.3 設定ファイル拡張

```json
// appsettings.json
{
  "PlcCommunication": {
    // フレーム形式設定
    "FrameFormat": {
      "SupportedFormats": ["3E_Binary", "4E_Binary", "3E_ASCII", "4E_ASCII"],
      "AutoDetect": true,
      "Default": "4E_Binary"
    },

    // プロトコル設定
    "Protocol": {
      "Type": "UDP",                      // UDP / TCP
      "TcpOptions": {
        "EnableFrameBuffering": true,     // TCP分割受信対応
        "MaxBufferSize": 65536,           // 最大バッファサイズ（バイト）
        "ReceiveTimeout": 5000            // 受信タイムアウト（ミリ秒）
      }
    },

    // 検証設定
    "Validation": {
      "EndCodeCheck": "Detailed",         // None / Basic / Detailed
      "DeviceCountCheck": "Warning",      // Strict / Warning / Info
      "DataLengthCheck": "Strict",
      "FrameStructureCheck": "Strict"
    },

    // データ処理設定
    "DataProcessing": {
      // ビット展開設定（ConMoni互換）
      "BitExpansion": {
        "Enabled": true,
        "SelectionMask": [],              // デバイスごとの展開フラグ
        "ConversionFactors": []           // 桁数変換係数
      }
    },

    // 統計・ログ設定
    "Statistics": {
      "Enabled": true,
      "RecordFrameTypeUsage": true,
      "RecordErrorCodeFrequency": true,
      "RecordDeviceCountMismatch": true,
      "RecordProcessingTime": true,
      "RecordTcpFragmentation": true,     // TCP分割受信統計
      "OutputInterval": 300,              // 統計出力間隔（秒）
      "OutputPath": "./logs/statistics"   // 統計ファイル出力先
    }
  }
}
```

### 9.4 実装スケジュール

| Phase | 内容 | 優先度 | 予想工数 | 状態 |
|-------|-----|--------|---------|------|
| **Phase 1-1** | フレーム自動判定機能 | 🔴 最優先 | 2-3時間 | 🔲 未着手 |
| **Phase 1-2** | ASCII形式パーサー（3E） | 🔴 最優先 | 3-4時間 | 🔲 未着手 |
| **Phase 1-3** | ASCII形式パーサー（4E） | 🔴 最優先 | 3-4時間 | 🔲 未着手 |
| **Phase 2-1** | ビット展開機能 | 🟡 高優先 | 4-5時間 | 🔲 未着手 |
| **Phase 2-2** | 変換係数対応 | 🟡 高優先 | 2-3時間 | 🔲 未着手 |
| **Phase 3-1** | デバイス点数検証 | 🟢 中優先 | 2-3時間 | 🔲 未着手 |
| **Phase 3-2** | エラーコードマッピング | 🟢 中優先 | 3-4時間 | 🔲 未着手 |
| **Phase 3-3** | **データ残存管理（TCP対応）** | 🟢 **中優先** | **4-5時間** | 🔲 未着手 |
| **Phase 3-4** | 統計記録機能 | 🟢 中優先 | 2-3時間 | 🔲 未着手 |

**総予想工数**: 25-34時間

#### Phase別の依存関係

```
Phase 1 (ASCII対応) ─┐
                    ├─→ Phase 3-3 (TCP対応) ※フレーム判定が必要
Phase 2 (ビット展開) ─┘

Phase 3-1, 3-2, 3-4 は独立して実装可能
```

#### TCP対応の重要性

**Phase 3-3（データ残存管理）は中優先ですが、TCP通信を使用する場合は必須機能です。**

- **UDP環境**: データ残存管理は不要（1回の受信で完結）
- **TCP環境**: 必須（分割受信に対応しないとフレーム解析が失敗）

**推奨実装順序**:
1. Phase 1完了後、ASCII形式のテスト
2. Phase 2完了後、ビット展開のテスト
3. **TCP使用予定がある場合**: Phase 3-3を優先実装
4. Phase 3-1, 3-2, 3-4は必要に応じて実装

### 9.5 テスト戦略

#### 単体テスト

1. **フレーム判定テスト**
   - 3E/4E Binary/ASCII全パターン
   - 不正サブヘッダのエラー処理

2. **オフセット計算テスト**
   - 各フレームタイプの正確性

3. **ビット展開テスト**
   - LSB first順序の正確性
   - ConMoniとの出力一致確認

4. **TCP分割受信テスト**
   - 単一フレームの完全受信
   - 2分割受信（ヘッダ/データ）
   - 3分割以上の受信
   - 複数フレームの連続受信
   - バッファオーバーフロー対策

#### 統合テスト

1. **実機データ再生テスト**
   - memo.mdの実機データで検証
   - 全フィールドの正確な解析

2. **エラーケーステスト**
   - 不完全フレーム
   - 異常終了コード
   - TCP接続切断時のバッファクリア

3. **TCP長時間通信テスト**
   - 連続1000フレーム受信
   - メモリリーク確認
   - バッファ管理の正確性

### 9.6 採用しない機能

以下の機能は採用を見送る：

1. ❌ **ConMoniの13バイトオフセット**
   - 理由: 標準仕様（15バイト）と不一致、実機データでも確認されず
   - 代替: 標準仕様に準拠した実装

2. ❌ **SIMD高速化**
   - 理由: 現状のパフォーマンスで十分
   - 将来対応: ボトルネック判明時に検討

---

**レポート作成者**: Claude Code
**参照ファイル**:
- andon/Core/Managers/PlcCommunicationManager.cs
- ConMoni (sample)/ConMoni/modules/process/GetPlcData.py
- PySLMPClient/pyslmpclient/__init__.py
- PySLMPClient/pyslmpclient/util.py
- andon/documents/design/フレーム構築方法.md
- andon/memo.md（実機通信データ）
