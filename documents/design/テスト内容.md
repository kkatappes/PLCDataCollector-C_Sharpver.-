# テスト内容

## テスト方針
- **TDD手法**を使用してテスト駆動開発を実施
- **単一ブロック毎**の機能をテスト→パス確認後に複合時の動作テスト
- **入力/出力の値が既知**のものを含める
- **Step3-6のブロック（PlcCommunicationManager）を優先**して実装・テスト
- メソッドレベルの粒度でテストを実施

## 実装優先順位
1. **PlcCommunicationManager** (Step3-6) - 最優先
2. **LoggingManager** (ログ機能)
3. **ErrorHandler** (エラーハンドリング)
4. **ResourceManager** (メモリ・リソース管理)
5. **ConfigToFrameManager** (Step1-2) - SplitDwordToWord分割処理含む
6. **DataOutputManager** (Step7) - 任意の場所/形式への出力対応

---

## 1. ConfigToFrameManager テスト設計

### 1.1 LoadConfigAsync メソッド
**目的**: 単一設定ファイル(appsettings.xlsx)の読み込み機能をテスト（既存機能保持）

#### 正常系テスト
- **TC001_LoadConfigAsync_正常**
  - 入力: 有効なappsettings.xlsx（UTF-8形式）
  - 期待出力: 全設定オブジェクトが正常に読み込まれる
    - ConnectionConfig（IpAddress="192.168.1.10", Port=5000等）
    - TimeoutConfig（ReceiveTimeoutMs=3000, ConnectTimeoutMs=5000等）
    - TargetDeviceConfig（MDeviceRange="M001-M999", DDeviceRange="D001-D999"等）
    - ActualConfigPath（実際に読み込んだファイルパス）
    - その他全設定項目

- **TC001_1_LoadConfigAsync_パス解決順序**
  - 入力: 複数候補パスに設定ファイル配置
  - 前提: ./config/test.xlsx, ./test.xlsx, 環境変数パス の順で配置
  - 期待出力: ./config/test.xlsx が優先的に読み込まれる
  - 検証項目: ActualConfigPath の値が正しいパスを示す

#### 異常系テスト
- **TC002_LoadConfigAsync_ファイル不存在**
  - 入力: 存在しないファイルパス
  - 期待出力: FileNotFoundException または ConfigurationError

- **TC003_LoadConfigAsync_フォーマット異常**
  - 入力: 不正なフォーマットのExcelファイル
  - 期待出力: FormatException または ConfigurationError

- **TC004_LoadConfigAsync_必須項目欠如**
  - 入力: 必須項目が欠如した設定ファイル
  - 期待出力: ArgumentNullException または ConfigurationError

### 1.2 GetConfig メソッド
**目的**: 読み込み済み設定の取得機能をテスト

#### 正常系テスト
- **TC005_GetConfig_ConnectionConfig取得**
  - 前提: LoadConfigAsyncが正常完了
  - 入力: ConnectionConfig型指定
  - 期待出力: 正しいConnectionConfigオブジェクト

- **TC006_GetConfig_各設定タイプ取得**
  - 前提: LoadConfigAsyncが正常完了
  - 入力: 各設定タイプ（TimeoutConfig, TargetDeviceConfig等）
  - 期待出力: 対応する設定オブジェクト

#### 異常系テスト
- **TC007_GetConfig_未初期化状態**
  - 前提: LoadConfigAsyncが未実行
  - 入力: 任意の設定タイプ
  - 期待出力: InvalidOperationException

### 1.3 SplitDwordToWord メソッド
**目的**: DWordからWordへの分割処理・デバイスデータ前処理機能をテスト

#### 正常系テスト
- **TC008_SplitDwordToWord_通常データ前処理**
  - 入力: TargetDeviceConfig（MDeviceRange="M001-M999", DataType=Word）
  - 期待出力: 前処理済みデバイス要求情報（最適化済み範囲）

- **TC009_SplitDwordToWord_DWord分割処理**
  - 入力: TargetDeviceConfig（DDeviceRange="D001-D999", DataType=DWord）
  - 期待出力: 前処理済みデバイス要求情報（DWordは16bit×2に分割済み）
  - 動作フロー成功条件: DWordの情報を読み取る場合は分割→フレーム作成のステップが正しく動作すること

- **TC010_SplitDwordToWord_混合データ型**
  - 入力: TargetDeviceConfig（MDeviceRange="M001-M100", DDeviceRange="D001-D100", DataType=Mixed）
  - 期待出力: データ型別に最適化された前処理済み要求情報

#### 異常系テスト
- **TC011_SplitDwordToWord_不正デバイス範囲**
  - 入力: 不正なデバイス範囲（"M1000-M999"等）
  - 期待出力: ArgumentException

### 1.4 BuildFrames メソッド
**目的**: SLMPフレーム構築機能をテスト

#### 正常系テスト
- **TC012_BuildFrames_4Eフレーム構築**
  - 入力:
    - ConnectionConfig（FrameVersion=4E, IsBinary=true）
    - ProcessedDeviceRequestInfo（前処理済みデバイス要求情報）
  - 期待出力: 正しいSLMPフレーム（16進数文字列、2つのフレーム）
  - 期待値例:
    - Mデバイス用: "54001234000000010401006400000090E8030000"
      - 構成: サブヘッダ(54001234000000) + READコマンド(0401) + サブコマンド(0100:ビット単位) + デバイスコード(6400:M機器) + 開始番号(00000090:M000) + デバイス点数(E80300:1000点)
    - Dデバイス用: "54001234000000010400A800000090E8030000"
      - 構成: サブヘッダ(54001234000000) + READコマンド(0401) + サブコマンド(0000:ワード単位) + デバイスコード(A800:D機器) + 開始番号(00000090:D000) + デバイス点数(E80300:1000点)

  - **📋 三菱電機公式リファレンスマニュアル実用例（pdf2img/sh080931q.pdf より）**:
    - **3Eフレーム構造**: サブヘッダ `50H, 00H` (バイナリ) / `"5000"` (ASCII)
    - **M100～M107ビット読み出し実例**:
      - 入力: M100から8ビット読み出し要求
      - 期待フレーム: `"5000"` + `"0401"` + `"01006400000090080000"`
      - 構成: サブヘッダ(5000) + READコマンド(0401) + サブコマンド(0100) + デバイスコード(64=M機器) + 開始デバイス番号(100=64H) + デバイス点数(8=08H)
      - 対応応答: `00H, 01H, 00H, 11H` (M100=OFF, M101=ON, M102-M106=OFF, M107=ON)

  - **🔧 実機テスト設定（4Eフレーム/ASCII、M000-M999/D000-D999）**:
    - **M000～M999ビット読み出し（1000点）**:
      - バイナリ形式（参考）: `54 00 12 34 00 00 00 00  01 04 01 00  64 00 00 00 90  E8 03 00`
      - ASCII形式（実際の送信）: `"54001234000000010401006400000090E8030000"`
      - 構成詳細:
        - サブヘッダ: `54001234000000` (4Eフレーム、バイナリ: 54H 00H 12H 34H 00H 00H 00H 00H)
        - READコマンド: `0104` (バイナリ: 01H 04H)
        - サブコマンド: `0100` (ビット単位、バイナリ: 01H 00H)
        - デバイスコード: `6400` (M機器=64H、バイナリ: 64H 00H)
        - 開始デバイス番号: `00000090` (M000=0、バイナリ: 00H 00H 00H 90H)
        - デバイス点数: `E80300` (1000点=03E8H、バイナリ: E8H 03H 00H)
      - 応答データ: 125バイト（1000ビット÷8）、ASCII形式では250文字

    - **D000～D999ワード読み出し（1000点）**:
      - バイナリ形式（参考）: `54 00 12 34 00 00 00 00  01 04 00 00  A8 00 00 00 90  E8 03 00`
      - ASCII形式（実際の送信）: `"54001234000000010400A800000090E8030000"`
      - 構成詳細:
        - サブヘッダ: `54001234000000` (4Eフレーム)
        - READコマンド: `0104`
        - サブコマンド: `0000` (ワード単位)
        - デバイスコード: `A800` (D機器=A8H)
        - 開始デバイス番号: `00000090` (D000=0)
        - デバイス点数: `E80300` (1000点=03E8H)
      - 応答データ: 2000バイト（1000ワード×2）、ASCII形式では4000文字

- **TC013_BuildFrames_4Eフレーム構築**
  - 入力:
    - ConnectionConfig（FrameVersion=4E, IsBinary=true）
    - ProcessedDeviceRequestInfo（SplitDwordToWordで分割済み要求情報）
  - 期待出力: 正しいSLMPフレーム（16進数文字列、複数フレーム対応）

  - **📋 三菱電機公式リファレンスマニュアル実用例（pdf2img/sh080931q.pdf より）**:
    - **4Eフレーム構造**: サブヘッダ `54H, 00H, 12H, 34H, 00H, 00H, 00H, 00H` (バイナリ) / `"54001234000000"` (ASCII)
    - **M100～M131ワード読み出し実例**:
      - 入力: M100から2ワード読み出し要求
      - 期待フレーム: `"54001234000000"` + `"0104"` + `"00006400000090020000"`
      - 構成: サブヘッダ(54001234000000) + READコマンド(0104) + サブコマンド(0000) + デバイスコード(64=M機器) + 開始デバイス番号(100=64H) + デバイス点数(2=02H)
      - 対応応答: `34H, 12H, 02H, 00H` (2ワード分のデータ)

  - **🔧 実機テスト設定との対応（4Eフレーム/ASCII）**:
    - 実機テスト: M000-M999/D000-D999、4Eフレーム、ASCII形式
    - TC013での検証: 上記実機テスト設定のフレーム構築とASCII変換の正確性確認

- **TC014_BuildFrames_ASCIIフレーム構築**
  - 入力:
    - ConnectionConfig（IsBinary=false）
    - ProcessedDeviceRequestInfo（前処理済み要求情報）
  - 期待出力: ASCII形式のSLMPフレーム

  - **📋 三菱電機公式リファレンスマニュアル実用例（pdf2img/sh080931q.pdf より）**:
    - **ASCIIフレーム構造**: バイナリフレームの各バイトを2文字のASCII16進数文字列に変換
    - **M100～M107ビット読み出しASCII実例**:
      - 入力: M100から8ビット読み出し要求（ASCII形式）
      - バイナリ版: `01H, 04H, 01H, 00H, 64H, 00H, 00H, 90H, 08H, 00H`
      - 期待フレーム（ASCII）: `"30313034303130303634303030303930303830303030"`
      - 構成: 各バイトが2文字のASCII16進数に変換（例: 01H → "3031", 04H → "3034"）
      - 対応応答（ASCII）: `"30303031303030313131"` (00H,01H,00H,11H をASCII変換)

#### 異常系テスト
- **TC015_BuildFrames_前処理未実行**
  - 入力:
    - ConnectionConfig（有効）
    - ProcessedDeviceRequestInfo（null または未処理）
  - 期待出力: InvalidOperationException

- **TC016_BuildFrames_不正接続設定**
  - 入力:
    - ConnectionConfig（不正なFrameVersion）
    - ProcessedDeviceRequestInfo（有効）
  - 期待出力: ArgumentException

### 1.5 MultiConfigManager テスト設計
**目的**: 複数設定ファイル対応・共有データ + 軽量インスタンス アーキテクチャをテスト

#### 正常系テスト
- **TC016_1_LoadAllFromDirectoryAsync_複数ファイル正常読み込み**
  - 入力:
    - configDirectory="./test_config/"
    - ファイル構成: PLC1_settings.xlsx, PLC2_settings.xlsx, PLC3_settings.xlsx
  - 期待出力:
    - Dictionary<string, ConfigToFrameManager> (3つの軽量インスタンス)
    - LoadResult.LoadedFiles = ["PLC1_settings.xlsx", "PLC2_settings.xlsx", "PLC3_settings.xlsx"]
    - 共有データ領域に3つの設定が保存される

- **TC016_2_LoadAllFromDirectoryAsync_パターンマッチング**
  - 入力:
    - configDirectory="./test_config/"
    - filePattern="PLC*_settings.xlsx"
    - ファイル構成: PLC1_settings.xlsx, PLC2_settings.xlsx, backup.xlsx, temp.xlsx
  - 期待出力: PLC1_settings.xlsx, PLC2_settings.xlsx のみ読み込み、他は除外

- **TC016_3_CreateManagersAsync_軽量インスタンス生成**
  - 前提: LoadAllFromDirectoryAsync実行済み
  - 入力: configFileNames=["PLC1_settings.xlsx", "PLC2_settings.xlsx"]
  - 期待出力:
    - ConfigToFrameManager[] (2つの軽量インスタンス)
    - 各インスタンスは共有データを参照
    - メモリ使用量が単体インスタンスより効率的

- **TC016_4_SharedConfigData_メモリ効率確認**
  - 前提: 3つの設定ファイル読み込み済み
  - 検証項目:
    - 設定データは1つだけ（重複無し）
    - 軽量インスタンスは設定データを参照のみ
    - 総メモリ使用量 < (単体インスタンス × 3)

#### 異常系テスト
- **TC016_5_LoadAllFromDirectoryAsync_部分失敗**
  - 入力:
    - ファイル構成: PLC1_settings.xlsx(正常), PLC2_settings.xlsx(破損), PLC3_settings.xlsx(正常)
    - allowPartialSuccess=true
  - 期待出力:
    - LoadResult.LoadedFiles = ["PLC1_settings.xlsx", "PLC3_settings.xlsx"]
    - LoadResult.FailedFiles = ["PLC2_settings.xlsx"]
    - 成功した設定ファイルのみ利用可能

- **TC016_6_LoadAllFromDirectoryAsync_ディレクトリ不存在**
  - 入力: configDirectory="./not_exist/"
  - 期待出力: DirectoryNotFoundException

- **TC016_7_GetSharedConfigData_存在しない設定**
  - 入力: configFileName="NotExist_settings.xlsx"
  - 期待出力: KeyNotFoundException

#### パフォーマンステスト
- **TC016_8_Performance_複数インスタンス作成速度**
  - 検証項目: 10個の設定ファイルから軽量インスタンス生成時間 < 1秒

- **TC016_9_Performance_メモリ使用量比較**
  - 検証項目:
    - 従来方式 vs 共有データ方式のメモリ使用量比較
    - 30%以上のメモリ削減を確認

#### ReleaseSharedDataメソッドテスト
- **TC016_10_ReleaseSharedData_特定ファイル解放**
  - 入力: configFileName="PLC1_settings.xlsx"
  - 期待出力:
    - ReleasedMemoryKB（解放されたメモリ量）
    - 指定ファイルの共有データのみ解放
    - 他の設定ファイルデータは保持

- **TC016_11_ReleaseSharedData_全体解放**
  - 入力: configFileName=null（全体指定）
  - 期待出力:
    - ReleasedMemoryKB（全解放メモリ量）
    - 全共有データの解放完了
    - メモリ使用量の大幅削減確認

- **TC016_12_ReleaseSharedData_長時間稼働最適化**
  - 前提: 8時間以上の連続稼働状態
  - 手順:
    1. 複数設定ファイル読み込み
    2. 長時間稼働シミュレーション
    3. ReleaseSharedData実行
  - 期待出力: メモリ最適化効果の確認

---

## 2. PlcCommunicationManager テスト設計（最優先実装）

### 2.1 ConnectAsync メソッド
**目的**: PLC接続機能をテスト

#### 正常系テスト
- **TC017_ConnectAsync_TCP接続成功**
  - 入力:
    - ConnectionConfig（IpAddress="192.168.1.10", Port=5000, UseTcp=true）
    - TimeoutConfig（ConnectTimeoutMs=5000, SendTimeoutMs=3000, ReceiveTimeoutMs=3000）
  - 期待出力: ConnectionResponse（接続成功オブジェクト）
    - Status=ConnectionStatus.Connected（接続成功）
    - Socket（System.Net.Sockets.Socket型）: 接続済みSocketインスタンス
    - RemoteEndPoint（System.Net.EndPoint型）: "192.168.1.10:5000"が正確に記録
    - ConnectedAt（DateTime型）: 接続完了時刻が記録済み
    - ConnectionTime（TimeSpan型）: 接続処理にかかった時間
      - 検証: ConnectionTime.TotalMilliseconds > 0 && < ConnectTimeoutMs
    - ErrorMessage=null（成功時はnull）

- **TC017_1_ConnectAsync_ソケットタイムアウト設定確認**
  - 前提: TC017のTCP接続成功後
  - 検証項目:
    - Socket.SendTimeout == TimeoutConfig.SendTimeoutMs（送信タイムアウト設定）
    - Socket.ReceiveTimeout == TimeoutConfig.ReceiveTimeoutMs（受信タイムアウト設定）
  - 重要性: Step4（送受信処理）で個別にタイムアウト制御を実装する必要がなくなる
  - 設計方針: ソケットレベルでのタイムアウト設定により、保守性が向上する

- **TC018_ConnectAsync_UDP接続成功**
  - 入力:
    - ConnectionConfig（IpAddress="192.168.1.10", Port=5000, UseTcp=false）
    - TimeoutConfig（ConnectTimeoutMs=5000, SendTimeoutMs=3000, ReceiveTimeoutMs=3000）
  - 期待出力: ConnectionResponse（UDP接続成功オブジェクト）
    - Status=ConnectionStatus.Connected
    - Socket: UDP用Socketインスタンス
    - RemoteEndPoint設定済み
    - ConnectedAt設定済み
    - ConnectionTime記録済み
    - UDP疎通確認方法（TDD・オフライン環境対応）:
      - テスト実施方法: PLCシミュレータまたはネットワークモックを使用
      - 模擬送信フレーム（M000-M999読み込み）: "54001234000000010401006400000090E8030000"
        - 構成: サブヘッダ(54001234000000) + READコマンド(0401) + サブコマンド(0100:ビット単位) + デバイスコード(6400:M機器) + 開始番号(00000090:M000) + デバイス点数(E80300:1000点)
      - 模擬送信フレーム（D000-D999読み込み）: "54001234000000010400A800000090E8030000"
        - 構成: サブヘッダ(54001234000000) + READコマンド(0401) + サブコマンド(0000:ワード単位) + デバイスコード(A800:D機器) + 開始番号(00000090:D000) + デバイス点数(E80300:1000点)
      - 模擬応答データ: モックがConnectTimeoutMs内に正常応答を返却
      - 検証項目: Socket.Connected状態、RemoteEndPoint設定、応答受信完了の確認
      - 重要: 実際のPLC機器不要、完全オフライン環境でのテスト実施

#### 異常系テスト
- **TC019_ConnectAsync_接続タイムアウト**
  - 入力:
    - ConnectionConfig（IpAddress="192.168.100.200", Port=5000）: 到達不可能なIPアドレス
    - TimeoutConfig（ConnectTimeoutMs=1000）
  - 期待動作:
    - TimeoutException がスローされる
    - 例外メッセージ: "接続タイムアウト: 192.168.100.200:5000（タイムアウト時間: 1000ms）"
    - ConnectionResponse は返却されない（例外発生のため）
  - テスト実装例:
    Assert.ThrowsAsync<TimeoutException>(async () =>
        await manager.ConnectAsync(config, timeout));

- **TC020_ConnectAsync_接続拒否**
  - 入力:
    - ConnectionConfig（IpAddress="192.168.1.10", Port=9999）: 接続拒否するポート
    - TimeoutConfig（ConnectTimeoutMs=5000）
  - 期待動作:
    - SocketException（または ConnectionException）がスローされる
    - 例外メッセージ: "接続拒否: 192.168.1.10:9999"
    - ConnectionResponse は返却されない（例外発生のため）
  - テスト実装例:
    Assert.ThrowsAsync<SocketException>(async () =>
        await manager.ConnectAsync(config, timeout));

- **TC020_1_ConnectAsync_不正IPアドレス**
  - 入力:
    - ConnectionConfig（IpAddress="999.999.999.999", Port=5000）: 不正なIPアドレス形式
    - TimeoutConfig（ConnectTimeoutMs=5000）
  - 期待出力: ArgumentException または FormatException
    - ErrorMessage: "不正なIPアドレス形式: 999.999.999.999"

- **TC020_2_ConnectAsync_不正ポート番号**
  - 入力:
    - ConnectionConfig（IpAddress="192.168.1.10", Port=70000）: 範囲外のポート番号（有効範囲: 1-65535）
    - TimeoutConfig（ConnectTimeoutMs=5000）
  - 期待出力: ArgumentOutOfRangeException
    - ErrorMessage: "ポート番号が範囲外です: 70000（有効範囲: 1-65535）"

- **TC020_3_ConnectAsync_null入力**
  - 入力: ConnectionConfig=null または TimeoutConfig=null
  - 期待出力: ArgumentNullException
    - ErrorMessage: "ConnectionConfigまたはTimeoutConfigがnullです"

- **TC020_4_ConnectAsync_既に接続済み状態での再接続**
  - 前提: ConnectAsync成功済み（Status=Connected、Socket接続中）
  - 入力: 同じConnectionConfigで再度ConnectAsync実行
  - 期待出力: InvalidOperationException
    - ErrorMessage: "既に接続済みです。再接続する場合は先にDisconnectAsync()を実行してください"
  - 設計判断: 既存接続を自動切断せず、明示的な切断を要求する安全設計

- **TC020_5_ConnectAsync_接続時間計測精度**
  - 前提: 意図的に遅延を発生させる環境（モック・スタブで遅延制御）
  - 入力:
    - ConnectionConfig（IpAddress="192.168.1.10", Port=5000）
    - 意図的遅延: 500ms
  - 検証項目:
    - ConnectionTime >= 実際の接続時間（誤差±100ms以内）
    - ConnectedAt（DateTime）と処理開始時刻の差 == ConnectionTime（誤差±100ms以内）
    - 時間計測の精度確認
  - 重要性: パフォーマンス分析、タイムアウト判定の正確性に直結

### 2.2 SendFrameAsync メソッド
**目的**: PLCへのリクエスト送信機能をテスト

#### 正常系テスト
- **TC021_SendFrameAsync_正常送信**
  - 前提: ConnectAsyncが成功済み
  - 入力: 有効なSLMPフレーム
    - M000-M999読み込みフレーム: "54001234000000010401006400000090E8030000"
      - 構成: サブヘッダ(54001234000000) + READコマンド(0401) + サブコマンド(0100:ビット単位) + デバイスコード(6400:M機器) + 開始番号(00000090:M000) + デバイス点数(E80300:1000点)
    - D000-D999読み込みフレーム: "54001234000000010400A800000090E8030000"
      - 構成: サブヘッダ(54001234000000) + READコマンド(0401) + サブコマンド(0000:ワード単位) + デバイスコード(A800:D機器) + 開始番号(00000090:D000) + デバイス点数(E80300:1000点)
  - 期待出力: 送信完了ステータス

- **TC022_SendFrameAsync_全機器データ取得**
  - 前提: ConnectAsyncが成功済み
  - 入力:
    - M機器用SLMPフレーム（M001-M999範囲）
    - D機器用SLMPフレーム（D001-D999範囲）
  - 期待出力: 一度の通信で全機器データ取得完了ステータス
  - 動作フロー成功条件: 一度の通信で全ての機器からデータを取得(既定値 M001-M999,D001-D999)

#### 異常系テスト
- **TC023_SendFrameAsync_未接続状態**
  - 前提: ConnectAsyncが未実行
  - 入力: 任意のSLMPフレーム
  - 期待出力: InvalidOperationException

- **TC024_SendFrameAsync_不正フレーム**
  - 前提: ConnectAsyncが成功済み
  - 入力: 不正な16進数文字列
  - 期待出力: FormatException

### 2.3 ReceiveResponseAsync メソッド
**目的**: PLCからのデータ受信機能をテスト

#### 正常系テスト
- **TC025_ReceiveResponseAsync_正常受信**
  - 前提: SendFrameAsyncが成功済み
  - 入力: TimeoutConfig（ReceiveTimeoutMs=3000）
  - 期待出力: PLCからの生データ（16進数）

#### 異常系テスト
- **TC026_ReceiveResponseAsync_受信タイムアウト**
  - 前提: SendFrameAsyncが成功済み
  - 入力: TimeoutConfig（ReceiveTimeoutMs=100）
  - 期待出力: TimeoutException

### 2.4 DisconnectAsync メソッド
**目的**: PLC切断機能をテスト

#### 正常系テスト
- **TC027_DisconnectAsync_正常切断**
  - 前提: ConnectAsyncが成功済み
  - 入力: 接続統計情報
  - 期待出力:
    - 切断完了ステータス
    - 接続統計情報（ConnectionTime等）
    - リソース解放完了

#### 異常系テスト
- **TC028_DisconnectAsync_未接続状態切断**
  - 前提: ConnectAsyncが未実行
  - 入力: なし
  - 期待出力: 何も処理せず正常終了

### 2.5 ProcessReceivedRawData メソッド（Step6-1）
**目的**: 受信データ基本後処理機能をテスト

#### 正常系テスト
- **TC029_ProcessReceivedRawData_基本後処理成功**
  - 入力:
    - Step4で受信した生データ(16進数)
    - ProcessedDeviceRequestInfo（送信時の前処理情報）
  - 期待出力: BasicProcessedResponseData（基本後処理結果オブジェクト）
    - 基本結果: 元生データ、基本処理済みデータ（デバイス名キー構造）、処理時刻
    - エラー情報: エラーフラグ、エラー・警告メッセージリスト
    - 統計情報: 処理デバイス数
  - 処理内容:
    - 生データの16進数パース
    - デバイス別データ抽出
    - 基本的な型変換（ビット/ワード）
    - エラー検証・記録

- **TC030_ProcessReceivedRawData_混合データ型基本処理**
  - 入力:
    - 混合データ型の受信生データ（ビット・ワード混在）
    - ProcessedDeviceRequestInfo（混合型要求情報）
  - 期待出力: 基本処理済みデータ（型別最適化済み、DWord結合前状態）

#### 異常系テスト
- **TC031_ProcessReceivedRawData_不正生データ**
  - 入力: 不正なフォーマットの受信データ
  - 期待出力: DataProcessingException

### 2.6 CombineDwordData メソッド（Step6-2）
**目的**: DWord結合処理機能をテスト

#### 正常系テスト
- **TC032_CombineDwordData_DWord結合処理成功**
  - 入力:
    - BasicProcessedResponseData（基本後処理結果）
    - ProcessedDeviceRequestInfo（DWord分割情報）
  - 期待出力: ProcessedResponseData（最終処理結果オブジェクト）
    - 基本結果: 元生データ、処理済みデータ（DWord結合済み）、DWord結合フラグ、処理時刻
    - エラー情報: エラーフラグ、エラー・警告メッセージリスト
    - 統計情報: 処理デバイス数、DWord結合数（自動計算）
  - 処理内容:
    - DWord分割要否判定
    - Low/Highワードの結合処理（16bit×2→32bit）
    - 結合結果の検証
    - DWord結合統計の計算
  - 動作フロー成功条件: DWordの情報を読み取る場合はLow/High結合→構造化データ変換のステップが正しく動作すること

- **TC033_CombineDwordData_結合不要データ処理**
  - 入力:
    - BasicProcessedResponseData（Word型・Bit型のみのデータ）
    - ProcessedDeviceRequestInfo（DWord分割なし情報）
  - 期待出力: ProcessedResponseData（DWord結合フラグ=false、結合処理スキップ）

- **TC034_CombineDwordData_混合データ型結合処理**
  - 入力:
    - BasicProcessedResponseData（ビット・ワード・DWord対象混在）
    - ProcessedDeviceRequestInfo（部分的DWord分割情報）
  - 期待出力: 必要なデバイスのみDWord結合済み最終データ

#### 異常系テスト
- **TC035_CombineDwordData_基本後処理未実行**
  - 入力: null または未処理のBasicProcessedResponseData
  - 期待出力: InvalidOperationException

- **TC036_CombineDwordData_DWord結合エラー**
  - 入力: 不正なLow/Highワードペアを含むBasicProcessedResponseData
  - 期待出力: DataProcessingException

### 2.7 ParseRawToStructuredData メソッド（Step6-3）
**目的**: 構造化データ変換機能をテスト

#### 正常系テスト
- **TC037_ParseRawToStructuredData_3Eフレーム解析**
  - 入力: ProcessedResponseData（DWord結合済み処理データ、3Eフレーム）
  - 期待出力: StructuredData（SLMP構造化解析結果オブジェクト）
    - 基本構造化データ: SLMPヘッダー（全標準情報）、終了コード、デバイスデータ、受信時刻、エラーフラグ
    - 解析詳細情報: 解析手順記録、解釈情報、処理時間、デバイス解釈、ステータス判定
    - エラー詳細情報: 詳細エラーコード、エラー説明、影響デバイス（エラー時のみ）

- **TC038_ParseRawToStructuredData_4Eフレーム解析**
  - 入力: ProcessedResponseData（DWord結合済み処理データ、4Eフレーム）
  - 期待出力: 4Eフレーム形式の構造化データ

- **TC039_ParseRawToStructuredData_DWord結合済みデータ解析**
  - 入力: ProcessedResponseData（DWord結合済み、IsDwordCombined=true）
  - 期待出力: DWord結合されたデバイス情報を含む構造化データ

#### 異常系テスト
- **TC040_ParseRawToStructuredData_DWord結合未実行**
  - 入力: 未処理のProcessedResponseData（CombineDwordData未実行）
  - 期待出力: InvalidOperationException

- **TC041_ParseRawToStructuredData_エラー終了コード**
  - 入力: エラー終了コードを含むProcessedResponseData
  - 期待出力: エラー情報を含む構造化データ

---

## 3. LoggingManager テスト設計

### 3.1 InitializeAsync メソッド
**目的**: ログシステム初期化機能をテスト

#### 正常系テスト
- **TC042_InitializeAsync_正常初期化**
  - 入力: LoggingConfig（ConsoleOutput=true, DetailedLog設定）
  - 期待出力:
    - ログファイル作成
    - ディレクトリ作成
    - 初期化完了ステータス

#### 異常系テスト
- **TC043_InitializeAsync_ディスク容量不足**
  - 入力: 有効なLoggingConfig
  - 前提: ディスク容量不足状態
  - 期待出力: IOException

### 3.2 各ログ出力メソッド（LogConfigAsync, LogCommunicationAsync等）
**目的**: 各種ログ出力機能をテスト

#### 正常系テスト
- **TC044_LogConfigAsync_設定ログ出力**
  - 入力: 全設定オブジェクト
  - 期待出力: 設定情報がファイル・コンソールに出力

- **TC045_LogCommunicationAsync_通信ログ出力**
  - 入力: SLMPフレーム、フレーム解析結果
  - 期待出力: 通信情報がファイル・コンソールに出力

### 3.3 SetCorrelationId メソッド
**目的**: セッション関連付けID設定機能をテスト

#### 正常系テスト
- **TC046_SetCorrelationId_正常設定**
  - 入力: SessionId（処理セッション識別子）
  - 期待出力: 関連付け設定完了状態

### 3.4 SetLogLevel メソッド
**目的**: ログレベル設定機能をテスト

#### 正常系テスト
- **TC047_SetLogLevel_正常設定**
  - 入力: LogLevel（出力レベル指定）
  - 期待出力: レベル設定完了状態

### 3.5 IsLogLevelEnabled メソッド
**目的**: ログレベル有効性確認機能をテスト

#### 正常系テスト
- **TC048_IsLogLevelEnabled_有効性確認**
  - 入力: LogLevel（確認対象レベル）
  - 期待出力: 有効性判定結果（true/false）

### 3.6 LogStateAsync メソッド
**目的**: アプリケーション状態出力機能をテスト

#### 正常系テスト
- **TC049_LogStateAsync_状態ログ出力**
  - 入力: セッション情報、サイクル情報、処理状況
  - 期待出力: 状態ログがファイル・コンソールに出力

### 3.7 LogMetricAsync メソッド
**目的**: 統計/パフォーマンス情報出力機能をテスト

#### 正常系テスト
- **TC050_LogMetricAsync_統計ログ出力**
  - 入力: 実行統計、応答時間分析、システム稼働状況
  - 期待出力: 統計ログがファイル・コンソールに出力

### 3.8 LogErrorAsync メソッド
**目的**: エラー/例外情報詳細出力機能をテスト

#### 正常系テスト
- **TC051_LogErrorAsync_エラーログ出力**
  - 入力: エラー分類、エラー詳細、回復処理結果
  - 期待出力: エラーログがファイル・コンソールに出力

### 3.9 LogDeviceDataAsync メソッド
**目的**: デバイス解釈情報出力機能をテスト

#### 正常系テスト
- **TC052_LogDeviceDataAsync_デバイスデータログ出力**
  - 入力: 生データ、解釈結果、ステータス判定
  - 期待出力: デバイスデータログがファイル・コンソールに出力

### 3.10 BeginTransaction メソッド
**目的**: トランザクション開始機能をテスト

#### 正常系テスト
- **TC053_BeginTransaction_正常開始**
  - 入力: TransactionId（トランザクション識別子）
  - 期待出力: トランザクション開始状態

### 3.11 EndTransaction メソッド
**目的**: トランザクション終了機能をテスト

#### 正常系テスト
- **TC054_EndTransaction_正常終了**
  - 入力: TransactionId、TransactionResult（成功/失敗結果）
  - 期待出力: トランザクション終了状態

### 3.12 FlushAsync メソッド
**目的**: バッファフラッシュ機能をテスト

#### 正常系テスト
- **TC055_FlushAsync_正常フラッシュ**
  - 入力: FlushTarget（ファイル指定）
  - 期待出力: フラッシュ完了状態

---

## 4. ErrorHandler テスト設計（バランス型例外設計対応）

### 4.0 バランス型例外設計テスト方針
**目的**: 混在型例外設計（カスタム例外 + 標準例外）、統一エラーメッセージ管理、権限チェック方式の動作検証

#### 基本テスト戦略
- **例外分類テスト**: MultiConfigLoadException（カスタム） vs 標準.NET例外の使い分け検証
- **メッセージ統一テスト**: ErrorMessages.cs定数クラスによるメッセージ管理検証
- **権限チェックテスト**: 単純ファイル作成テストによる確実性検証

### 4.1 DetermineErrorCategory メソッド
**目的**: エラー分類判定機能をテスト

#### 正常系テスト
- **TC056_DetermineErrorCategory_通信エラー**
  - 入力: SocketException, StepNumber=3
  - 期待出力:
    - ErrorCategory=CommunicationError
    - Severity=Error

- **TC057_DetermineErrorCategory_設定エラー**
  - 入力: ConfigurationException, StepNumber=1
  - 期待出力:
    - ErrorCategory=ConfigurationError
    - Severity=Fatal

### 4.2 ApplyRetryPolicy メソッド
**目的**: リトライ方針適用機能をテスト

#### 正常系テスト
- **TC058_ApplyRetryPolicy_リトライ実行**
  - 入力:
    - ErrorCategory=CommunicationError
    - StepNumber=4
    - CurrentRetryCount=1
  - 期待出力:
    - ShouldRetry=true
    - MaxRetryCount=3

- **TC059_ApplyRetryPolicy_リトライ上限**
  - 入力:
    - ErrorCategory=CommunicationError
    - CurrentRetryCount=3
  - 期待出力: ShouldRetry=false

### 4.3 RecordError メソッド
**目的**: エラー記録機能をテスト

#### 正常系テスト
- **TC060_RecordError_正常記録**
  - 入力:
    - ErrorCategory（エラー分類）
    - Severity（重要度）
    - ErrorMessage（エラーメッセージ）
    - Exception（例外オブジェクト）
    - StepNumber（ステップ番号）
  - 期待出力: 記録完了状態

### 4.4 ApplyErrorPolicy メソッド
**目的**: エラー処理方針適用機能をテスト

#### 正常系テスト
- **TC038_2_ApplyErrorPolicy_継続判定**
  - 入力:
    - ErrorCategory（エラー分類）
    - StepNumber（ステップ番号）
  - 期待出力: ErrorAction（継続/終了の判定結果）

### 4.5 ErrorMessages テスト設計（統一エラーメッセージ管理）
**目的**: 定数クラスによる統一エラーメッセージ管理機能をテスト

#### 正常系テスト
- **TC038_3_ErrorMessages_設定ファイル関連**
  - 入力: CONFIG_FILE_NOT_FOUND, ファイルパス \"test.xlsx\"
  - 期待出力: \"設定ファイルが見つかりません: test.xlsx\"
  - 検証項目: パラメータ埋め込み、日本語メッセージ品質

- **TC038_4_ErrorMessages_複数設定ファイル関連**
  - 入力: MULTI_CONFIG_LOAD_FAILED, 成功数=2, 失敗数=1
  - 期待出力: \"複数設定ファイル読み込みに失敗しました。成功: 2件、失敗: 1件\"
  - 検証項目: 複数パラメータ埋め込み、部分成功状況表現

- **TC038_5_ErrorMessages_通信関連**
  - 入力: CONNECTION_FAILED, IPアドレス \"192.168.1.10\", ポート 5000
  - 期待出力: \"PLC接続に失敗しました: 192.168.1.10:5000\"
  - 検証項目: ネットワーク情報表現、技術者向け詳細情報

- **TC038_6_ErrorMessages_権限・ファイルシステム関連**
  - 入力: WRITE_PERMISSION_CHECK_FAILED, パス \"./logs/\"
  - 期待出力: \"書き込み権限チェックに失敗しました: ./logs/\"
  - 検証項目: 権限エラー表現、パス情報表示

- **TC038_7_ErrorMessages_メモリ・リソース関連**
  - 入力: MEMORY_LIMIT_EXCEEDED, 現在使用量=120000, 制限値=100000
  - 期待出力: \"メモリ使用量が制限を超過しました: 120000KB/100000KB\"
  - 検証項目: リソース使用量表現、数値フォーマット

#### ErrorMessages網羅的テスト追加
- **TC038_7_1_ErrorMessages_メモリ警告閾値**
  - 入力: MEMORY_THRESHOLD_WARNING, 現在使用量=85000, 警告閾値=80000
  - 期待出力: \"メモリ使用量が警告閾値を超過しました: 85000KB/80000KB\"
  - 検証項目: 警告レベルメッセージ、閾値表現

- **TC038_7_2_ErrorMessages_リソース最適化要求**
  - 入力: RESOURCE_OPTIMIZATION_REQUIRED, 理由=\"メモリ使用量増加\"
  - 期待出力: \"リソース最適化が必要です: メモリ使用量増加\"
  - 検証項目: 最適化要求メッセージ、理由説明

- **TC038_7_3_ErrorMessages_汎用システムメッセージ**
  - 入力: UNEXPECTED_ERROR, エラー詳細=\"NullReferenceException in ConfigManager\"
  - 期待出力: \"予期しないエラーが発生しました: NullReferenceException in ConfigManager\"
  - 検証項目: 汎用エラーメッセージ、技術詳細情報

- **TC038_7_4_ErrorMessages_操作キャンセルメッセージ**
  - 入力: OPERATION_CANCELLED, 操作名=\"PLC接続処理\"
  - 期待出力: \"操作がキャンセルされました: PLC接続処理\"
  - 検証項目: キャンセル状況表現、操作識別

- **TC038_7_5_ErrorMessages_初期化失敗メッセージ**
  - 入力: INITIALIZATION_FAILED, コンポーネント=\"LoggingManager\"
  - 期待出力: \"初期化に失敗しました: LoggingManager\"
  - 検証項目: 初期化エラー表現、コンポーネント識別

- **TC038_7_6_ErrorMessages_ディレクトリ作成失敗**
  - 入力: DIRECTORY_CREATE_FAILED, パス=\"./logs/rawdata/\"
  - 期待出力: \"ディレクトリ作成に失敗しました: ./logs/rawdata/\"
  - 検証項目: ファイルシステム操作エラー、パス情報

- **TC038_7_7_ErrorMessages_ログファイル書き込み失敗**
  - 入力: LOG_FILE_WRITE_FAILED, ファイルパス=\"./logs/terminal_output.txt\"
  - 期待出力: \"ログファイル書き込みに失敗しました: ./logs/terminal_output.txt\"
  - 検証項目: ログシステムエラー、ファイルパス表現

- **TC038_7_8_ErrorMessages_複数設定ファイル対応無しエラー**
  - 入力: MULTI_CONFIG_NO_FILES_FOUND, パターン=\"*_settings.xlsx\"
  - 期待出力: \"指定パターンに一致する設定ファイルが見つかりません: *_settings.xlsx\"
  - 検証項目: 複数設定ファイル機能エラー、パターンマッチング

- **TC038_7_9_ErrorMessages_設定項目不足エラー**
  - 入力: CONFIG_MISSING_REQUIRED_FIELD, 項目名=\"IpAddress\"
  - 期待出力: \"必須設定項目が不足しています: IpAddress\"
  - 検証項目: 設定検証エラー、必須項目識別

- **TC038_7_10_ErrorMessages_設定ディレクトリ不存在**
  - 入力: CONFIG_DIRECTORY_NOT_FOUND, ディレクトリ=\"./config/\"
  - 期待出力: \"設定ディレクトリが見つかりません: ./config/\"
  - 検証項目: 設定ファイル検索エラー、ディレクトリ表現

#### 設計品質テスト
- **TC038_8_ErrorMessages_メッセージ一意性**
  - 検証項目: 全メッセージが一意であること、重複無し
  - 期待結果: 各メッセージIDが唯一の文字列を持つ

- **TC038_9_ErrorMessages_パラメータ整合性**
  - 検証項目: パラメータプレースホルダー（{0}, {1}等）と実使用の整合性
  - 期待結果: 全メッセージで必要パラメータ数が正確

### 4.6 MultiConfigLoadException テスト設計（複数設定ファイル専用例外）
**目的**: 複数設定ファイル読み込み時の詳細エラー情報保持機能をテスト

#### 正常系テスト
- **TC038_10_MultiConfigLoadException_完全失敗**
  - 入力:
    - directory=\"./config/\"
    - pattern=\"*_settings.xlsx\"
    - failures={ \"PLC1.xlsx\": FileNotFoundException, \"PLC2.xlsx\": FormatException }
  - 期待出力:
    - LoadedFiles=[]（空リスト）
    - FailedFiles=2件
    - IsPartialSuccess=false
    - TotalAttempted=2

- **TC038_11_MultiConfigLoadException_部分成功**
  - 入力:
    - directory=\"./config/\"
    - pattern=\"*_settings.xlsx\"
    - loaded=[\"PLC1_settings.xlsx\", \"PLC3_settings.xlsx\"]
    - failures={ \"PLC2_settings.xlsx\": IOException }
  - 期待出力:
    - LoadedFiles=2件
    - FailedFiles=1件
    - IsPartialSuccess=true
    - SuccessCount=2, FailureCount=1

- **TC038_12_MultiConfigLoadException_詳細レポート生成**
  - 前提: 部分成功状態のMultiConfigLoadException
  - 入力: GetDetailedErrorReport()実行
  - 期待出力:
    - 成功ファイル一覧表示
    - 失敗ファイルと例外タイプ表示
    - 読み込み試行ディレクトリ・パターン表示
    - 統計情報表示（成功/失敗件数）

- **TC038_13_MultiConfigLoadException_特定失敗確認**
  - 前提: 複数種類の例外を含むMultiConfigLoadException
  - 入力: HasSpecificFailure(typeof(FileNotFoundException))
  - 期待出力: true（FileNotFoundExceptionが含まれる場合）

#### 継承・互換性テスト
- **TC038_14_MultiConfigLoadException_標準例外互換**
  - 検証項目: Exception基底クラスとの完全互換性
  - 期待結果:
    - Message プロパティ正常動作
    - InnerException プロパティ正常動作
    - StackTrace 情報保持
    - ToString() メソッド適切な出力

- **TC038_15_MultiConfigLoadException_シリアライゼーション**
  - 検証項目: .NET標準シリアライゼーション対応
  - 期待結果: 例外情報の完全な復元が可能

### 4.7 バランス型例外処理統合テスト
**目的**: カスタム例外と標準例外の使い分け、統一メッセージ管理の統合動作をテスト

#### 統合テスト
- **TC038_16_バランス型例外_使い分け判定**
  - シナリオ1（カスタム例外使用）:
    - 状況: 複数設定ファイル読み込みで部分失敗
    - 期待例外: MultiConfigLoadException
    - 期待メッセージ: ErrorMessages.MULTI_CONFIG_PARTIAL_SUCCESS使用

  - シナリオ2（標準例外使用）:
    - 状況: 単一設定ファイル読み込みでファイル不存在
    - 期待例外: FileNotFoundException
    - 期待メッセージ: ErrorMessages.CONFIG_FILE_NOT_FOUND使用

- **TC038_17_バランス型例外_権限チェック統合**
  - 手順:
    1. 単純ファイル作成テストで権限チェック実行
    2. 権限不足の場合、UnauthorizedAccessException発生
    3. ErrorMessages.WRITE_PERMISSION_CHECK_FAILED使用確認
  - 期待結果: 確実な権限判定と統一メッセージ使用

- **TC038_18_バランス型例外_メッセージ一貫性**
  - 検証項目: カスタム例外・標準例外共にErrorMessagesクラス使用
  - 期待結果:
    - MultiConfigLoadException: ErrorMessages使用
    - 標準例外: ErrorMessages使用（適切なwrap）
    - メッセージ品質・形式の統一性確保

---

## 5. ResourceManager テスト設計

### 5.1 GetMemoryUsage メソッド
**目的**: メモリ使用量取得機能をテスト

#### 正常系テスト
- **TC088_GetMemoryUsage_正常取得**
  - 入力: 現在のシステム状態
  - 期待出力:
    - 現在のメモリ使用量（KB単位）
    - 各コンポーネント別使用量

### 5.2 EvaluateLevel メソッド
**目的**: メモリレベル判定機能をテスト

#### 正常系テスト
- **TC089_EvaluateLevel_正常レベル**
  - 入力:
    - 現在使用量=1000KB
    - 閾値設定（MemoryLimitKB=10000, MemoryThresholdKB=8000）
  - 期待出力:
    - メモリレベル=Normal
    - 推奨アクション=None

- **TC090_EvaluateLevel_警告レベル**
  - 入力:
    - 現在使用量=8500KB
    - 閾値設定（MemoryLimitKB=10000, MemoryThresholdKB=8000）
  - 期待出力:
    - メモリレベル=Warning
    - 推奨アクション=OptimizeMemory

### 5.3 ApplyDataAndLoggingPolicy メソッド
**目的**: データ/ログポリシー適用機能をテスト

#### 正常系テスト
- **TC091_ApplyDataAndLoggingPolicy_ポリシー適用**
  - 入力:
    - メモリレベル（ResourceManager.EvaluateLevel()）
    - ポリシー設定（ConfigToFrameManager.LoadConfigAsync()）
  - 期待出力:
    - 適用されたポリシー内容
    - データ処理制限設定

### 5.4 OptimizeMemory メソッド
**目的**: メモリ最適化実行機能をテスト

#### 正常系テスト
- **TC092_OptimizeMemory_最適化実行**
  - 入力:
    - 最適化対象（各クラスインスタンス）
    - 最適化レベル（ResourceManager.EvaluateLevel()）
  - 期待出力:
    - 最適化実行結果
    - 削減されたメモリ量

### 5.5 WriteLogAsync メソッド
**目的**: メモリ状況ログ出力機能をテスト

#### 正常系テスト
- **TC093_WriteLogAsync_メモリログ出力**
  - 入力:
    - メモリ使用状況（ResourceManager.GetMemoryUsage()）
    - メモリレベル（ResourceManager.EvaluateLevel()）
    - 最適化結果（ResourceManager.OptimizeMemory()）
  - 期待出力: ログ出力完了状態

### 5.6 RunMonitoringLoopAsync メソッド
**目的**: メモリ監視ループ実行機能をテスト

#### 正常系テスト
- **TC094_RunMonitoringLoopAsync_監視ループ実行**
  - 入力:
    - 監視間隔設定（ConfigToFrameManager.LoadConfigAsync()）
    - 継続監視フラグ
  - 期待出力: 監視ループ実行状態

---

## 6. DataOutputManager テスト設計（Step7）

### 6.1 OutputDataAsync メソッド（想定）
**目的**: 解析後データの出力機能をテスト

#### 正常系テスト
- **TC095_OutputDataAsync_ファイル出力**
  - 入力:
    - 構造化データ（ParseRawToStructuredDataの出力）
    - 出力設定（FilePath, Format）
  - 期待出力: データが指定場所/形式で出力/保存される
  - 動作フロー成功条件: 解析したデータを任意の場所/形式に出力/保存できる

- **TC096_OutputDataAsync_複数形式出力**
  - 入力:
    - 構造化データ
    - 複数出力設定（CSV, JSON, XML等）
  - 期待出力: データが複数形式で出力される

- **TC097_OutputDataAsync_リアルタイム出力**
  - 入力:
    - 継続的な構造化データストリーム
    - リアルタイム出力設定
  - 期待出力: データがリアルタイムで出力される

#### 異常系テスト
- **TC098_OutputDataAsync_出力先アクセス不可**
  - 入力:
    - 構造化データ
    - アクセス不可な出力先設定
  - 期待出力: IOException

- **TC099_OutputDataAsync_ディスク容量不足**
  - 入力:
    - 大量の構造化データ
    - ディスク容量不足状態
  - 期待出力: InsufficientMemoryException

---

## 7. インターフェース設計テスタビリティテスト

### 7.1 インターフェース分離テスト
**目的**: 全主要クラスのインターフェース分離によるテスタビリティ確保をテスト

#### インターフェース設計テスト
- **TC100_IConfigToFrameManager_インターフェース分離**
  - 目的: ConfigToFrameManagerクラスのインターフェース分離確認
  - 入力: IConfigToFrameManager契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能

- **TC101_IPlcCommunicationManager_インターフェース分離**
  - 目的: PlcCommunicationManagerクラスのインターフェース分離確認（最重要）
  - 入力: IPlcCommunicationManager契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能

- **TC102_IDataOutputManager_インターフェース分離**
  - 目的: DataOutputManagerクラスのインターフェース分離確認
  - 入力: IDataOutputManager契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能

- **TC103_ILoggingManager_インターフェース分離**
  - 目的: LoggingManagerクラスのインターフェース分離確認
  - 入力: ILoggingManager契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能

- **TC104_IErrorHandler_インターフェース分離**
  - 目的: ErrorHandlerクラスのインターフェース分離確認
  - 入力: IErrorHandler契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能

- **TC105_IResourceManager_インターフェース分離**
  - 目的: ResourceManagerクラスのインターフェース分離確認
  - 入力: IResourceManager契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能

#### 新規追加インターフェース分離テスト
- **TC106_IApplicationController_インターフェース分離**
  - 目的: ApplicationControllerクラスのインターフェース分離確認
  - 入力: IApplicationController契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能
  - 検証項目:
    - StartAsync, StopAsync, ExecuteStep1InitializationAsync, StartContinuousDataCycleAsyncの全メソッド対応
    - InitializationResult, CycleExecutionResult等の戻り値型互換性
    - CancellationToken対応の非同期処理制御

- **TC107_IExecutionOrchestrator_インターフェース分離**
  - 目的: ExecutionOrchestratorクラスのインターフェース分離確認
  - 入力: IExecutionOrchestrator契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能
  - 検証項目:
    - RunContinuousDataCycleAsync, ExecuteSingleCycleAsync, GetMonitoringIntervalの全メソッド対応
    - PLC別インスタンス管理との親和性
    - TimerService連携の抽象化

- **TC108_IAsyncExceptionHandler_インターフェース分離**
  - 目的: AsyncExceptionHandlerクラスのインターフェース分離確認
  - 入力: IAsyncExceptionHandler契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能
  - 検証項目:
    - HandleCriticalOperationAsync<T>, HandleGeneralOperationsAsyncの全メソッド対応
    - AsyncOperationResult<T>, GeneralOperationResult戻り値型互換性
    - 階層的例外ハンドリング抽象化

- **TC109_ICancellationCoordinator_インターフェース分離**
  - 目的: CancellationCoordinatorクラスのインターフェース分離確認
  - 入力: ICancellationCoordinator契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能
  - 検証項目:
    - CreateHierarchicalToken, RegisterCancellationCallbackの全メソッド対応
    - CancellationTokenSource, CancellationTokenRegistration管理の抽象化
    - 階層的キャンセル制御の抽象化

- **TC110_IResourceSemaphoreManager_インターフェース分離**
  - 目的: ResourceSemaphoreManagerクラスのインターフェース分離確認
  - 入力: IResourceSemaphoreManager契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能
  - 検証項目:
    - ExecuteWithSemaphoreAsync<T>, GetResourceSemaphoreの全メソッド対応
    - SemaphoreSlim管理の抽象化
    - ResourceType列挙型対応

- **TC111_IProgressReporter_インターフェース分離**
  - 目的: ProgressReporter<T>クラスのインターフェース分離確認
  - 入力: IProgressReporter<T>契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能
  - 検証項目:
    - Report, CreateStepProgressの全メソッド対応
    - ProgressInfo, ParallelProgressInfo型対応
    - IProgress<T>標準インターフェース準拠

- **TC112_IParallelExecutionController_インターフェース分離**
  - 目的: ParallelExecutionControllerクラスのインターフェース分離確認
  - 入力: IParallelExecutionController契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能
  - 検証項目:
    - ExecuteParallelPlcOperationsAsync, MonitorParallelExecutionの全メソッド対応
    - ParallelExecutionResult戻り値型互換性
    - Task.WhenAll活用の抽象化

- **TC113_ITimerService_インターフェース分離**
  - 目的: TimerServiceクラスのインターフェース分離確認
  - 入力: ITimerService契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能
  - 検証項目:
    - StartPeriodicExecutionの全メソッド対応
    - System.Threading.PeriodicTimer抽象化
    - MonitoringIntervalMs間隔制御の抽象化

- **TC114_IGracefulShutdownHandler_インターフェース分離**
  - 目的: GracefulShutdownHandlerクラスのインターフェース分離確認
  - 入力: IGracefulShutdownHandler契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能
  - 検証項目:
    - RegisterShutdownHandlers, ExecuteGracefulShutdownの全メソッド対応
    - ShutdownResult戻り値型互換性
    - シグナル処理（Ctrl+C等）の抽象化

- **TC115_IMultiConfigDIIntegration_インターフェース分離**
  - 目的: MultiConfigDIIntegrationクラスのインターフェース分離確認
  - 入力: IMultiConfigDIIntegration契約による抽象化
  - 期待出力: モック・スタブによる完全な機能置換が可能
  - 検証項目:
    - RegisterMultiConfigServices, CreateConfigSpecificProviderの全メソッド対応
    - IServiceCollection, IServiceProvider管理の抽象化
    - 複数設定ファイル対応DIコンテナ統合の抽象化

### 7.2 TDD手法サポートテスト
**目的**: インターフェース分離によるTDD手法サポートをテスト

#### Red-Green-Refactorサイクルテスト
- **TC116_TDD_RedGreenRefactor_サイクル**
  - 目的: インターフェースベースのTDDサイクル実行確認
  - 手順:
    1. Red: 失敗するテストケース作成（インターフェースモック使用）
    2. Green: 最小限の実装で成功させる
    3. Refactor: インターフェース契約を保ちながらリファクタリング
  - 期待出力: 完全なTDDサイクルの実行が可能

---

## 8. Modelsクラス単体テスト設計

### 8.1 Core/Models/ConfigModels テスト
**目的**: 設定関連モデルクラスの個別単体テストを実施

#### 列挙型テスト
- **TC117_ConnectionType_列挙型**
  - 入力: ConnectionType値（Ethernet, Serial, USB）
  - 期待出力: 型安全な表現と適切なデフォルト値

- **TC118_FrameVersion_列挙型**
  - 入力: FrameVersion値（Frame3E, Frame4E）
  - 期待出力: 型安全な表現と適切なデフォルト値

#### ConfigModelsクラステスト
- **TC119_ConnectionConfig_コンストラクタ**
  - 入力: IPAddress, Port, UseTcp, ConnectionType, IsBinary, FrameVersion
  - 期待出力: 全プロパティnull不許容での正常インスタンス化

- **TC120_TimeoutConfig_コンストラクタ**
  - 入力: ReceiveTimeoutMs, ConnectTimeoutMs, RetryTimeoutMs
  - 期待出力: 実用的デフォルト値（3-5秒）での正常インスタンス化

- **TC121_TargetDeviceConfig_コンストラクタ**
  - 入力: MDeviceRange, DDeviceRange, DataType
  - 期待出力: 標準範囲デフォルト値での正常インスタンス化

- **TC122_SystemResourcesConfig_コンストラクタ**
  - 入力: MemoryLimitKB, MaxBufferSize, MemoryThresholdKB, LowMemoryMode
  - 期待出力: 実用的制限値（100MB制限）での正常インスタンス化

- **TC123_DataProcessingConfig_コンストラクタ**
  - 入力: TargetName, ContinuousDataMode, DataRetentionDays
  - 期待出力: 継続モード優先設定での正常インスタンス化

- **TC124_LoggingConfig_コンストラクタ**
  - 入力: ConsoleOutput, DetailedLog
  - 期待出力: 開発・運用両対応設定での正常インスタンス化

- **TC125_DataTransferConfig_コンストラクタ**
  - 入力: EnableTransfer, DestinationIpAddress, DestinationPort
  - 期待出力: セキュリティ優先（デフォルト無効）での正常インスタンス化

- **TC126_ProcessedDeviceRequestInfo_操作メソッド**
  - 入力: SplitRanges, DataTypeInfo, OptimizedRanges
  - 期待出力: AddSplitRange, GetSplitRanges等の操作メソッドが正常動作

#### ProcessedDeviceRequestInfo詳細メソッドテスト
- **TC126_1_AddSplitRange_分割範囲追加**
  - 入力:
    - デバイス範囲: "D100-D199"
    - 分割リスト: ["D100-D149", "D150-D199"]
  - 期待出力: SplitRanges辞書に正常追加、DWord分割情報保持

- **TC126_2_AddDataTypeInfo_データ型情報追加**
  - 入力:
    - デバイス範囲: "M001-M999"
    - データ型: "Bit"
  - 期待出力: DataTypeInfo辞書に正常追加、型情報保持

- **TC126_3_AddOptimizedRange_最適化範囲追加**
  - 入力:
    - デバイス種別: "D"
    - 最適化範囲: "D001-D999"
  - 期待出力: OptimizedRanges辞書に正常追加、統合範囲情報保持

- **TC126_4_GetSplitRanges_分割情報取得**
  - 前提: AddSplitRange実行済み
  - 入力: デバイス範囲指定 "D100-D199"
  - 期待出力: 対応する分割リスト ["D100-D149", "D150-D199"]

- **TC126_5_GetDataType_データ型取得**
  - 前提: AddDataTypeInfo実行済み
  - 入力: デバイス範囲指定 "M001-M999"
  - 期待出力: 対応するデータ型 "Bit"

- **TC126_6_GetAllDeviceTypes_全データ型一覧取得**
  - 前提: 複数のAddDataTypeInfo実行済み
  - 入力: なし
  - 期待出力: 全データ型の一覧 ["Bit", "Word", "DWord"]

- **TC126_7_ProcessedDeviceRequestInfo_境界値テスト**
  - 入力: 存在しないデバイス範囲指定
  - 期待出力: null または適切な例外

### 8.2 Core/Models（PlcCommunicationManager用データ転送オブジェクト）テスト
**目的**: PLC通信用データ転送オブジェクトの個別単体テストを実施

#### 列挙型・基本クラステスト
- **TC127_ConnectionStatus_列挙型**
  - 入力: ConnectionStatus値（Connected, Failed, Timeout）
  - 期待出力: 型安全な表現

- **TC128_ConnectionResponse_コンストラクタ**
  - 入力: Status, Socket, RemoteEndPoint, ConnectedAt, ConnectionTime, ErrorMessage
  - 期待出力: 接続成功/失敗で異なるプロパティのnull許容性管理

- **TC129_ConnectionStats_統計メソッド**
  - 入力: ResponseTimes, TotalErrors, TotalRetries
  - 期待出力: AddResponseTime, IncremetError, IncrementRetry等の統計メソッドが正常動作

#### ConnectionStats詳細統計メソッドテスト
- **TC129_1_AddResponseTime_応答時間追加**
  - 入力:
    - 応答時間: TimeSpan.FromMilliseconds(150)
    - 応答時間: TimeSpan.FromMilliseconds(200)
    - 応答時間: TimeSpan.FromMilliseconds(120)
  - 期待出力:
    - ResponseTimes履歴に追加
    - AverageResponseTime自動計算（約157ms）
    - MaxResponseTime更新（200ms）
    - MinResponseTime更新（120ms）

- **TC129_2_AddResponseTime_統計自動再計算**
  - 前提: 複数の応答時間データ追加済み
  - 入力: 新たな応答時間 TimeSpan.FromMilliseconds(300)
  - 期待出力:
    - 平均応答時間の自動再計算
    - 最大応答時間の更新確認
    - 統計精度の検証

- **TC129_3_IncremetError_エラー発生統計**
  - 入力: IncremetError()メソッド複数回実行
  - 期待出力:
    - TotalErrors カウント増加
    - SuccessRate 自動再計算（成功率低下）
    - エラー統計の正確性確認

- **TC129_4_IncrementRetry_リトライ実行統計**
  - 入力: IncrementRetry()メソッド複数回実行
  - 期待出力:
    - TotalRetries カウント増加
    - リトライ統計の正確性確認
    - 通信品質指標への反映

- **TC129_5_SuccessRate_通信成功率計算**
  - 前提:
    - 総送信回数: 100回
    - エラー発生: 5回
    - リトライ成功: 3回
  - 期待出力:
    - SuccessRate = 0.98 (98%成功率)
    - 自動計算精度の検証

- **TC129_6_ConnectionStats_統計リセット**
  - 入力: 新しいConnectionStatsインスタンス作成
  - 期待出力:
    - 全統計値が初期状態（0）
    - 履歴リストが空の状態
    - 成功率が未定義状態（データなし）

- **TC130_ProcessedResponseData_データ操作メソッド**
  - 入力: OriginalRawData, ProcessedData, OriginalRequest
  - 期待出力: AddProcessedDevice, GetDeviceValue等のデータ操作メソッドが正常動作

#### ProcessedResponseData詳細データ操作メソッドテスト
- **TC130_1_AddProcessedDevice_デバイスデータ追加**
  - 入力:
    - デバイス名: "M100"
    - 値: true
    - データ型: "Bit"
    - DWord結合フラグ: false
  - 期待出力:
    - ProcessedData辞書に正常追加
    - ProcessedDeviceCount自動増加
    - デバイス情報の正確な保持

- **TC130_2_AddProcessedDevice_DWord結合デバイス追加**
  - 入力:
    - デバイス名: "D100"
    - 値: 0x12345678
    - データ型: "DWord"
    - DWord結合フラグ: true
  - 期待出力:
    - ProcessedData辞書に正常追加
    - DWordCombinedCount自動増加
    - IsDwordCombinedフラグがtrue

- **TC130_3_AddError_エラーメッセージ追加**
  - 入力: エラーメッセージ "デバイスM100の読み取りに失敗しました"
  - 期待出力:
    - Errorsリストに追加
    - HasErrorsフラグがtrue
    - エラー情報の正確な保持

- **TC130_4_AddWarning_警告メッセージ追加**
  - 入力: 警告メッセージ "デバイスD200のデータ形式を自動修正しました"
  - 期待出力:
    - Warningsリストに追加
    - 警告情報の正確な保持

- **TC130_5_GetDeviceValue_デバイス値取得**
  - 前提: AddProcessedDevice実行済み
  - 入力: デバイス名 "M100"
  - 期待出力: 対応する値 true

- **TC130_6_GetDeviceType_デバイス型取得**
  - 前提: AddProcessedDevice実行済み
  - 入力: デバイス名 "D100"
  - 期待出力: 対応するデータ型 "DWord"

- **TC130_7_GetCombinedDWordDevices_DWord結合デバイス一覧取得**
  - 前提: DWord結合デバイス複数追加済み
  - 入力: なし
  - 期待出力: DWord結合されたデバイス名一覧 ["D100", "D200"]

- **TC130_8_ProcessedResponseData_統計情報自動計算**
  - 前提:
    - 通常デバイス5個追加
    - DWord結合デバイス2個追加
    - エラー1個、警告1個追加
  - 期待出力:
    - ProcessedDeviceCount = 7
    - DWordCombinedCount = 2
    - HasErrors = true
    - 統計精度の検証

- **TC131_SlmpHeader_ヘッダー情報**
  - 入力: SubHeader, NetworkNumber, StationNumber等のSLMP標準情報
  - 期待出力: 全プロパティnull不許容でのSLMP標準情報完全保持

#### SlmpHeader詳細テスト
- **TC131_1_SlmpHeader_3Eフレームヘッダー**
  - 入力:
    - SubHeader: "5000"
    - NetworkNumber: "01"
    - StationNumber: "00"
    - ModuleIONumber: "03FF"
    - MultidropNumber: "00"
    - RequestDataLength: "001B"
    - FrameType: "3E"
    - IsBinary: true
  - 期待出力: 3Eフレーム用SLMP標準ヘッダー情報の完全保持

- **TC131_2_SlmpHeader_4Eフレームヘッダー**
  - 入力:
    - SubHeader: "5400"
    - NetworkNumber: "01"
    - StationNumber: "FF"
    - ModuleIONumber: "03FF"
    - MultidropNumber: "00"
    - RequestDataLength: "001B"
    - FrameType: "4E"
    - IsBinary: true
  - 期待出力: 4Eフレーム用SLMP標準ヘッダー情報の完全保持

- **TC131_3_SlmpHeader_ASCIIフレームヘッダー**
  - 入力:
    - SubHeader: "35303030"
    - NetworkNumber: "3031"
    - StationNumber: "3030"
    - ModuleIONumber: "30334646"
    - MultidropNumber: "3030"
    - RequestDataLength: "30304142"
    - FrameType: "3E"
    - IsBinary: false
  - 期待出力: ASCII形式SLMP標準ヘッダー情報の完全保持

- **TC131_4_SlmpHeader_解析情報**
  - 入力: ParsedAt時刻設定
  - 期待出力:
    - ParsedAt設定済み（解析実行時刻）
    - FrameType判定済み（3E or 4E）
    - IsBinary判定済み（バイナリ/ASCII）

- **TC131_5_SlmpHeader_プロパティnull安全性**
  - 入力: 各プロパティのnull設定試行
  - 期待出力:
    - 全プロパティでnull不許容
    - 適切な例外発生（ArgumentNullException等）

- **TC131_6_SlmpHeader_SLMP仕様準拠性**
  - 入力: 三菱電機公式仕様書準拠のヘッダー値
  - 期待出力:
    - 公式サンプルとの完全一致
    - SLMP通信プロトコル標準への完全準拠
    - ネットワーク情報の正確な保持

- **TC132_StructuredData_構造化メソッド**
  - 入力: Header, EndCode, DeviceData, ReceivedAt等
  - 期待出力: AddStructuredDevice, GetDeviceValue等の構造化メソッドが正常動作

#### StructuredData詳細構造化メソッドテスト
- **TC132_1_AddStructuredDevice_構造化デバイスデータ追加**
  - 入力:
    - デバイス名: "M100"
    - 値: true
    - データ型: "Bit"
    - 解釈フラグ: true
  - 期待出力:
    - DeviceData辞書に正常追加
    - TotalDevices自動増加
    - デバイス構造化情報の正確な保持

- **TC132_2_AddParseStep_解析手順追加**
  - 入力: 解析手順 "SLMPヘッダー解析完了"
  - 期待出力:
    - ParseStepsリストに追加
    - 解析履歴の正確な記録
    - デバッグ情報の保持

- **TC132_3_AddDeviceInterpretation_デバイス解釈情報追加**
  - 入力:
    - デバイス名: "M100"
    - 解釈情報: { "Status": "ON", "Description": "動作中" }
  - 期待出力:
    - DeviceInterpretations辞書に追加
    - 人間が読める形式での情報保持

- **TC132_4_AddStatusJudgment_ステータス判定追加**
  - 入力:
    - デバイス名: "M100"
    - ステータス判定: "正常"
  - 期待出力:
    - StatusJudgments辞書に追加
    - ON/OFF、正常/異常判定の保持

- **TC132_5_SetErrorDetails_エラー詳細設定**
  - 入力:
    - 詳細エラーコード: "E001"
    - エラー説明: "デバイス読み取りエラー"
    - 影響デバイス: ["M100", "M101"]
    - エラー詳細情報: { "原因": "通信タイムアウト" }
  - 期待出力:
    - IsErrorフラグがtrue
    - ErrorMessage設定
    - 詳細エラー情報の完全保持

- **TC132_6_GetDeviceValue_構造化デバイス値取得**
  - 前提: AddStructuredDevice実行済み
  - 入力: デバイス名 "M100"
  - 期待出力: 対応する値 true

- **TC132_7_GetDeviceInterpretation_デバイス解釈情報取得**
  - 前提: AddDeviceInterpretation実行済み
  - 入力: デバイス名 "M100"
  - 期待出力: 対応する解釈情報 { "Status": "ON", "Description": "動作中" }

- **TC132_8_GetStatusJudgment_ステータス判定取得**
  - 前提: AddStatusJudgment実行済み
  - 入力: デバイス名 "M100"
  - 期待出力: 対応するステータス判定 "正常"

- **TC132_9_GetAllDeviceNames_全デバイス名取得**
  - 前提: 複数デバイス追加済み
  - 入力: なし
  - 期待出力: 全デバイス名一覧 ["M100", "M101", "D100", "D101"]

- **TC132_10_GetErrorDevices_エラー発生デバイス取得**
  - 前提: エラー詳細設定済み
  - 入力: なし
  - 期待出力: エラー発生デバイス一覧 ["M100", "M101"]

- **TC132_11_StructuredData_包括的SLMP情報保持**
  - 前提: 完全なSLMP応答解析済み
  - 検証項目:
    - SLMPヘッダー情報の完全保持
    - 終了コード解析結果
    - 全デバイスデータの構造化
    - 解析手順の詳細記録
    - エラー情報の包括的管理
  - 期待出力: デバッグ・運用監視の完全支援情報

### 8.3 Core/Models（非同期・並行処理用データ転送オブジェクト）テスト
**目的**: 非同期処理結果の構造化、並行実行状態管理、進捗情報保持、例外処理結果管理をテスト

#### 列挙型テスト
- **TC133_ResourceType_列挙型**
  - 入力: ResourceType値（LogFile, ConfigFile, OutputFile）
  - 期待出力: 型安全な表現
  - 検証項目:
    - LogFile: ログファイルリソース
    - ConfigFile: 設定ファイルリソース
    - OutputFile: データ出力ファイルリソース

#### 非同期処理結果クラステスト
- **TC134_AsyncOperationResult_コンストラクタ**
  - 入力:
    - 成功時: Result, ExecutionTime, OperationName, StartTime
    - 失敗時: Exception, ExecutionTime, OperationName, StartTime
  - 期待出力: 成功/失敗の論理的整合性での正常インスタンス化
    - 成功時: IsSuccess=true, Result設定, Exception=null
    - 失敗時: IsSuccess=false, Result=null, Exception設定

- **TC135_GeneralOperationResult_一括処理結果**
  - 入力: OperationGroupName, ExecutedAt
  - 期待出力: 一括処理統計管理での正常インスタンス化
  - 検証項目:
    - AddSuccess(string operationName): 成功処理追加
    - AddFailure(string operationName, Exception exception): 失敗処理・例外追加
    - GetSuccessRate(): 成功率計算（0.0-1.0）

#### GeneralOperationResult詳細メソッドテスト
- **TC135_1_AddSuccess_成功処理追加**
  - 入力: operationName "ログファイル出力"
  - 期待出力:
    - SuccessCount増加
    - 成功率向上
    - 処理名記録

- **TC135_2_AddFailure_失敗処理追加**
  - 入力:
    - operationName "設定ファイル読み込み"
    - exception IOException
  - 期待出力:
    - FailureCount増加
    - FailedOperations一覧に追加
    - Exceptions一覧に追加

- **TC135_3_GetSuccessRate_成功率計算**
  - 前提:
    - 成功処理: 8件
    - 失敗処理: 2件
  - 期待出力: GetSuccessRate() = 0.8（80%成功率）

#### 並行実行結果クラステスト
- **TC136_ParallelExecutionResult_並行実行結果**
  - 入力: TotalCount, StartTime
  - 期待出力: 並行実行効果測定での正常インスタンス化
  - 検証項目:
    - AddPlcResult(string plcId, CycleExecutionResult result): PLC結果追加
    - UpdateContinuingPlcs(List<string> continuingIds): 継続PLC更新
    - CalculateEfficiency(): 並行実行効率計算
    - GetFailedPlcIds(): 失敗PLC ID一覧取得

#### ParallelExecutionResult詳細メソッドテスト
- **TC136_1_AddPlcResult_PLC結果追加**
  - 入力:
    - plcId "PLC001"
    - result CycleExecutionResult（成功状態）
  - 期待出力:
    - PlcResults辞書に追加
    - SuccessfulPlcCount増加
    - 並行実行統計更新

- **TC136_2_AddPlcResult_失敗PLC結果追加**
  - 入力:
    - plcId "PLC002"
    - result CycleExecutionResult（失敗状態）
  - 期待出力:
    - PlcResults辞書に追加
    - FailedPlcCount増加
    - 失敗統計更新

- **TC136_3_UpdateContinuingPlcs_継続PLC更新**
  - 入力: continuingIds ["PLC001", "PLC003", "PLC005"]
  - 期待出力:
    - ContinuingPlcIds更新
    - 動的状況管理

- **TC136_4_CalculateEfficiency_並行実行効率計算**
  - 前提:
    - 理論最大時間: 600秒（3PLC × 200秒）
    - 実際実行時間: 250秒
  - 期待出力:
    - ParallelEfficiency = 2.4（240%効率、理想値3.0に対して80%）
    - 並行実行効果の定量評価

- **TC136_5_GetFailedPlcIds_失敗PLC一覧取得**
  - 前提: 複数PLC結果追加済み（成功・失敗混在）
  - 期待出力: 失敗したPLC ID一覧 ["PLC002", "PLC004"]

#### 進捗情報クラステスト
- **TC137_ProgressInfo_進捗情報基底クラス**
  - 入力: CurrentStep, Progress, Message, ElapsedTime
  - 期待出力: 統一された進捗表現での正常インスタンス化
  - 検証項目:
    - CurrentStep: 現在実行ステップ（例："Step3", "PLC接続中"）
    - Progress: 進捗率（0.0-1.0）
    - Message: 進捗メッセージ（人間向け表示用）
    - EstimatedTimeRemaining: 推定残り時間（null許容）
    - ElapsedTime: 経過時間
    - ReportedAt: 報告時刻

- **TC138_ParallelProgressInfo_並行実行進捗情報**
  - 継承関係: ProgressInfo（基底クラス）を継承
  - 入力: Step, PlcProgresses, ElapsedTime
  - 期待出力: 複数PLC並行実行の進捗情報保持
  - 検証項目:
    - ActivePlcCount: 実行中PLC数
    - CompletedPlcCount: 完了PLC数
    - FailedPlcCount: 失敗PLC数
    - PlcProgresses: PLC別進捗率（PlcId→進捗率）
    - OverallProgress: 全体進捗率（全PLC平均進捗）

#### ParallelProgressInfo詳細メソッドテスト
- **TC138_1_UpdatePlcProgress_PLC進捗更新**
  - 入力:
    - plcId "PLC001"
    - progress 0.75（75%進捗）
  - 期待出力:
    - PlcProgresses辞書更新
    - OverallProgress再計算

- **TC138_2_CalculateOverallProgress_全体進捗率計算**
  - 前提:
    - PLC001: 80%進捗
    - PLC002: 60%進捗
    - PLC003: 90%進捗
  - 期待出力:
    - OverallProgress = 0.767（76.7%全体進捗）
    - 全PLC平均進捗の正確な計算

### 8.4 Core/Models（ApplicationController用データ転送オブジェクト）テスト
**目的**: アプリケーション制御メソッドの入出力データ構造化、実行結果保持、ライフサイクル状態管理をテスト

#### 初期化結果クラステスト
- **TC139_InitializationResult_初期化結果**
  - 入力:
    - 成功時: LoadedCount, ManagersCount, Time, Paths
    - 失敗時: ErrorDetails, Failures
  - 期待出力: Step1初期化フェーズの実行結果保持
  - 検証項目:
    - LoadedConfigCount: 読み込み成功した設定ファイル数
    - CreatedManagersCount: 作成されたManagerインスタンス数
    - InitializationTime: 初期化処理にかかった時間
    - IsSuccess: 初期化成功フラグ
    - ErrorDetails: 初期化エラー詳細（失敗時のみ設定、成功時はnull）
    - LoadedConfigPaths: 読み込み成功した設定ファイルパス一覧
    - FailedConfigs: 失敗した設定ファイルとエラー内容

#### 初期化結果詳細テスト
- **TC139_1_InitializationResult_成功状態**
  - 入力:
    - loadedCount: 5
    - managersCount: 15
    - time: TimeSpan.FromSeconds(2.5)
    - paths: ["PLC1_settings.xlsx", "PLC2_settings.xlsx", ...]
  - 期待出力:
    - IsSuccess=true
    - ErrorDetails=null
    - 全統計情報の正確な設定

- **TC139_2_InitializationResult_失敗状態**
  - 入力:
    - errorDetails: "設定ファイル読み込みに失敗しました"
    - failures: {"PLC3_settings.xlsx": "ファイル形式エラー"}
  - 期待出力:
    - IsSuccess=false
    - 失敗情報の詳細保持
    - デバッグ・トラブルシューティング支援情報

#### サイクル実行結果クラステスト
- **TC140_CycleExecutionResult_サイクル実行結果**
  - 入力:
    - 成功時: Steps, Time, DataCount, PlcId, StepResults
    - 失敗時: PlcId, ErrorDetails, CompletedSteps
  - 期待出力: Step2-7単一サイクル実行結果保持
  - 検証項目:
    - IsSuccess: サイクル実行成功フラグ
    - ExecutedSteps: 実行完了したステップ一覧
    - ExecutionTime: サイクル全体の実行時間
    - DataCount: 処理されたデバイスデータ数
    - PlcIdentifier: 対象PLCの識別子
    - ErrorDetails: エラー詳細（失敗時のみ設定、成功時はnull）
    - StepResults: 各ステップの実行結果詳細
    - WarningMessages: 警告メッセージ一覧

#### CycleExecutionResult詳細メソッドテスト
- **TC140_1_AddStepResult_ステップ結果追加**
  - 入力:
    - stepName "Step3"
    - result { "ConnectionTime": "00:00:01.2", "Status": "Success" }
  - 期待出力:
    - StepResults辞書に追加
    - ステップ別詳細情報保持

- **TC140_2_AddWarning_警告メッセージ追加**
  - 入力: message "デバイスD200のデータ形式を自動修正しました"
  - 期待出力:
    - WarningMessages一覧に追加
    - 成功だが注意が必要な事項の記録

- **TC140_3_GetStepResult_ステップ結果取得**
  - 前提: AddStepResult実行済み
  - 入力: stepName "Step3"
  - 期待出力: 対応するステップ結果オブジェクト

#### 終了処理結果クラステスト
- **TC141_ShutdownResult_終了処理結果**
  - 入力:
    - 正常終了用: Time, Completed, State, Trigger
    - タイムアウト終了用: Time, Completed, Incomplete, Details, Trigger
  - 期待出力: アプリケーション終了処理結果保持
  - 検証項目:
    - IsGraceful: 適切な終了処理完了フラグ
    - ShutdownTime: 終了処理にかかった時間
    - CompletedTasks: 完了した終了タスク一覧
    - IncompleteTaskCount: 未完了タスク数（タイムアウト時）
    - IncompleteTaskDetails: 未完了タスク詳細一覧
    - FinalResourceState: 最終リソース状態
    - ShutdownTrigger: 終了契機

#### ShutdownResult詳細テスト
- **TC141_1_ShutdownResult_正常終了**
  - 入力:
    - time: TimeSpan.FromSeconds(5.2)
    - completed: ["ApplicationController.StopAsync", "PlcConnections.Disconnect", "LogFiles.Flush", "Resources.Release"]
    - state: { "PlcConnections": "Disconnected", "LogFiles": "Flushed", "Memory": "Released" }
    - trigger: "Ctrl+C"
  - 期待出力:
    - IsGraceful=true
    - IncompleteTaskCount=0
    - 終了処理の透明性確保

- **TC141_2_ShutdownResult_タイムアウト終了**
  - 入力:
    - time: TimeSpan.FromSeconds(30.0)
    - completed: ["ApplicationController.StopAsync", "LogFiles.Flush"]
    - incomplete: 2
    - details: ["PlcConnections.Disconnect: Timeout", "Resources.Release: Blocked"]
    - trigger: "ProcessExit"
  - 期待出力:
    - IsGraceful=false
    - IncompleteTaskCount=2
    - タイムアウト対応状況把握

---

## 9. 複合テスト設計

### 7.1 Step1-2統合テスト
**目的**: 設定読み込みからフレーム構築までの統合機能をテスト

- **TC142_統合_設定読み込み_フレーム構築**
  - 手順:
    1. LoadConfigAsync実行
    2. GetConfig実行（ConnectionConfig, TargetDeviceConfig取得）
    3. SplitDwordToWord実行（DWord分割処理含む）
    4. BuildFrames実行
  - 期待結果: 正しいSLMPフレームが生成される（DWord分割対応）

### 7.2 Step3-6 PLC通信核心部 専用複合テスト
**目的**: PLC通信の最重要部分であるStep3-6の複合動作を徹底検証

#### **TC143_1 Step3-6基本連続実行テスト**
- **手順**:
  1. Step3: ConnectAsync実行（TCP/UDP別）
  2. Step4: SendFrameAsync → ReceiveResponseAsync実行
  3. Step5: DisconnectAsync実行
  4. Step6: PostprocessReceivedData → ParseRawToStructuredData実行
- **期待結果**: 全ステップが順次成功し、各ステップの戻り値が正常
- **検証項目**:
  - 接続状態の適切な遷移（未接続→接続中→接続済み→切断済み）
  - 各ステップの実行時間が仕様内
  - メモリ使用量の適切な推移

#### **TC143_2 Step3-6データ継承精度テスト**
- **手順**:
  1. Step3で取得した接続情報（Socket, EndPoint）がStep4-5で正確に使用されること
  2. Step4で受信したデータがStep6で正確に処理されること
  3. Step6で生成した構造化データが完全であること
- **期待結果**: データの完全性が保持され、情報の欠損・変更がない
- **検証項目**:
  - Socket接続情報の一貫性
  - 受信データの16進数形式→バイナリ→構造化データの変換精度
  - SLMPヘッダー情報の完全保持

#### **TC143_3 Step3-6段階的エラーハンドリングテスト**
- **シナリオ1 Step3失敗**: 接続失敗時のStep4-6適切なスキップ
- **シナリオ2 Step4失敗**: 通信失敗時のStep5切断処理実行とエラー伝播
- **シナリオ3 Step5失敗**: 切断失敗時の適切なリソース解放
- **シナリオ4 Step6失敗**: データ処理失敗時のエラー情報保持
- **期待結果**: 各段階でのエラー発生に対する適切な対応とリソース管理
- **検証項目**:
  - エラー発生ステップ以降の適切な処理スキップ
  - リソースリーク無し
  - エラー詳細情報の正確な記録

#### **TC143_4 Step3-6 DWord処理統合テスト**
- **前提**: DWord型デバイス（D001-D999）を対象とした通信
- **手順**:
  1. ConfigToFrameManager.SplitDwordToWord()でDWord→16bit×2分割済み
  2. Step3-4: 分割後フレームでの通信実行
  3. Step6: PostprocessReceivedData()でのDWord結合処理
  4. 最終的な32bitデータの正確性確認
- **期待結果**: DWord分割→通信→結合の一連処理が正確
- **検証項目**:
  - 16bit×2→32bit結合の数値精度
  - エンディアン処理の正確性
  - 複数DWordデバイスの一括処理精度

#### **TC143_5 Step3-6タイムアウト制御統合テスト**
- **シナリオ**:
  - Step3: ConnectTimeoutMsでの接続タイムアウト
  - Step4: ReceiveTimeoutMsでの受信タイムアウト
  - Step5: DisconnectTimeoutMsでの切断タイムアウト
- **期待結果**: 各ステップで設定されたタイムアウト時間の正確な制御
- **検証項目**:
  - タイムアウト時間の精度（±100ms以内）
  - タイムアウト時の適切な例外発生
  - タイムアウト後のリソース状態

#### **TC143_6 Step3-6リソース管理統合テスト**
- **検証項目**:
  - **メモリ管理**: 各ステップでのメモリ使用量推移
  - **Socket管理**: 接続・切断での適切なSocket状態管理
  - **バッファ管理**: 送受信バッファの適切な確保・解放
- **手順**: 100回連続でStep3-6実行後のリソース状態確認
- **期待結果**:
  - メモリリーク無し
  - Socket接続残存無し
  - システムリソースの適切な解放

#### **TC143_7 Step3-6パフォーマンス測定統合テスト**
- **測定項目**:
  - **全体実行時間**: Step3-6完了までの時間
  - **各ステップ実行時間**: Step別の処理時間分析
  - **スループット**: 1分間に処理可能なサイクル数
- **期待結果**:
  - 全体実行時間: 平均3秒以内
  - Step3接続時間: 1秒以内
  - Step4通信時間: 1秒以内
  - 連続実行時のパフォーマンス劣化無し

#### **TC143_8 Step3-6エラー回復・リトライ統合テスト**
- **シナリオ**:
  1. Step3接続失敗→リトライ→成功
  2. Step4通信失敗→リトライ→成功
  3. 最大リトライ回数到達時の適切な処理終了
- **期待結果**: ErrorHandlerと連携したリトライ制御の正確な動作
- **検証項目**:
  - リトライ間隔の制御
  - リトライ回数の正確なカウント
  - 最終失敗時の適切なエラー情報

#### **TC143_9 Step3-6並行実行統合テスト（複数PLC対応）**
- **前提**: 複数PLC設定ファイル（PLC1, PLC2, PLC3）
- **手順**: 各PLCに対してStep3-6を並行実行
- **期待結果**: 各PLCの独立した処理実行とリソース競合回避
- **検証項目**:
  - PLC別の独立したSocket管理
  - 並行実行時のメモリ効率
  - エラー発生時の他PLC処理への影響無し

#### **テスト実行条件**
- **実行順序**: 必ず単一ブロックテスト（TC017-TC030）完了後に実行
- **テスト環境**: PLCシミュレータ使用
- **合格基準**: 全テストケース100%成功
- **実行頻度**: コード変更時の回帰テストとして実行

#### **TC143_10 Step3-6 M100～M107ビット読み出し2パターン統合テスト（オフライン）**

**目的**: 実際のPLC機器無しで、M100～M107ビット読み出しの2パターン（3E/4E × バイナリ）について、Step3-6の完全な通信フローが正しく動作することを検証

**テストデータ仕様:**

##### 想定するPLC設備状態
```
M100: OFF (0)
M101: OFF (0)
M102: OFF (0)
M103: ON  (1)
M104: OFF (0)
M105: OFF (0)
M106: ON  (1)
M107: ON  (1)

ビット配列: 0 0 0 1 0 0 1 1
16進数: 0xC8 (1バイト目), 0x00 (2バイト目、未使用ビット)
```

##### パターン1: 3Eフレーム × バイナリ（ビット単位読み出し）

**送信フレーム（23バイト）:**
```
50 00 00 FF FF 03 00 0E 00 00 00 01 04 01 00 9C 00 64 00 00 00 08 00
```

| フィールド | バイト列 | 説明 |
|-----------|---------|------|
| サブヘッダ | `50 00` | 3Eフレーム |
| ネットワーク番号 | `00` | ローカル |
| PC番号 | `FF` | 直接接続 |
| ユニットI/O | `FF 03` | 0x03FF (リトルエンディアン) |
| 局番 | `00` | マルチドロップなし |
| 要求データ長 | `0E 00` | 14バイト (リトルエンディアン) |
| CPU監視タイマ | `00 00` | 無制限 |
| コマンド | `01 04` | 一括読み出し |
| サブコマンド | `01 00` | **ビット単位** |
| デバイスコード | `9C` | M (内部リレー) |
| 開始デバイス番号 | `64 00 00 00` | M100 (0x64, 3バイト + パディング) |
| デバイス点数 | `08 00` | 8点 (M100-M107) |

**受信フレーム（13バイト）:**
```
D0 00 00 FF FF 03 00 04 00 00 00 C8 00
```

| フィールド | バイト列 | 説明 |
|-----------|---------|------|
| サブヘッダ | `D0 00` | 応答フレーム |
| ネットワーク番号 | `00` | |
| PC番号 | `FF` | |
| 要求元IOユニット | `FF 03` | |
| 要求元局番 | `00` | |
| 応答データ長 | `04 00` | 4バイト (終了コード2 + データ2) |
| 終了コード | `00 00` | **正常終了** |
| データ | `C8 00` | M100-M107: 11001000b (リトルエンディアン) |

**解析後データ（成功条件）:**
```json
{
  "status": "SUCCESS",
  "end_code": "0x0000",
  "error_message": null,
  "device_type": "M",
  "start_address": 100,
  "point_count": 8,
  "data_format": "bit",
  "bit_values": [
    { "address": "M100", "value": 0 },
    { "address": "M101", "value": 0 },
    { "address": "M102", "value": 0 },
    { "address": "M103", "value": 1 },
    { "address": "M104", "value": 0 },
    { "address": "M105", "value": 0 },
    { "address": "M106", "value": 1 },
    { "address": "M107", "value": 1 }
  ],
  "raw_data_hex": "C8 00"
}
```

##### パターン2: 4Eフレーム × バイナリ（ビット単位読み出し）

**送信フレーム（27バイト）:**
```
54 00 00 00 00 00 00 FF FF 03 00 0E 00 00 00 01 04 01 00 9C 00 64 00 00 00 08 00
```
※ 4Eフレームはサブヘッダ後に予約フィールド4バイト（`00 00 00 00`）が追加

**受信フレーム（17バイト）:**
```
D4 00 00 00 00 00 00 FF FF 03 00 04 00 00 00 C8 00
```

| フィールド | バイト列 | 説明 |
|-----------|---------|------|
| サブヘッダ | `D4 00` | 4E応答フレーム |
| シリアル | `00 00` | 要求のエコーバック |
| 予約 | `00 00` | 予約領域 |
| ネットワーク番号 | `00` | |
| PC番号 | `FF` | |
| 要求元IOユニット | `FF 03` | |
| 要求元局番 | `00` | |
| 応答データ長 | `04 00` | 4バイト (終了コード2 + データ2) |
| 終了コード | `00 00` | **正常終了**（※応答に監視タイマなし） |
| データ | `C8 00` | M100-M107: 11001000b |

**解析後データ:** パターン1と同じ構造化データ

**成功条件（テスト合格基準）:**

全2パターン（3E/4E × バイナリ）で以下の条件を満たすこと：

###### 1. Step3（接続）の成功条件
- ConnectionResponse.Status == `Connected`
- Socket接続情報が正しく設定されている
- 例外が発生しない

###### 2. Step4-1（送信）の成功条件
- 送信バイト数 == 期待バイト数
  - 3E Binary: 23バイト
  - 4E Binary: 27バイト（サブヘッダ+予約4バイト追加）
- 送信フレームの16進数ダンプが期待値と一致
- 送信統計が正しく記録される
- 例外が発生しない

###### 3. Step4-2（受信）の成功条件
- 受信バイト数 == 期待バイト数
  - 3E Binary: 13バイト（サブヘッダ2 + ヘッダー9 + データ2）
  - 4E Binary: 17バイト（サブヘッダ2 + シリアル・予約4 + ヘッダー9 + データ2）
- 受信データの16進数ダンプが期待値と一致
  - 3E Binary: `D0 00 00 FF FF 03 00 04 00 00 00 C8 00`（13バイト）
  - 4E Binary: `D4 00 00 00 00 00 00 FF FF 03 00 04 00 00 00 C8 00`（17バイト）
- 生データ(16進数)として正しく保存される
- 例外が発生しない

###### 4. Step5（切断）の成功条件
- 切断処理が正常に完了する
- 接続統計情報が正しく記録される
- リソースが適切に解放される（メモリリークなし）
- 例外が発生しない

###### 5. Step6（データ解析）の成功条件
- 終了コードが正常（`0x0000`）
- StructuredData.IsError == `false`
- StructuredData.Status == `"SUCCESS"`
- StructuredData.EndCode == `"0x0000"`
- StructuredData.ErrorMessage == `null`
- デバイス情報が正しい:
  - DeviceType == `"M"`
  - StartAddress == `100`
  - PointCount == `8`
  - DataFormat == `"bit"`
- ビット値が期待通り:
  ```
  M100: 0 (OFF)  ← bit_values[0].value == 0
  M101: 0 (OFF)  ← bit_values[1].value == 0
  M102: 0 (OFF)  ← bit_values[2].value == 0
  M103: 1 (ON)   ← bit_values[3].value == 1
  M104: 0 (OFF)  ← bit_values[4].value == 0
  M105: 0 (OFF)  ← bit_values[5].value == 0
  M106: 1 (ON)   ← bit_values[6].value == 1
  M107: 1 (ON)   ← bit_values[7].value == 1
  ```
- RawDataHex == `"C8 00"`

**統合成功条件（全パターン共通）:**

- **フレーム整合性**: 送信フレームと受信フレームが仕様通りの構造
- **データ整合性**: ビット配列 `0 0 0 1 0 0 1 1` が正しく `0xC8` にエンコードされ、デコードされる
- **エラーハンドリング**: 異常系でも適切にエラーが検出・報告される
- **リソース管理**: 全ステップ完了後、リソースが解放されている
- **ログ出力**: 各ステップで適切なログが出力される
- **実行時間**: 各パターンが妥当な時間内（例: 5秒以内）に完了する

**不合格条件（即座に調査が必要）:**

以下のいずれかが発生した場合、テスト不合格：

- ❌ 送信バイト数が期待値と異なる → Step4-1（送信）の実装に問題
- ❌ 受信バイト数が期待値と異なる → Step4-2（受信）の実装に問題
- ❌ 終了コードが `0x0000` 以外 → フレーム構築またはモック応答に問題
- ❌ ビット値が期待値と異なる → Step6（データ解析）の実装に問題
- ❌ 例外が発生する → 該当ステップの実装に問題
- ❌ リソースリークが検出される → リソース管理に問題
- ❌ 3E/4Eで結果が異なる → フレーム形式別処理に問題

**テスト実施手順:**
1. **Phase 1**: テストケースを `テスト内容.md` のTC143_10として追加（✅完了）
2. **Phase 2**: PLCシミュレータまたはネットワークモックの準備
   - 送信フレーム2パターンを受け取り
   - 応答データ `C8 00` を含む正常応答を返却
3. **Phase 3**: テストパターン実装（2パターン実行）
4. **Phase 4**: Step3-6統合動作確認
5. **Phase 5**: 結果記録（`documents/implementation_records/execution_logs/` に保存）

**重要性:**
- **PLC機器不要**: 完全オフライン環境でのテスト実施可能
- **テスト駆動開発**: 実機テスト前に通信フロー全体の動作保証
- **品質保証**: 2パターン全ての組み合わせで動作確認
- **実機テスト準備**: オフラインテスト成功後、実機テストへ移行

#### **TC143_11 4Eフレーム ランダム読み出し（複数デバイス）実機データ解析テスト**

**目的**: 実機PLCから受信した4Eフレーム（ランダム読み出し応答）の構造解析とデータ抽出が正しく動作することを検証

**テストデータ仕様:**

##### 実際に受信した4Eフレーム（113バイト）

**受信フレーム全体:**
```
D4 00 00 00 00 00 00 FF FF 03 00 62 00 00 00 00 00
FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
07 19 FF FF FF FF FF FF FF FF FF FF FF FF FF FF
FF FF 00 10 00 08 00 01 00 10 00 10 00 08 20 00
10 00 08 00 02 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```

##### フレーム構造解析

**ヘッダー部分（15バイト）:**

| オフセット | バイト列 | フィールド | 値 | 説明 |
|-----------|---------|-----------|-----|------|
| 0-1 | `D4 00` | サブヘッダ | 0xD400 | 4E応答フレーム |
| 2-3 | `00 00` | シリアル | 0x0000 | 要求のエコーバック |
| 4-5 | `00 00` | 予約 | 0x0000 | 予約領域 |
| 6 | `00` | ネットワーク番号 | 0 | ローカル |
| 7 | `FF` | PC番号 | 255 | 全局 |
| 8-9 | `FF 03` | I/O番号 | 0x03FF | 1023 (LE) |
| 10 | `00` | 局番 | 0 | マルチドロップなし |
| 11-12 | `62 00` | データ長 | 0x0062 | 98バイト (LE) |
| 13-14 | `00 00` | 終了コード | 0x0000 | **正常終了** ✓（※応答に監視タイマなし） |

**デバイスデータ部分（96バイト、オフセット15～110）:**

```
[15-30]   FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF  (16バイト: 全FF)
[31-32]   07 19                                              (LE: 0x1907 = 6407)
[33-46]   FF FF FF FF FF FF FF FF FF FF FF FF FF FF        (14バイト: 全FF)
[47-48]   FF FF                                              (2バイト: 全FF)
[49-50]   00 10                                              (LE: 0x1000 = 4096)
[51-52]   00 08                                              (LE: 0x0800 = 2048)
[53-54]   00 01                                              (LE: 0x0100 = 256)
[55-56]   00 10                                              (LE: 0x1000 = 4096)
[57-58]   00 10                                              (LE: 0x1000 = 4096)
[59-60]   00 08                                              (LE: 0x0800 = 2048)
[61-62]   20 00                                              (LE: 0x0020 = 32)
[63-64]   10 00                                              (LE: 0x0010 = 16)
[65-66]   08 00                                              (LE: 0x0008 = 8)
[67-68]   02 00                                              (LE: 0x0002 = 2)
[69-110]  00 00 ... 00 00                                    (42バイト: 全00)
```

##### ワードデバイス値抽出（リトルエンディアン）

デバイスデータを2バイトずつワード値として解釈：

| インデックス | オフセット | バイト列 | 値（10進） | 値（16進） |
|------------|----------|---------|-----------|-----------|
| Word 0-7 | 15-30 | `FF FF ... FF FF` | 65535×8 | 0xFFFF×8 |
| Word 8 | 31-32 | `07 19` | **6407** | **0x1907** |
| Word 9-15 | 33-46 | `FF FF ... FF FF` | 65535×7 | 0xFFFF×7 |
| Word 16-17 | 47-50 | `FF FF 00 10` | 65535, 4096 | 0xFFFF, 0x1000 |
| Word 18 | 51-52 | `00 08` | 2048 | 0x0800 |
| Word 19 | 53-54 | `00 01` | 256 | 0x0100 |
| Word 20-21 | 55-58 | `00 10 00 10` | 4096×2 | 0x1000×2 |
| Word 22 | 59-60 | `00 08` | 2048 | 0x0800 |
| Word 23 | 61-62 | `20 00` | 32 | 0x0020 |
| Word 24 | 63-64 | `10 00` | 16 | 0x0010 |
| Word 25 | 65-66 | `08 00` | 8 | 0x0008 |
| Word 26 | 67-68 | `02 00` | 2 | 0x0002 |
| Word 27-47 | 69-110 | `00 00 ... 00 00` | 0×21 | 0x0000×21 |

##### 検証項目

**1. フレーム構造の正確性:**
- ✓ サブヘッダが `D4 00` （4E応答フレーム）
- ✓ シリアルフィールド（2バイト）と予約フィールド（2バイト）が存在
- ✓ ヘッダー長が15バイト（サブヘッダ2 + シリアル・予約4 + ネットワーク～データ長7 + 終了コード2）
- ✓ デバイスデータ開始位置がオフセット15
- ✓ **重要**: 4E応答フレームには監視タイマフィールドが存在しない

**2. 終了コードの検証:**
- ✓ 終了コード = `0x0000` （正常終了）
- ✓ エラーメッセージ = null

**3. データ長の整合性:**
- ✓ データ長フィールド = 98バイト（0x62）
- ✓ 実際のデータ長 = 終了コード（2バイト） + デバイスデータ（96バイト） = 98バイト

**4. デバイスデータの解析:**
- ✓ デバイスデータ長 = 96バイト
- ✓ ワード数 = 48ワード（96バイト ÷ 2）
- ✓ リトルエンディアン変換が正しい
- ✓ 特徴的な値の検出:
  - Word 8 = 6407 (0x1907)
  - Word 23 = 32 (0x0020)
  - Word 24 = 16 (0x0010)
  - Word 25 = 8 (0x0008)
  - Word 26 = 2 (0x0002)

**5. エッジケースの処理:**
- ✓ 0xFFFF（最大値）の正しい処理
- ✓ 0x0000（最小値）の正しい処理
- ✓ 混在データ（FF, 有効値, 00）の正しい解析

**成功条件（テスト合格基準）:**

1. **ヘッダー解析成功:**
   - サブヘッダ判定: `4Eフレーム` として認識
   - 終了コード抽出: オフセット13-14から `0x0000` を正しく取得
   - データ長検証: 98バイトを正しく認識
   - **監視タイマフィールドが存在しないことを正しく認識**

2. **デバイスデータ抽出成功:**
   - デバイスデータ開始位置: オフセット15から正しく抽出
   - デバイスデータ長: 96バイトを正しく取得

3. **ワード値変換成功:**
   - リトルエンディアン変換が全ワードで正しい
   - 特徴的な値（6407, 32, 16, 8, 2）が正確に抽出される

4. **エラーハンドリング:**
   - フレーム長不足時に適切なエラー検出
   - 不正なサブヘッダ時に適切なエラー検出

**不合格条件（即座に調査が必要）:**

- ❌ 終了コード抽出位置が誤っている（オフセット11-12や15-16を使用している）
- ❌ デバイスデータ開始位置が誤っている（オフセット13や17を使用している）
- ❌ シリアル・予約フィールドが考慮されていない
- ❌ 監視タイマフィールドが存在すると誤認している（応答フレームには監視タイマなし）
- ❌ ヘッダー長が17バイトとして処理されている（正しくは15バイト）
- ❌ ワード値がリトルエンディアンで正しく変換されていない
- ❌ 特徴的な値が抽出できていない

**重要性:**
- **実機データ検証**: 実際のPLC通信データに基づく検証
- **フレーム構造確認**: ドキュメント（フレーム構築方法.md）との整合性確認
- **バグ早期発見**: 4Eフレーム解析の実装誤りを検出
- **品質保証**: 実機テスト前の信頼性向上

### 7.3 エラーハンドリング統合テスト
**目的**: エラー発生時の処理フローをテスト

- **TC144_統合_エラーハンドリング_リトライ**
  - 手順:
    1. ConnectAsync実行（タイムアウト発生）
    2. ErrorHandler.DetermineErrorCategory実行
    3. ErrorHandler.ApplyRetryPolicy実行
    4. リトライ実行
  - 期待結果: 適切なリトライ処理が実行される

---

## 8. パフォーマンステスト

### 8.1 メモリ使用量テスト
- **TC145_Performance_メモリ使用量**
  - 目的: 長時間実行時のメモリリーク検証
  - 手順: 1000回の通信サイクル実行
  - 期待結果: メモリ使用量が閾値内に収まる

### 8.2 応答時間テスト
- **TC146_Performance_応答時間**
  - 目的: 通信応答時間の性能検証
  - 手順: 連続100回の通信測定
  - 期待結果: 平均応答時間が仕様内（例: 100ms以下）

---

## 9. テスト実行環境・ツール

### 9.1 単体テストフレームワーク
- **xUnit** または **NUnit** を使用
- **Moq** を使用したモックオブジェクト作成

### 9.2 テストデータ
- **appsettings.xlsx**: 正常系テスト用設定ファイル（M001-M999, D001-D999対応）
- **invalid_settings.xlsx**: 異常系テスト用設定ファイル
- **sample_slmp_frames.txt**: 既知のSLMPフレームサンプル（DWord分割対応）

### 9.3 📋 公式リファレンスデータ（三菱電機公式SLMP仕様書）
- **参照元**: `C:\Users\1010821\Desktop\python\andon\pdf2img\sh080931q.pdf`
- **三菱電機公式SLMPリファレンスマニュアル**: 98ページの詳細な技術仕様書
- **TC012～TC014で活用する既知の入力出力例**:
  - **M100～M107ビット読み出し通信例**:
    - 要求: `01H, 04H, 01H, 00H, 64H, 00H, 00H, 90H, 08H, 00H`
    - 応答: `00H, 01H, 00H, 11H` (M100=OFF, M101=ON, M102-M106=OFF, M107=ON)
  - **M100～M131ワード読み出し通信例**:
    - 要求: `01H, 04H, 00H, 00H, 64H, 00H, 00H, 90H, 02H, 00H`
    - 応答: `34H, 12H, 02H, 00H` (2ワード分のデータ)
  - **3E/4Eフレーム構造詳細**: 第4章「伝文フォーマット」
  - **READコマンド(0401)詳細**: 第5章「コマンド」
- **テスト品質向上**: 実際のPLC通信で使用される標準パターンによる検証
- **トレーサビリティ**: 公式仕様書への直接的な参照

### 9.4 モック・スタブ
- **PLCシミュレータ**: 実際のPLC無しでの通信テスト
- **ファイルシステムモック**: ファイルI/Oテスト用
- **ネットワークモック**: 通信エラーシミュレーション用

---

## 14. テスト実行順序（更新版）

### Phase構成 - 実装優先順位対応

1. **Phase 1**: ConfigToFrameManager単体テスト (TC001-TC016) - LoadConfigAsync, GetConfig, SplitDwordToWord, BuildFrames（DWord分割処理含む）
2. **Phase 2**: PlcCommunicationManager単体テスト (TC017-TC041) - 最優先、ConnectAsync, SendFrameAsync, ReceiveResponseAsync, DisconnectAsync, PostprocessReceivedData, ParseRawToStructuredData（全機器データ取得・DWord結合処理含む）
3. **Phase 3**: LoggingManager単体テスト (TC042-TC060) - InitializeAsync, SetCorrelationId, SetLogLevel, IsLogLevelEnabled, LogConfigAsync, LogCommunicationAsync, LogStateAsync, LogMetricAsync, LogErrorAsync, LogDeviceDataAsync, BeginTransaction, EndTransaction, FlushAsync
4. **Phase 4**: ErrorHandler単体テスト (TC061-TC087) - DetermineErrorCategory, RecordError, ApplyErrorPolicy, ApplyRetryPolicy, ErrorMessages統一管理テスト, MultiConfigLoadException詳細テスト, バランス型例外処理統合テスト
5. **Phase 5**: ResourceManager単体テスト (TC088-TC094) - GetMemoryUsage, EvaluateLevel, ApplyDataAndLoggingPolicy, OptimizeMemory, WriteLogAsync, RunMonitoringLoopAsync
6. **Phase 6**: DataOutputManager単体テスト (TC095-TC099)

### 新規追加Phase - アーキテクチャ拡張対応

7. **Phase 7**: ApplicationController・ExecutionOrchestrator単体テスト (TC150-TC168) - **高優先度**
   - ApplicationController: StartAsync, StopAsync, ExecuteStep1InitializationAsync, StartContinuousDataCycleAsync
   - ExecutionOrchestrator: RunContinuousDataCycleAsync, ExecuteSingleCycleAsync, GetMonitoringInterval
   - AndonHostedService: ExecuteAsync, StartAsync, StopAsync（.NET HostedService統合）
   - TimerService: StartPeriodicExecution（MonitoringIntervalMs間隔制御）
   - GracefulShutdownHandler: RegisterShutdownHandlers, ExecuteGracefulShutdown（適切な終了制御）

8. **Phase 8**: 非同期・並行処理アーキテクチャ単体テスト (TC169-TC181) - **高優先度**
   - AsyncExceptionHandler: HandleCriticalOperationAsync, HandleGeneralOperationsAsync（階層的例外処理）
   - CancellationCoordinator: CreateHierarchicalToken, RegisterCancellationCallback（階層的キャンセル制御）
   - ResourceSemaphoreManager: ExecuteWithSemaphoreAsync, GetResourceSemaphore（共有リソース排他制御）
   - ProgressReporter: Report, CreateStepProgress（リアルタイム進捗報告）
   - ParallelExecutionController: ExecuteParallelPlcOperationsAsync, MonitorParallelExecution（複数PLC並行実行）

9. **Phase 9**: DIコンテナ設計単体テスト (TC182-TC192) - **中優先度**
   - DependencyInjectionConfigurator: ConfigureServices, RegisterCoreServices, RegisterInfrastructureServices, RegisterAsyncServices, RegisterHostedServices
   - OptionsConfigurator: ConfigureOptions, ValidateOptions（Optionsパターン設定値注入）
   - ServiceLifetimeManager: DetermineLifetime, ValidateLifetimeConsistency（ライフタイム最適化）
   - MultiConfigDIIntegration: RegisterMultiConfigServices, CreateConfigSpecificProvider（複数設定ファイル対応）

10. **Phase 10**: Program.cs・エントリーポイント単体テスト (TC193-TC209) - **中優先度**
    - Program: Main, CreateHostBuilder, ConfigureServices, ConfigureConfiguration, ConfigureLogging
    - CommandLineOptions: Parse, Validate（コマンドライン引数処理）
    - ExitCodeManager: DetermineExitCode, LogExitInformation（終了コード統一管理）

11. **Phase 11**: インターフェース設計テスタビリティテスト (TC100-TC116) - **中優先度**
    - 既存インターフェース分離テスト (TC100-TC105)
    - 新規追加インターフェース分離テスト (TC106-TC115): IApplicationController, IExecutionOrchestrator, IAsyncExceptionHandler, ICancellationCoordinator, IResourceSemaphoreManager, IProgressReporter<T>, IParallelExecutionController, ITimerService, IGracefulShutdownHandler, IMultiConfigDIIntegration
    - TDD手法サポートテスト (TC116)

12. **Phase 12**: Modelsクラス単体テスト (TC117-TC141) - **低優先度**
    - 既存Models: ConfigModels, PlcCommunicationManager用データ転送オブジェクト (TC117-TC132)
    - 非同期・並行処理用データ転送オブジェクト (TC133-TC138): ResourceType, AsyncOperationResult<T>, GeneralOperationResult, ParallelExecutionResult, ProgressInfo, ParallelProgressInfo
    - ApplicationController用データ転送オブジェクト (TC139-TC141): InitializationResult, CycleExecutionResult, ShutdownResult

13. **Phase 13**: 統合テスト (TC142-TC144) - **最重要**
    - Step1-2統合テスト: 設定読み込み→フレーム構築（DWord分割対応）
    - Step3-6統合テスト: PLC通信全体（DWord結合対応）
    - エラーハンドリング統合テスト: リトライ・継続制御

14. **Phase 14**: パフォーマンステスト (TC145-TC146) - **最重要**
    - メモリ使用量テスト: 長時間実行・メモリリーク検証
    - 応答時間テスト: 通信応答時間・性能特性

### テスト統計（更新版）

**総テストケース数: 254個**（従来150個から+104個増加）

**新規追加テストケース詳細**:
- ApplicationController・ExecutionOrchestrator関連: +19テストケース (TC052-TC070)
- 非同期・並行処理アーキテクチャ関連: +13テストケース (TC071-TC083)
- DIコンテナ設計関連: +11テストケース (TC084-TC094)
- Program.cs・エントリーポイント関連: +17テストケース (TC095-TC111)
- 新しいデータ転送オブジェクト: +9テストケース (TC047_17-TC047_25)
- インターフェース設計拡張: +10テストケース (TC046_7-TC046_16)
- その他詳細メソッドテスト: +25テストケース

**バランス型例外設計対応**: +16テストケース (TC038_3-TC038_18)
**詳細メソッドテスト追加**: +51テストケース

### 実行優先度判定

1. **最重要（Phase 1-2, 13-14）**: ConfigToFrameManager, PlcCommunicationManager, 統合テスト, パフォーマンステスト
   - Step3-6ブロック（PLC通信）の確実な動作確認
   - DWord分割・結合処理の動作確認
   - システム全体の統合動作確認

2. **高優先度（Phase 7-8）**: ApplicationController・ExecutionOrchestrator, 非同期・並行処理
   - アプリケーション制御ロジックの確実な動作
   - 並行実行・例外処理の信頼性確保

3. **中優先度（Phase 3-6, 9-11）**: 各Managerクラス, DIコンテナ, エントリーポイント, インターフェース設計
   - システム支援機能の品質確保
   - 保守性・テスタビリティの確保

4. **低優先度（Phase 12）**: Modelsクラス
   - データ転送オブジェクトの型安全性確保

各Phase完了後、次のPhaseに進む前にテスト結果を確認し、全テストが合格することを確認する。

**Phase 7-8重点項目**: 新規アーキテクチャ拡張の動作確認
- ApplicationController・ExecutionOrchestratorによる適切なライフサイクル管理
- 非同期・並行処理による複数PLC並行実行制御
- CancellationToken階層管理によるグレースフル停止制御
- AsyncExceptionHandler・ResourceSemaphoreManagerによる信頼性確保

**Phase 4重点項目**: バランス型例外設計の動作確認
- MultiConfigLoadException（カスタム例外）の詳細エラー情報保持
- ErrorMessages.cs（統一メッセージ管理）の品質・一貫性
- 標準例外との使い分け判定の正確性
- 権限チェック（単純ファイル作成テスト）の確実性

---

## 11. モック・スタブ設計詳細

### 11.1 ConfigToFrameManager テスト用モック・スタブ

#### ファイルシステムモック（TC001-TC004）
**目的**: appsettings.xlsx読み込み処理の外部依存を排除し、様々なファイル状態をテスト

**モック設計**:
- **正常系テスト用データ**: UTF-8形式の有効なExcelファイルをメモリ上で模擬
  - 設定項目: ConnectionConfig（IpAddress="192.168.1.10", Port=5000）
  - 設定項目: TimeoutConfig（ReceiveTimeoutMs=3000, ConnectTimeoutMs=5000）
  - 設定項目: TargetDeviceConfig（MDeviceRange="M001-M999", DDeviceRange="D001-D999"）
  - その他全設定項目を含む完全な設定データ
- **異常系テスト用シナリオ**:
  - FileNotFoundException発生条件の設定
  - 不正フォーマット（非Excelファイル）の模擬
  - 必須項目欠如データの作成（例：IpAddress未設定、Port未設定）
  - エンコーディング異常（非UTF-8）の模擬

**スタブ設計**:
- **設定オブジェクト予め定義**: 各テストケース用の既知の設定値をスタブとして準備
- **設定取得メソッドスタブ**: GetConfig呼び出し時の戻り値を事前定義
- **未初期化状態模擬**: LoadConfigAsync未実行状態での例外発生をスタブで制御

#### デバイスデータ処理スタブ（TC008-TC011）
**目的**: SplitDwordToWord処理の入力・出力パターンを既知データで検証

**スタブ設計**:
- **DWord分割処理用テストデータ**:
  - 入力: DDeviceRange="D001-D999", DataType=DWord
  - 期待出力: 32bit値を16bit×2に分割済みの前処理情報
  - 検証項目: 分割後のアドレス範囲、データサイズ計算の正確性
- **混合データ型テストデータ**:
  - 入力: MDeviceRange="M001-M100"（ビット）+ DDeviceRange="D001-D100"（ワード・DWord混在）
  - 期待出力: データ型別に最適化された要求情報
- **不正範囲データ**: "M1000-M999"等の論理的に無効な範囲指定

#### SLMPフレーム構築スタブ（TC012-TC016）
**目的**: 三菱電機公式仕様書準拠の既知フレームでBuildFrames処理を検証

**スタブ設計**:
- **3Eフレーム公式実例データ**: pdf2img/sh080931q.pdfの仕様書から抽出
  - M100～M107ビット読み出し用フレーム
  - 期待出力: "5000040100006400000090080000"（公式実例準拠）
- **4Eフレーム公式実例データ**:
  - M100～M131ワード読み出し用フレーム
  - 期待出力: "54001234000000040000006400000090020000"（公式実例準拠）
- **ASCIIフレーム変換データ**:
  - バイナリフレームの各バイトを2文字ASCII16進数に変換
  - 期待出力: "30313034303130303634303030303930303830303030"

### 11.2 PlcCommunicationManager テスト用モック・スタブ

#### ネットワーク通信モック（TC012-TC015）
**目的**: 実際のPLC機器無しでTCP/UDP通信をテスト

**モック設計**:
- **接続成功シナリオ**: 指定IP・ポートへの接続を即座に成功として応答
  - 内部状態管理: 接続状態フラグ、RemoteEndPoint設定、ConnectedAt時刻記録
- **接続失敗シナリオ**:
  - タイムアウト: 指定時間経過後にTimeoutException発生
  - 接続拒否: SocketException（ConnectionRefused）発生
  - ネットワーク到達不能: SocketException（NetworkUnreachable）発生
- **UDP接続特殊処理（TC018対応）**: UDP特有の接続レス動作を模擬
  - 模擬送信フレーム（M000-M999読み込み）: "54001234000000010401006400000090E8030000"
    - 構成: サブヘッダ(54001234000000) + READコマンド(0401) + サブコマンド(0100:ビット単位) + デバイスコード(6400:M機器) + 開始番号(00000090:M000) + デバイス点数(E80300:1000点)
  - 模擬送信フレーム（D000-D999読み込み）: "54001234000000010400A800000090E8030000"
    - 構成: サブヘッダ(54001234000000) + READコマンド(0401) + サブコマンド(0000:ワード単位) + デバイスコード(A800:D機器) + 開始番号(00000090:D000) + デバイス点数(E80300:1000点)
  - 模擬応答: ConnectTimeoutMs内に正常なSLMP応答を返却
  - 疎通確認: Socket.Connected状態確認、RemoteEndPoint設定確認
  - タイムアウト処理: 指定時間経過で応答なし→TimeoutException発生
  - 完全オフライン対応: 実際のネットワーク通信不要、全てモック内で完結

#### PLCシミュレータ（TC016-TC030）
**目的**: 実際のPLC応答を三菱電機公式仕様書に基づいて模擬

**シミュレータ設計**:
- **公式実例応答データ**:
  - M100～M107ビット読み出し要求に対する応答: "00010011"
    - 解釈: M100=OFF, M101=ON, M102-M106=OFF, M107=ON
  - M100～M131ワード読み出し要求に対する応答: "34120200"
    - 解釈: 2ワード分のデータ（0x1234, 0x0002）
- **エラー応答データ**:
  - 不正デバイス指定時のエラーコード応答
  - タイムアウト時の応答無し状態
- **フレーム形式対応**:
  - 3E/4Eフレーム別の応答ヘッダー生成
  - バイナリ/ASCII形式対応
  - 終了コード（正常/エラー）制御

#### データ後処理・解析スタブ（TC023-TC030）
**目的**: DWord結合処理と構造化データ変換の検証

**スタブ設計**:
- **DWord結合テストデータ**:
  - 入力: 16bit×2に分割された受信データ（例："1234", "5678"）
  - 期待出力: 32bitに結合されたデータ（例：0x56781234）
  - 検証項目: エンディアン処理の正確性
- **構造化データ変換テストデータ**:
  - 入力: SLMPレスポンスフレーム（ヘッダー + データ部）
  - 期待出力: 解析済み構造化データ（ヘッダー情報、終了コード、データ配列）
- **エラー終了コード処理**:
  - 異常終了コードを含む応答データ
  - エラー情報を含む構造化データへの変換

### 11.3 LoggingManager テスト用モック・スタブ

#### ファイルI/Oモック（TC031-TC032）
**目的**: ログファイル出力処理の外部依存を排除し、ファイルシステム状態をテスト

**モック設計**:
- **正常書き込みシナリオ**: メモリ上でのファイル書き込み模擬
  - ディレクトリ作成処理（logs/terminal_output.txt, logs/rawdata_analysis.json）
  - ファイル書き込み処理（追記・上書きモード対応）
  - ファイルローテーション処理（MaxFileSizeMB, MaxFileCount制限）
- **異常系シナリオ**:
  - ディスク容量不足: IOException発生
  - アクセス権限不足: UnauthorizedAccessException発生
  - ファイルロック中: IOException発生

**検証項目**:
- **出力内容検証**: 書き込まれたログ内容の文字列一致確認
- **出力先検証**: ConsoleOutput/DetailedLog設定別の出力先振り分け
- **フォーマット検証**: JSON形式、テキスト形式の出力フォーマット

#### コンソール出力モック（TC033-TC034）
**目的**: リアルタイムコンソール表示をテスト環境で捕捉・検証

**モック設計**:
- **出力捕捉**: Console.WriteLine/Write呼び出しをメモリバッファに記録
- **リアルタイム性検証**: ログ出力タイミングと内容の対応関係確認
- **設定連動確認**: ConsoleOutput設定による出力制御の動作確認

### 11.4 ErrorHandler テスト用モック・スタブ（バランス型例外設計対応）

#### 例外発生シナリオスタブ（TC035-TC038）
**目的**: 各種エラー状況を再現し、エラー分類・処理ロジックをテスト

**スタブ設計**:
- **通信エラー系**:
  - SocketException（NetworkUnreachable, ConnectionRefused, TimedOut）
  - TimeoutException（受信タイムアウト、接続タイムアウト）
- **設定エラー系**:
  - ConfigurationException（必須項目不足、不正値）
  - FileNotFoundException（設定ファイル不存在）
  - FormatException（設定値形式異常）
- **データ処理エラー系**:
  - FormatException（16進数変換失敗）
  - ArgumentException（デバイス範囲不正）
- **リソースエラー系**:
  - OutOfMemoryException（メモリ不足）
  - IOException（ディスク容量不足）

**エラー分類テストデータ**:
- **Step番号対応**: 各Stepで発生する典型的エラーパターン
- **Severity判定**: エラー種別とStep番号の組み合わせによる重要度決定ロジック
- **リトライ判定**: エラーカテゴリとリトライ回数による継続可否判定

#### バランス型例外設計テスト用モック・スタブ（TC038_3-TC038_18）
**目的**: 混在型例外設計、統一メッセージ管理、権限チェック方式の動作検証

**ErrorMessagesテスト用スタブ設計**:
- **メッセージパラメータテストデータ**:
  - 設定ファイル関連: ファイルパス、エラー詳細の様々なパターン
  - 複数設定ファイル関連: 成功/失敗件数の組み合わせパターン（0-10件範囲）
  - 通信関連: IPアドレス・ポート番号の有効/無効パターン
  - 権限・ファイルシステム関連: 各種パス形式（相対/絶対、Windows/Unix形式）
  - メモリ・リソース関連: 使用量・制限値の境界値パターン
- **メッセージ品質検証データ**:
  - 日本語表現の自然さ確認用サンプル
  - パラメータ埋め込み精度確認用データセット
  - 重複チェック用全メッセージ一覧

**MultiConfigLoadExceptionテスト用スタブ設計**:
- **完全失敗シナリオデータ**:
  - 読み込み対象: 3-5個の設定ファイル（すべて失敗）
  - 失敗種別: FileNotFoundException, FormatException, IOException混在
  - ディレクトリ・パターン: 実際の使用パターンに準拠
- **部分成功シナリオデータ**:
  - 成功ファイル: 正常な設定ファイル（2-3個）
  - 失敗ファイル: 様々な例外パターン（1-2個）
  - 部分成功率: 20%-80%の範囲で多様なパターン
- **詳細情報保持検証データ**:
  - 例外チェーン: InnerException含む複層構造
  - 統計情報: 自動計算プロパティの精度確認
  - エラーレポート: 人間が読みやすい形式の出力確認

**権限チェックテスト用モック設計**:
- **書き込み権限モック**:
  - 権限あり: ファイル作成・削除が正常実行
  - 権限なし: UnauthorizedAccessException発生
  - 部分権限: 読み取り可・書き込み不可状態
- **ファイルシステム状態モック**:
  - ディスク容量不足: IOException（No space left on device）
  - ディレクトリ不存在: DirectoryNotFoundException
  - ファイルロック中: IOException（Access denied）
- **権限チェック結果検証**:
  - 単純ファイル作成テスト実行確認
  - 適切な例外タイプ・メッセージ生成確認
  - ErrorMessages統一メッセージ使用確認

**例外使い分け判定テスト用スタブ設計**:
- **カスタム例外適用シナリオ**:
  - 複数設定ファイル関連: MultiConfigLoadException使用
  - 詳細情報が重要な場面: カスタム例外の詳細プロパティ活用
- **標準例外適用シナリオ**:
  - 単一ファイル操作: FileNotFoundException, IOException等
  - 一般的エラー状況: ArgumentException, InvalidOperationException等
- **メッセージ統一確認**:
  - カスタム例外: ErrorMessages使用確認
  - 標準例外: ErrorMessagesでのwrap確認
  - 一貫したメッセージ品質・形式確認

### 11.5 ResourceManager テスト用モック・スタブ

#### システム情報モック（TC039-TC041）
**目的**: メモリ使用量・システムリソース情報を模擬し、閾値判定ロジックをテスト

**モック設計**:
- **正常レベルシナリオ**:
  - 総メモリ: 10000KB、使用量: 1000KB（10%使用）
  - 各コンポーネント使用量: ConfigToFrameManager=200KB, PlcCommunicationManager=300KB, LoggingManager=500KB
  - 期待判定: Normal、推奨アクション=None
- **警告レベルシナリオ**:
  - 総メモリ: 10000KB、使用量: 8500KB（85%使用）
  - 閾値設定: MemoryThresholdKB=8000KB
  - 期待判定: Warning、推奨アクション=OptimizeMemory
- **危険レベルシナリオ**:
  - 総メモリ: 10000KB、使用量: 9500KB（95%使用）
  - 限界設定: MemoryLimitKB=10000KB
  - 期待判定: Critical、推奨アクション=EmergencyCleanup

**動的変化シミュレーション**:
- **メモリリーク検証**: 1000回実行後のメモリ使用量増加パターン
- **最適化効果検証**: OptimizeMemory実行前後のメモリ使用量変化

### 11.6 DataOutputManager テスト用モック・スタブ

#### 出力先モック（TC042-TC046）
**目的**: 様々な出力先・形式への データ出力処理をテスト

**モック設計**:
- **ファイル出力モック**:
  - CSV, JSON, XML形式別の出力処理
  - ファイルパス指定・作成処理
  - 既存ファイル上書き・追記処理
- **リアルタイム出力モック**:
  - ストリーミングデータ出力の連続性確認
  - 出力間隔・タイミング制御
- **異常系シナリオ**:
  - 出力先アクセス不可: UnauthorizedAccessException
  - ディスク容量不足: InsufficientMemoryException
  - ファイルロック: IOException

**出力データ検証**:
- **構造化データ変換**: ParseRawToStructuredDataの出力を入力として受け取り
- **形式別変換**: 同一データのCSV/JSON/XML形式への変換精度確認
- **データ完整性**: 出力データと元データの一致性確認

### 11.7 統合テスト用モック・スタブ組み合わせ

#### Step1-2統合テスト用統合モック（TC047）
**目的**: 設定読み込みからフレーム構築までの一連の処理を検証

**統合モック設計**:
- **モック連携**: FileSystemMock + ConfigStubs + FrameStubs
- **データフロー検証**:
  1. LoadConfigAsync（FileSystemMock） → 設定オブジェクト
  2. GetConfig（ConfigStubs） → 各種設定取得
  3. SplitDwordToWord（DeviceStubs） → 前処理済みデバイス情報
  4. BuildFrames（FrameStubs） → 完成SLMPフレーム
- **DWord分割処理統合確認**: 分割→フレーム生成の一連処理が正常動作することを確認

#### Step3-6統合テスト用統合モック（TC048）
**目的**: PLC通信全体サイクルの完全な動作検証

**統合モック設計**:
- **モック連携**: NetworkMock + PlcSimulator + DataStubs
- **通信サイクル検証**:
  1. ConnectAsync（NetworkMock） → 接続確立
  2. SendFrameAsync（NetworkMock） → フレーム送信
  3. ReceiveResponseAsync（PlcSimulator） → 応答受信
  4. PostprocessReceivedData（DataStubs） → DWord結合処理
  5. ParseRawToStructuredData（DataStubs） → 構造化変換
  6. DisconnectAsync（NetworkMock） → 接続切断
- **DWord結合処理統合確認**: 受信→結合→構造化の一連処理が正常動作することを確認

#### エラーハンドリング統合テスト用モック（TC049）
**目的**: エラー発生時の処理フロー全体をテスト

**統合モック設計**:
- **エラー注入**: 各Stepでの意図的エラー発生
- **エラー処理フロー検証**:
  1. 例外発生（各種ExceptionMocks）
  2. DetermineErrorCategory（ErrorHandler） → エラー分類
  3. RecordError（LoggingMock） → エラー記録
  4. ApplyRetryPolicy（ErrorHandler） → リトライ判定
  5. リトライ実行またはエラー終了
- **リトライ統合確認**: 複数Stepでのリトライ動作とエラー回復処理の動作確認

### 11.8 インターフェース設計テスタビリティテスト用モック・スタブ

#### インターフェース分離テスト用モック（TC046_1-TC046_6）
**目的**: 各主要クラスのインターフェース分離によるモック・スタブ置換をテスト

**モック設計**:
- **IConfigToFrameManagerモック**: 設定読み込みとフレーム構築の完全置換
  - LoadConfigAsync, GetConfig, SplitDwordToWord, BuildFrames全メソッドのモック実装
  - 実装クラスと同一の契約による機能提供確認
- **IPlcCommunicationManagerモック**: PLC通信の完全置換（最重要）
  - ConnectAsync, SendFrameAsync, ReceiveResponseAsync, DisconnectAsync等全メソッドのモック実装
  - ネットワーク通信を完全にシミュレーションし、実装クラスと同一動作確認
- **IDataOutputManager, ILoggingManager, IErrorHandler, IResourceManagerモック**: 各々の完全置換
  - 実装クラスの全メソッドをモックで置換
  - 同一インターフェース契約での完全互換性確認

#### TDD手法サポートテスト用モック（TC046_7）
**目的**: Red-Green-Refactorサイクル実行をモック・スタブで支援

**モック設計**:
- **Redフェーズ用**: 意図的に失敗するモック（期待値と異なる応答）
- **Greenフェーズ用**: 最小限の成功応答を提供するモック（最小実装テスト）
- **Refactorフェーズ用**: リファクタリング前後で同一応答を提供するモック（動作一致確認）

### 11.9 Modelsクラス単体テスト用モック・スタブ

#### ConfigModelsテスト用スタブ（TC047_1-TC047_10）
**目的**: 設定関連モデルクラスの個別動作検証

**スタブ設計**:
- **列挙型テストデータ**: ConnectionType, FrameVersion各値の境界値・無効値テスト
- **コンストラクタテストデータ**: 各Configクラスの正常値・異常値・境界値セット
- **デフォルト値検証データ**: 各Configクラスの初期値・デフォルト値の妥当性確認
- **null許容性検証データ**: 各プロパティのnull設定・取得での例外発生確認

#### PlcCommunicationManager用データ転送オブジェクトテスト用スタブ（TC047_11-TC047_16）
**目的**: PLC通信用データ転送オブジェクトの個別動作検証

**スタブ設計**:
- **ConnectionResponseテストデータ**: 成功/失敗シナリオ別のプロパティ設定パターン
- **ConnectionStatsテストデータ**: 統計メソッド（AddResponseTime等）の動作確認データ
- **ProcessedResponseDataテストデータ**: データ操作メソッドの入出力パターン
- **StructuredDataテストデータ**: 構造化メソッドの変換精度確認データ
- **SlmpHeaderテストデータ**: SLMP標準情報の完全性確認データ

### 11.10 パフォーマンステスト用モック・スタブ

#### メモリリークテスト用モック（TC050）
**目的**: 長時間実行時のメモリ使用量推移をテスト

**モック設計**:
- **反復実行制御**: 1000回の通信サイクル実行をシミュレーション
- **メモリ使用量トラッキング**: 各サイクル後のメモリ使用量記録
- **リーク検出**: 実行回数に比例したメモリ増加パターンの検出
- **閾値監視**: MemoryLimitKB超過時の動作確認

#### 応答時間テスト用モック（TC051）
**目的**: 通信応答時間の性能特性をテスト

**モック設計**:
- **応答時間制御**: PlcSimulatorでの応答遅延制御（10ms〜1000ms範囲）
- **統計データ収集**: 100回実行の応答時間データ収集・分析
- **性能閾値検証**: 平均応答時間100ms以下の要件確認
- **タイムアウト動作**: ReceiveTimeoutMs設定値での正確なタイムアウト動作確認

---

## 10. ApplicationController・ExecutionOrchestrator テスト設計

### 10.1 ApplicationController テスト設計
**目的**: アプリケーション全体のライフサイクル管理、Step1初期化フェーズ実行、Step2-7データ処理サイクルの継続実行制御をテスト

#### 正常系テスト
- **TC150_ApplicationController_StartAsync_正常開始**
  - 入力: CancellationToken（キャンセレーション制御）
  - 期待出力: Task（非同期実行完了状態）
  - 処理内容:
    - Step1初期化フェーズ実行（ExecuteStep1InitializationAsync()）
    - Step2-7継続実行開始（StartContinuousDataCycleAsync()）

- **TC151_ApplicationController_StopAsync_正常停止**
  - 入力: CancellationToken（停止制御）
  - 期待出力: Task（非同期停止完了状態）
  - 処理内容:
    - 実行中サイクルの適切な停止
    - 各Managerクラスのリソース解放
    - PLC接続の適切な切断

- **TC152_ApplicationController_ExecuteStep1InitializationAsync_初期化成功**
  - 入力: 設定ディレクトリパス（string型、デフォルト："./config/"）
  - 期待出力: InitializationResult（初期化結果オブジェクト）
    - LoadedConfigCount（読み込み設定ファイル数）
    - CreatedManagersCount（作成されたManagerインスタンス数）
    - InitializationTime（初期化処理時間）
    - IsSuccess=true（初期化成功フラグ）
    - ErrorDetails=null（エラー詳細：成功時はnull）
  - 処理内容:
    - 複数設定ファイル読み込み（MultiConfigManager.LoadAllFromDirectoryAsync()）
    - 各種Managerクラスインスタンス作成
    - 初期化検証・ヘルスチェック

- **TC153_ApplicationController_StartContinuousDataCycleAsync_継続実行開始**
  - 入力:
    - InitializationResult（Step1初期化結果）
    - CancellationToken（実行制御）
  - 期待出力: Task（継続実行タスク）
  - 処理内容:
    - ExecutionOrchestratorインスタンス作成
    - 複数PLC並行実行開始（Task.WhenAll使用）
    - エラー発生時の継続処理制御

#### 異常系テスト
- **TC154_ApplicationController_ExecuteStep1InitializationAsync_初期化失敗**
  - 入力: 存在しない設定ディレクトリパス
  - 期待出力: InitializationResult（失敗状態）
    - IsSuccess=false
    - ErrorDetails（失敗理由詳細）
    - LoadedConfigCount=0

- **TC155_ApplicationController_StartAsync_キャンセル処理**
  - 入力: 即座にキャンセルされるCancellationToken
  - 期待出力: OperationCanceledException
  - 処理内容: 適切なキャンセル処理とリソース解放

### 10.2 ExecutionOrchestrator テスト設計
**目的**: Step2-7データ処理サイクルの詳細実行制御、MonitoringIntervalMs間隔制御、単一PLC用実行ロジックをテスト

#### 正常系テスト
- **TC156_ExecutionOrchestrator_RunContinuousDataCycleAsync_継続実行**
  - 入力:
    - ConfigToFrameManager（PLC用設定・フレーム管理）
    - PlcIdentifier（PLC識別子：string型）
    - CancellationToken（実行制御）
  - 期待出力: Task（継続実行タスク）
  - 処理内容:
    - TimerService使用によるMonitoringIntervalMs間隔制御
    - ExecuteSingleCycleAsync()の繰り返し実行
    - エラー発生時の継続判定・ログ出力

- **TC157_ExecutionOrchestrator_ExecuteSingleCycleAsync_単一サイクル成功**
  - 入力:
    - ConfigToFrameManager（設定・フレーム管理）
    - PlcCommunicationManager（PLC通信管理）
    - DataOutputManager（データ出力管理）
    - LoggingManager（ログ管理）
  - 期待出力: CycleExecutionResult（サイクル実行結果オブジェクト）
    - IsSuccess=true（サイクル成功フラグ）
    - ExecutedSteps=["Step2", "Step3", "Step4", "Step5", "Step6", "Step7"]
    - ExecutionTime（サイクル実行時間）
    - DataCount（処理データ数）
    - ErrorDetails=null（成功時はnull）
  - 処理内容:
    - Step2: ConfigToFrameManager.SplitDwordToWord() → ConfigToFrameManager.BuildFrames()
    - Step3: PlcCommunicationManager.ConnectAsync()
    - Step4: PlcCommunicationManager.SendFrameAsync() → PlcCommunicationManager.ReceiveResponseAsync()
    - Step5: PlcCommunicationManager.DisconnectAsync()
    - Step6: PlcCommunicationManager.PostprocessReceivedData() → PlcCommunicationManager.ParseRawToStructuredData()
    - Step7: DataOutputManager.OutputDataAsync()

- **TC158_ExecutionOrchestrator_GetMonitoringInterval_間隔取得**
  - 入力: ConfigToFrameManager（設定管理）
  - 期待出力: TimeSpan（監視間隔：MonitoringIntervalMs設定値をTimeSpanに変換）
  - データ取得元: ConfigToFrameManager.GetConfig<DataProcessingConfig>()（MonitoringIntervalMs設定）

#### 異常系テスト
- **TC159_ExecutionOrchestrator_ExecuteSingleCycleAsync_Step内エラー**
  - 入力: 有効な各Managerインスタンス（Step3で通信エラー発生設定）
  - 期待出力: CycleExecutionResult（部分失敗状態）
    - IsSuccess=false
    - ExecutedSteps=["Step2"]（Step3で失敗）
    - ErrorDetails（Step3エラー詳細）

- **TC160_ExecutionOrchestrator_RunContinuousDataCycleAsync_キャンセル**
  - 入力: キャンセル済みCancellationToken
  - 期待出力: OperationCanceledException
  - 処理内容: 実行中サイクルの適切な中断

### 10.3 AndonHostedService テスト設計
**目的**: .NET HostedServiceとしてのバックグラウンド実行、ApplicationControllerのライフサイクル管理をテスト

#### 正常系テスト
- **TC161_AndonHostedService_ExecuteAsync_バックグラウンド実行**
  - 入力: CancellationToken（.NETランタイムから取得）
  - 期待出力: Task（バックグラウンド実行タスク）
  - 処理内容:
    - ApplicationController.StartAsync()実行
    - CancellationToken監視による適切な終了制御

- **TC162_AndonHostedService_StartAsync_サービス開始**
  - 入力: CancellationToken（.NETランタイムから取得）
  - 期待出力: Task（開始処理完了状態）
  - 処理内容:
    - 起動ログ出力
    - ApplicationController初期化確認

- **TC163_AndonHostedService_StopAsync_サービス停止**
  - 入力: CancellationToken（.NETランタイムから取得）
  - 期待出力: Task（停止処理完了状態）
  - 処理内容:
    - ApplicationController.StopAsync()実行
    - 停止ログ出力

### 10.4 TimerService テスト設計
**目的**: MonitoringIntervalMs間隔でのタイマー制御、精密な間隔制御をテスト

#### 正常系テスト
- **TC164_TimerService_StartPeriodicExecution_周期実行**
  - 入力:
    - Func<Task>（実行する非同期処理）
    - TimeSpan（実行間隔：1000ms）
    - CancellationToken（実行制御）
  - 期待出力: Task（周期実行タスク）
  - 処理内容:
    - System.Threading.PeriodicTimer使用
    - 指定間隔での正確な実行制御
    - 前回処理未完了時の重複実行防止

#### 異常系テスト
- **TC165_TimerService_StartPeriodicExecution_実行中例外**
  - 入力: 例外を発生させるFunc<Task>
  - 期待出力: 例外処理後の継続実行
  - 処理内容: 個別実行エラーでもタイマー継続

### 10.5 GracefulShutdownHandler テスト設計
**目的**: Ctrl+C等のシグナル処理、適切な終了処理実行、リソース解放順序制御をテスト

#### 正常系テスト
- **TC166_GracefulShutdownHandler_RegisterShutdownHandlers_ハンドラ登録**
  - 入力:
    - ApplicationController（制御対象）
    - CancellationTokenSource（キャンセレーション制御）
  - 期待出力: 登録完了状態
  - 処理内容:
    - Console.CancelKeyPress登録
    - AppDomain.ProcessExit登録
    - キャンセレーショントークン発行

- **TC167_GracefulShutdownHandler_ExecuteGracefulShutdown_適切な終了**
  - 入力:
    - ApplicationController（制御対象）
    - TimeSpan（タイムアウト時間：30秒）
  - 期待出力: ShutdownResult（終了処理結果）
    - IsGraceful=true（適切な終了処理完了フラグ）
    - ShutdownTime（終了処理にかかった時間）
    - CompletedTasks（完了した終了タスク一覧）
    - IncompleteTaskCount=0（未完了タスク数）
    - FinalResourceState（最終リソース状態）
    - ShutdownTrigger（終了契機）
  - 処理内容:
    - ApplicationController.StopAsync()実行
    - 各Managerクラスのリソース解放確認
    - タイムアウト制御

#### 異常系テスト
- **TC168_GracefulShutdownHandler_ExecuteGracefulShutdown_タイムアウト**
  - 入力: 長時間処理を含むApplicationController、短いタイムアウト時間
  - 期待出力: ShutdownResult（タイムアウト終了状態）
    - IsGraceful=false
    - IncompleteTaskCount>0
    - IncompleteTaskDetails（未完了タスク詳細一覧）

---

## 11. 非同期・並行処理アーキテクチャ テスト設計

### 11.1 AsyncExceptionHandler テスト設計
**目的**: 階層的例外ハンドリング、重要処理の個別対応、一般処理の一括処理、統一エラーログ出力をテスト

#### 正常系テスト
- **TC169_AsyncExceptionHandler_HandleCriticalOperationAsync_重要処理成功**
  - 入力:
    - Func<Task<T>>（成功する重要処理）
    - string（処理名称："PLC接続処理"）
    - CancellationToken（キャンセル制御）
  - 期待出力: AsyncOperationResult<T>（実行結果オブジェクト）
    - IsSuccess=true（実行成功フラグ）
    - Result（実行結果：成功時のみ設定）
    - Exception=null（失敗時のみ設定）
    - ExecutionTime（実行時間）
    - OperationName="PLC接続処理"（処理名称）

- **TC170_AsyncExceptionHandler_HandleGeneralOperationsAsync_一般処理一括成功**
  - 入力:
    - IEnumerable<Func<Task>>（成功する一般処理群）
    - string（処理グループ名称："ログ出力処理群"）
    - CancellationToken（キャンセル制御）
  - 期待出力: GeneralOperationResult（一括実行結果オブジェクト）
    - SuccessCount（成功処理数）
    - FailureCount=0（失敗処理数）
    - TotalExecutionTime（全体実行時間）
    - FailedOperations=[]（失敗した処理名一覧：空リスト）
    - Exceptions=[]（発生例外一覧：空リスト）

#### 異常系テスト
- **TC171_AsyncExceptionHandler_HandleCriticalOperationAsync_重要処理失敗**
  - 入力: 例外を発生するFunc<Task<T>>
  - 期待出力: AsyncOperationResult<T>（失敗状態）
    - IsSuccess=false
    - Result=null
    - Exception（発生例外）
    - ExecutionTime（実行時間）

- **TC172_AsyncExceptionHandler_HandleGeneralOperationsAsync_部分失敗**
  - 入力: 成功処理と失敗処理が混在するIEnumerable<Func<Task>>
  - 期待出力: GeneralOperationResult（部分失敗状態）
    - SuccessCount>0, FailureCount>0
    - FailedOperations（失敗処理名一覧）
    - Exceptions（発生例外一覧）

### 11.2 CancellationCoordinator テスト設計
**目的**: CancellationToken階層管理、適切なキャンセル伝達、グレースフル停止制御をテスト

#### 正常系テスト
- **TC173_CancellationCoordinator_CreateHierarchicalToken_階層トークン作成**
  - 入力:
    - CancellationToken（親トークン）
    - TimeSpan（タイムアウト時間：5秒）
  - 期待出力: CancellationTokenSource（子トークンソース）
  - 処理内容:
    - 親トークンとタイムアウトの組み合わせ
    - 階層的キャンセル制御

- **TC174_CancellationCoordinator_RegisterCancellationCallback_コールバック登録**
  - 入力:
    - CancellationToken（対象トークン）
    - Func<Task>（キャンセル時実行処理）
    - string（コールバック名称："リソース解放"）
  - 期待出力: CancellationTokenRegistration（登録ハンドル）
  - 処理内容:
    - キャンセル時の適切な清掃処理登録
    - 非同期コールバック対応

### 11.3 ResourceSemaphoreManager テスト設計
**目的**: 共有リソースの排他制御、ログファイル・設定ファイル競合回避、パフォーマンス最適化をテスト

#### 正常系テスト
- **TC175_ResourceSemaphoreManager_ExecuteWithSemaphoreAsync_セマフォ制御実行**
  - 入力:
    - SemaphoreSlim（LogFileSemaphore：同時アクセス数1）
    - Func<Task<T>>（実行対象処理）
    - CancellationToken（キャンセル制御）
    - TimeSpan（セマフォ取得タイムアウト：30秒）
  - 期待出力: T（実行結果）
  - 処理内容:
    - セマフォ取得→処理実行→セマフォ解放の確実実行
    - タイムアウト制御
    - 例外発生時の確実なセマフォ解放

- **TC176_ResourceSemaphoreManager_GetResourceSemaphore_リソース種別セマフォ取得**
  - 入力: ResourceType（LogFile, ConfigFile, OutputFile）
  - 期待出力: SemaphoreSlim（対応するセマフォ）
  - 検証項目:
    - LogFileSemaphore：同時アクセス数1
    - ConfigFileSemaphore：同時アクセス数3
    - OutputFileSemaphore：同時アクセス数2

### 11.4 ProgressReporter テスト設計
**目的**: IProgress<T>実装、リアルタイム進捗報告、UI・コンソール出力対応をテスト

#### 正常系テスト
- **TC177_ProgressReporter_Report_進捗報告**
  - 入力: ProgressInfo（現在ステップ、進捗率、メッセージ）
  - 期待出力: void（進捗情報の出力・通知）
  - 処理内容:
    - コンソール出力（リアルタイム表示）
    - ログファイル記録
    - 進捗率計算・表示

- **TC178_ProgressReporter_CreateStepProgress_ステップ別進捗作成**
  - 入力:
    - string（ステップ名："Step3"）
    - int（予想処理数：100）
  - 期待出力: ProgressReporter<ProgressInfo>（ステップ専用進捗レポーター）

### 11.5 ParallelExecutionController テスト設計
**目的**: 複数PLC並行実行制御、Task.WhenAll活用、エラー発生時継続制御をテスト

#### 正常系テスト
- **TC179_ParallelExecutionController_ExecuteParallelPlcOperationsAsync_並行実行成功**
  - 入力:
    - IEnumerable<ConfigToFrameManager>（PLC用設定管理インスタンス群）
    - Func<ConfigToFrameManager, CancellationToken, Task<CycleExecutionResult>>（実行処理）
    - CancellationToken（実行制御）
  - 期待出力: ParallelExecutionResult（並行実行結果オブジェクト）
    - TotalPlcCount（対象PLC総数）
    - SuccessfulPlcCount（成功PLC数）
    - FailedPlcCount=0（失敗PLC数）
    - PlcResults（PLC別実行結果）
    - OverallExecutionTime（全体実行時間）
    - ContinuingPlcIds（継続実行中PLC ID一覧）

- **TC180_ParallelExecutionController_MonitorParallelExecution_並行実行監視**
  - 入力:
    - IEnumerable<Task<CycleExecutionResult>>（実行中タスク群）
    - IProgress<ParallelProgressInfo>（進捗レポーター）
    - CancellationToken（監視制御）
  - 期待出力: Task（監視タスク）
  - 処理内容:
    - 実行中タスクの状態監視
    - 完了・エラー・継続状況のリアルタイム報告
    - 全体進捗率計算・表示

#### 異常系テスト
- **TC181_ParallelExecutionController_ExecuteParallelPlcOperationsAsync_部分失敗**
  - 入力: 一部PLC処理が失敗するシナリオ
  - 期待出力: ParallelExecutionResult（部分失敗状態）
    - SuccessfulPlcCount>0, FailedPlcCount>0
    - エラー発生PLC以外の継続実行制御

---

## 12. DI（依存性注入）コンテナ設計 テスト設計

### 12.1 DependencyInjectionConfigurator テスト設計
**目的**: DIコンテナ設定、サービス登録、ライフタイム管理、インターフェースマッピングをテスト

#### 正常系テスト
- **TC182_DependencyInjectionConfigurator_ConfigureServices_サービス登録**
  - 入力:
    - IServiceCollection（DIコンテナ）
    - IConfiguration（設定情報：appsettings.json、環境変数）
  - 期待出力: IServiceCollection（設定完了済みDIコンテナ）
  - 処理内容:
    - 全主要クラスのインターフェース登録
    - ライフタイム設定（Singleton/Transient）
    - Optionsパターン設定値注入
    - HostedService登録

- **TC183_DependencyInjectionConfigurator_RegisterCoreServices_コアサービス登録**
  - 入力: IServiceCollection（DIコンテナ）
  - 期待出力: IServiceCollection（コア登録完了済み）
  - 検証項目:
    - ApplicationController → IApplicationController（Singleton）
    - ExecutionOrchestrator → IExecutionOrchestrator（Transient：PLC別インスタンス）
    - ConfigToFrameManager → IConfigToFrameManager（Transient：設定ファイル別）
    - PlcCommunicationManager → IPlcCommunicationManager（Transient：PLC別）
    - DataOutputManager → IDataOutputManager（Singleton：共有リソース）

- **TC184_DependencyInjectionConfigurator_RegisterInfrastructureServices_インフラサービス登録**
  - 入力: IServiceCollection（DIコンテナ）
  - 期待出力: IServiceCollection（インフラ登録完了済み）
  - 検証項目:
    - LoggingManager → ILoggingManager（Singleton：ログ集約）
    - ErrorHandler → IErrorHandler（Singleton：エラー統計）
    - ResourceManager → IResourceManager（Singleton：システム監視）
    - AsyncExceptionHandler → IAsyncExceptionHandler（Singleton：例外処理統一）
    - ResourceSemaphoreManager → IResourceSemaphoreManager（Singleton：共有リソース制御）

- **TC185_DependencyInjectionConfigurator_RegisterAsyncServices_非同期処理サービス登録**
  - 入力: IServiceCollection（DIコンテナ）
  - 期待出力: IServiceCollection（非同期登録完了済み）
  - 検証項目:
    - CancellationCoordinator → ICancellationCoordinator（Singleton：キャンセル制御統一）
    - ParallelExecutionController → IParallelExecutionController（Singleton：並行実行制御）
    - ProgressReporter<T> → IProgressReporter<T>（Transient：進捗報告個別）
    - TimerService → ITimerService（Transient：タイマー個別）

- **TC186_DependencyInjectionConfigurator_RegisterHostedServices_HostedService登録**
  - 入力: IServiceCollection（DIコンテナ）
  - 期待出力: IServiceCollection（HostedService登録完了済み）
  - 検証項目:
    - AndonHostedService登録（IHostedService）
    - GracefulShutdownHandler登録（バックグラウンドサービス）

### 12.2 OptionsConfigurator テスト設計
**目的**: Optionsパターン設定値注入、型安全設定管理、バリデーション設定をテスト

#### 正常系テスト
- **TC187_OptionsConfigurator_ConfigureOptions_Options設定注入**
  - 入力:
    - IServiceCollection（DIコンテナ）
    - IConfiguration（設定情報：appsettings.json等）
  - 期待出力: IServiceCollection（Options設定完了済み）
  - 処理内容:
    - IOptions<ConnectionConfig>注入設定
    - IOptions<TimeoutConfig>注入設定
    - IOptions<SystemResourcesConfig>注入設定
    - IOptions<LoggingConfig>注入設定
    - バリデーション設定（DataAnnotations）

- **TC188_OptionsConfigurator_ValidateOptions_設定値バリデーション**
  - 入力: IServiceCollection（DIコンテナ）
  - 期待出力: IServiceCollection（バリデーション設定完了済み）
  - 処理内容:
    - 必須項目チェック設定
    - 範囲値チェック設定
    - 形式チェック設定（IPアドレス、ポート番号等）

### 12.3 ServiceLifetimeManager テスト設計
**目的**: サービスライフタイム最適化、メモリ効率管理、パフォーマンス最適化をテスト

#### 正常系テスト
- **TC189_ServiceLifetimeManager_DetermineLifetime_ライフタイム判定**
  - 入力:
    - Type（対象クラス型）
    - ServiceRole（サービス役割：Core, Infrastructure, Async）
  - 期待出力: ServiceLifetime（Singleton, Scoped, Transient）
  - 処理内容:
    - Singleton判定条件：共有リソース、統計管理、システム監視クラス
    - Transient判定条件：PLC別、設定ファイル別、進捗報告クラス
    - パフォーマンス・メモリ効率考慮

- **TC190_ServiceLifetimeManager_ValidateLifetimeConsistency_ライフタイム整合性検証**
  - 入力: IServiceCollection（DIコンテナ）
  - 期待出力: ValidationResult（整合性検証結果）
  - 処理内容:
    - 依存関係ライフタイム検証
    - Singleton→Transient依存の警告
    - 循環依存チェック

### 12.4 MultiConfigDIIntegration テスト設計
**目的**: 複数設定ファイルとDIコンテナ統合、軽量インスタンス注入、設定別サービス解決をテスト

#### 正常系テスト
- **TC191_MultiConfigDIIntegration_RegisterMultiConfigServices_複数設定対応サービス登録**
  - 入力:
    - IServiceCollection（DIコンテナ）
    - MultiConfigManager（複数設定管理：事前初期化済み）
  - 期待出力: IServiceCollection（複数設定対応完了済み）
  - 処理内容:
    - 設定ファイル別ConfigToFrameManagerファクトリ登録
    - PLC別PlcCommunicationManagerファクトリ登録
    - 軽量インスタンス生成器登録

- **TC192_MultiConfigDIIntegration_CreateConfigSpecificProvider_設定別サービスプロバイダ作成**
  - 入力:
    - IServiceProvider（メインプロバイダ）
    - string（設定ファイル名："PLC1_settings.xlsx"）
  - 期待出力: IServiceProvider（設定専用プロバイダ）
  - 処理内容:
    - 設定ファイル専用スコープ作成
    - 該当設定値の注入
    - 軽量インスタンス解決

---

## 13. Program.cs・エントリーポイント設計 テスト設計

### 13.1 Program テスト設計
**目的**: アプリケーション起動制御、Host・DIコンテナ初期化、コマンドライン引数処理、設定ファイル初期読み込み、HostedService起動をテスト

#### 正常系テスト
- **TC193_Program_Main_正常起動終了**
  - 入力: string[] args（有効なコマンドライン引数）
  - 期待出力: int（終了コード：0=正常終了）
  - 処理内容:
    - コマンドライン引数解析
    - CreateHostBuilder()実行
    - Host.RunAsync()実行
    - 最上位例外処理

- **TC194_Program_CreateHostBuilder_Host構築**
  - 入力: string[] args（コマンドライン引数）
  - 期待出力: IHostBuilder（構築済みHostBuilder）
  - 処理内容:
    - Generic Host初期化
    - ConfigureServices()実行
    - ConfigureConfiguration()実行
    - ConfigureLogging()実行

- **TC195_Program_ConfigureServices_サービス設定**
  - 入力:
    - HostBuilderContext（Hostコンテキスト）
    - IServiceCollection（DIコンテナ）
  - 期待出力: void（サービス登録完了）
  - 処理内容:
    - DependencyInjectionConfigurator.ConfigureServices()実行
    - OptionsConfigurator.ConfigureOptions()実行
    - AndonHostedService登録

- **TC196_Program_ConfigureConfiguration_設定統合**
  - 入力:
    - HostBuilderContext（Hostコンテキスト）
    - IConfigurationBuilder（設定ビルダー）
  - 期待出力: void（設定読み込み完了）
  - 処理内容:
    - appsettings.json読み込み
    - 環境変数読み込み
    - コマンドライン引数読み込み
    - 設定優先順位設定（コマンドライン > 環境変数 > appsettings.json）

- **TC197_Program_ConfigureLogging_ログ設定**
  - 入力:
    - HostBuilderContext（Hostコンテキスト）
    - ILoggingBuilder（ログビルダー）
  - 期待出力: void（ログ設定完了）
  - 処理内容:
    - コンソールログ設定
    - ファイルログ設定
    - ログレベル設定
    - ログフォーマット設定

#### 異常系テスト
- **TC198_Program_Main_一般エラー終了**
  - 入力: 例外を発生する設定
  - 期待出力: int（終了コード：1=一般エラー）
  - 処理内容: 最上位例外キャッチと適切な終了コード返却

- **TC199_Program_Main_設定エラー終了**
  - 入力: 不正な設定ファイル
  - 期待出力: int（終了コード：2=設定エラー）

- **TC200_Program_Main_権限エラー終了**
  - 入力: 権限不足状態
  - 期待出力: int（終了コード：3=権限エラー）

### 13.2 CommandLineOptions テスト設計
**目的**: コマンドライン引数解析、起動オプション管理、バリデーション実行をテスト

#### 正常系テスト
- **TC201_CommandLineOptions_Parse_引数解析成功**
  - 入力: string[] args（"--config-dir ./config --log-level Debug --console"）
  - 期待出力: CommandLineOptions（解析済みオプション）
    - ConfigDirectory="./config"
    - LogLevel="Debug"
    - ConsoleOutput=true
    - ShowVersion=false
    - ShowHelp=false
    - DryRun=false

- **TC202_CommandLineOptions_Parse_バージョン表示**
  - 入力: string[] args（"--version"）
  - 期待出力: CommandLineOptions（ShowVersion=true）

- **TC203_CommandLineOptions_Parse_ヘルプ表示**
  - 入力: string[] args（"--help"）
  - 期待出力: CommandLineOptions（ShowHelp=true）

- **TC204_CommandLineOptions_Parse_ドライ実行**
  - 入力: string[] args（"--dry-run"）
  - 期待出力: CommandLineOptions（DryRun=true）

- **TC205_CommandLineOptions_Validate_オプションバリデーション成功**
  - 入力: 有効なCommandLineOptions
  - 期待出力: ValidationResult（IsValid=true）
  - 処理内容:
    - 設定ディレクトリ存在チェック
    - ログレベル形式チェック
    - オプション組み合わせチェック

#### 異常系テスト
- **TC206_CommandLineOptions_Parse_不正引数**
  - 入力: string[] args（"--invalid-option"）
  - 期待出力: ArgumentException

- **TC207_CommandLineOptions_Validate_設定ディレクトリ不存在**
  - 入力: 存在しないディレクトリを含むCommandLineOptions
  - 期待出力: ValidationResult（IsValid=false、エラー詳細）

### 13.3 ExitCodeManager テスト設計
**目的**: 終了コード管理、エラー分類、統一的な終了処理をテスト

#### 正常系テスト
- **TC208_ExitCodeManager_DetermineExitCode_終了コード判定**
  - 入力: Exception（各種例外タイプ）
  - 期待出力: ExitCode（適切な終了コード）
  - 検証項目:
    - FileNotFoundException → ConfigurationError（2）
    - SocketException → NetworkError（4）
    - UnauthorizedAccessException → PermissionError（3）
    - IOException → FileSystemError（5）
    - 一般Exception → GeneralError（1）

- **TC209_ExitCodeManager_LogExitInformation_終了情報ログ出力**
  - 入力:
    - ExitCode（終了コード）
    - Exception（例外：null許容）
    - TimeSpan（実行時間）
  - 期待出力: Task（ログ出力完了）
  - 処理内容:
    - 終了コード・理由ログ出力
    - 実行時間・統計ログ出力
    - エラー詳細ログ出力（エラー時のみ）

---

## 12. モック・スタブ実装方針

### 12.1 テストデータ管理
- **設定ファイル**: テスト用appsettings.xlsx（正常系・異常系各種）
- **SLMPフレームサンプル**: 三菱電機公式仕様書準拠の実例データ
- **応答データ**: PLCシミュレータ用の既知応答パターン

### 12.2 モック・スタブライブラリ
- **Moq**: インターフェースベースモック作成
- **カスタムスタブ**: 複雑なシナリオ用の専用スタブクラス
- **テストデータビルダー**: テストケース別データ生成

### 12.3 検証戦略
- **状態検証**: モック・スタブの内部状態確認
- **相互作用検証**: メソッド呼び出し順序・パラメータ確認
- **出力検証**: 期待値との完全一致確認