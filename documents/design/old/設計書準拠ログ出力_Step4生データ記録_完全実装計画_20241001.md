# 設計書準拠ログ出力とStep4生データ記録完全実装計画

## 作成日時
- **作成日**: 2024年10月1日
- **対象システム**: Andon SLMP Client - Comprehensive Device Discovery System
- **バージョン**: 2.0.0-comprehensive

## 📋 実装目標

### 主要目標
1. **設計書記載の全7エントリータイプ**をターミナル・ログファイルに完全出力
2. **Step4網羅的スキャン時の受信生データ（SLMPフレーム）**を16進数で完全記録
3. **rawResponseDataが常にnullの根本問題**を解決し、実際のバイナリデータを取得

### 参照設計書
- `C:\Users\1010821\Desktop\python\andon\documents\design\ログ出力設計\Complete_Unified_Logging_System_Design.md`
- `C:\Users\1010821\Desktop\python\andon\documents\design\ログ出力設計\PLC_Connection_Diagnostic_Integration_Plan.md`
- `C:\Users\1010821\Desktop\python\andon\documents\design\データ取得動作流れ\動作イメージ.md`

## 🔍 現状問題の詳細分析

### 核心的問題1: SLMPフレーム生データ取得の完全停止
**問題詳細:**
- **ファイル**: `SlmpClientWithTestLogging.cs`
- **行番号**: 89, 142
- **問題コード**: `byte[]? rawData = null;`
- **影響**: 実際のSLMP通信バイナリフレームが全く取得されていない

**関連する問題:**
- `SlmpRawDataAnalyzer` が機能せず、16進数ダンプ・フレーム解析が無効
- 設計書で最重要視されているSLMPフレーム生バイナリデータが記録されない
- デバッグ・トラブルシューティング時に通信内容が不明

### 核心的問題2: 統合ログシステムの未活用
**問題詳細:**
- **実装済み**: `UnifiedLogWriter.cs` (6/7エントリタイプ実装済み)
- **未使用**: `IntelligentMonitoringSystem.cs` で全く使用されていない
- **欠落**: Step4の各デバイスアクセス時の詳細情報が記録されていない

**影響:**
- 現在は `_logger.LogInformation` による簡素なログのみ
- 設計書要求の構造化ログが出力されていない
- トレーサビリティとセッション管理機能が活用されていない

### 核心的問題3: Step4応答情報の記録不備
**問題詳細:**
- 各デバイス通信での受信生データ・応答時間・エラー詳細が未記録
- 設計書要求の詳細フレーム解析情報が欠落
- CYCLE_COMMUNICATIONエントリでの完全な情報が提供されていない

## 📊 設計書要求事項との詳細ギャップ分析

### 要求されるエントリータイプと実装状況

| エントリータイプ | 実装状況 | 使用状況 | 問題 |
|------------------|----------|----------|------|
| SESSION_START | ✅ 実装済み | ❌ 未使用 | IntelligentMonitoringSystemで未使用 |
| CYCLE_START | ✅ 実装済み | ❌ 未使用 | Step4開始時に未出力 |
| CYCLE_COMMUNICATION | ✅ 実装済み | ❌ 未使用 | rawDataが常にnull |
| ERROR_OCCURRED | ✅ 実装済み | ❌ 未使用 | エラー時の詳細記録なし |
| STATISTICS | ✅ 実装済み | ❌ 未使用 | セッション統計が記録されない |
| SESSION_END | ✅ 実装済み | ❌ 未使用 | セッション終了時に未出力 |
| PERFORMANCE_METRICS | ❌ **未実装** | ❌ 未使用 | 完全に欠落 |

### 設計書で要求される情報カテゴリーと実装状況

| 情報カテゴリー | 実装率 | 問題詳細 |
|----------------|--------|----------|
| SLMPフレーム生バイナリデータ | 0% | rawData常にnull、16進数記録なし |
| 詳細SLMPフレーム解析 | 100% | 実装済みだが生データ未取得で動作せず |
| アプリケーション状態情報 | 80% | セッション管理・設定情報は実装済み |
| 統計・パフォーマンス情報 | 90% | PerformanceMonitor実装済み、統合ログ未使用 |
| エラー・例外情報詳細 | 70% | 基本機能あり、統合ログでの詳細記録なし |
| 時系列・関連情報 | 60% | SessionId・CycleNumber機能あり、未活用 |

## 🎯 詳細実装プラン

### メインタスク1: SLMPフレーム生データ取得機能の完全修復

#### サブタスク1.1: SlmpClient.csでの実rawData取得実装
**対象ファイル**: `C:\Users\1010821\Desktop\python\andon\andon\Core\SlmpClient.cs`

**実装内容:**
1. **送信フレーム記録プロパティ追加**
   ```csharp
   public byte[]? LastSentFrame { get; private set; }
   public byte[]? LastReceivedFrame { get; private set; }
   ```

2. **通信メソッド修正** (各通信メソッドで実装)
   - `ReadBitDevicesAsync`
   - `ReadWordDevicesAsync`
   - `ReadTypeNameAsync`

   **修正例**:
   ```csharp
   // 送信フレーム記録
   LastSentFrame = frameData.ToArray();

   // 通信実行
   var response = await SendAndReceiveAsync(frameData, timeout, cancellationToken);

   // 受信フレーム記録
   LastReceivedFrame = response.ToArray();
   ```

#### サブタスク1.2: SlmpClientWithTestLoggingのrawData渡し修正
**対象ファイル**: `C:\Users\1010821\Desktop\python\andon\andon\Core\SlmpClientWithTestLogging.cs`

**修正対象行**:
- **行89**: `byte[]? rawData = null;` → 実際のrawData取得
- **行142**: `byte[]? rawData = null;` → 実際のrawData取得

**修正内容**:
```csharp
// 修正前
byte[]? rawData = null;

// 修正後
byte[]? rawData = _innerClient.LastReceivedFrame;
```

#### サブタスク1.3: SlmpRawDataAnalyzerの動作検証
**対象ファイル**: `C:\Users\1010821\Desktop\python\andon\andon\Core\SlmpRawDataAnalyzer.cs`

**検証項目**:
1. 実rawDataでの16進数ダンプ生成確認
2. FrameAnalysis機能の動作確認
3. HexDump出力フォーマット確認

### メインタスク2: 統合ログシステムとStep4処理の完全連携

#### サブタスク2.1: IntelligentMonitoringSystemでのUnifiedLogWriter統合
**対象ファイル**: `C:\Users\1010821\Desktop\python\andon\andon\Core\IntelligentMonitoringSystem.cs`

**実装箇所**:
1. **コンストラクタ修正** (UnifiedLogWriter依存性注入)
2. **RunSixStepFlowAsync メソッド修正** (SESSION_START/END追加)
3. **Step4_ComprehensiveScanAllDevices メソッド修正** (CYCLE_START追加)

**実装例**:
```csharp
// セッション開始記録
await _unifiedLogWriter.WriteSessionStartAsync(sessionInfo, configDetails);

// Step4開始記録
await _unifiedLogWriter.WriteCycleStartAsync(new CycleStartInfo
{
    SessionId = sessionId,
    CycleNumber = 4,
    StartMessage = "Step 4実行: 全デバイスコード＋一般的機器番号で網羅的スキャン",
    IntervalFromPrevious = 0
});
```

#### サブタスク2.2: DeviceScannerでの詳細応答情報記録
**対象ファイル**: `C:\Users\1010821\Desktop\python\andon\andon\Core\DeviceScanner.cs`

**修正メソッド**:
- `ScanBitDeviceRangeAsync`
- `ScanWordDeviceRangeAsync`

**実装内容**:
各デバイス通信でCYCLE_COMMUNICATIONエントリ出力
```csharp
// 通信詳細記録
await _unifiedLogWriter.WriteCommunicationAsync(communicationInfo, rawDataAnalysis);
```

#### サブタスク2.3: エラー処理時のERROR_OCCURREDエントリ出力
**実装内容**:
タイムアウト・通信エラー時の詳細情報記録
```csharp
await _unifiedLogWriter.WriteErrorAsync(errorInfo, recoveryInfo);
```

### メインタスク3: PERFORMANCE_METRICSエントリタイプの実装

#### サブタスク3.1: UnifiedLogWriterへのPERFORMANCE_METRICS追加
**対象ファイル**: `C:\Users\1010821\Desktop\python\andon\andon\Core\UnifiedLogWriter.cs`

**追加メソッド**:
```csharp
/// <summary>
/// パフォーマンスメトリクスエントリを出力
/// </summary>
public async Task WritePerformanceMetricsAsync(PerformanceMetricsInfo metricsInfo)
{
    var entry = new
    {
        EntryType = "PERFORMANCE_METRICS",
        Timestamp = DateTime.Now,
        SessionId = metricsInfo.SessionId,
        PerformanceData = new
        {
            NetworkQuality = metricsInfo.NetworkQuality,
            SlmpPerformance = metricsInfo.SlmpPerformance,
            SystemResource = metricsInfo.SystemResource
        }
    };

    await WriteLogEntryAsync(entry);
}
```

**データモデル追加**:
```csharp
public class PerformanceMetricsInfo
{
    public string SessionId { get; set; } = string.Empty;
    public NetworkQualityData NetworkQuality { get; set; } = new();
    public SlmpPerformanceData SlmpPerformance { get; set; } = new();
    public SystemResourceData SystemResource { get; set; } = new();
}
```

#### サブタスク3.2: PerformanceMonitorとの統合
**実装内容**:
定期的なPERFORMANCE_METRICSエントリ出力機能

### メインタスク4: ターミナル出力とログファイル出力の完全統合

#### サブタスク4.1: 統合出力管理クラスの作成
**新規ファイル**: `C:\Users\1010821\Desktop\python\andon\andon\Core\IntegratedOutputManager.cs`

**機能**:
- ターミナルとファイルへの同期出力
- JSONログのターミナル用整形表示
- エントリタイプ別の表示制御

#### サブタスク4.2: 各エントリタイプのターミナル表示設計
**実装内容**:
- 構造化JSONの人間可読形式変換
- Step4での各デバイスアクセス結果の視覚的表示

#### サブタスク4.3: IntelligentMonitoringSystemでの統合出力適用
**実装内容**:
- 全Step処理での統合出力利用
- リアルタイム進捗とファイル記録の同期

### メインタスク5: 設定ファイルとJSON出力制御の完全対応

#### サブタスク5.1: appsettings.jsonへのDiagnosticSettings追加
**対象ファイル**: `C:\Users\1010821\Desktop\python\andon\andon\appsettings.json`

**追加セクション**:
```json
{
  "DiagnosticSettings": {
    "EnableDetailedDiagnostic": true,
    "DiagnosticLevel": "Verbose",
    "ShowNetworkStats": true,
    "ShowDeviceDetails": true,
    "StatisticsInterval": 10,
    "EnableErrorAnalysis": true
  }
}
```

#### サブタスク5.2: JSON出力の完全無効化
**追加設定**:
```json
{
  "UnifiedLoggingSettings": {
    "EnableJsonExport": false,
    "LogFilePath": "logs/rawdata_analysis.log"
  }
}
```

#### サブタスク5.3: 統合ログファイルパス設定の確認・調整
**設定確認**:
- 単一ログファイル: `rawdata_analysis.log`
- 重複JSON出力の停止確認

## 🔄 実装順序と依存関係

### Phase 1: 基礎修復 (優先度: 最高)
1. **SlmpClient.cs**: rawData取得機能追加
2. **SlmpClientWithTestLogging.cs**: rawData null修正
3. **動作検証**: 実rawDataが取得されることを確認

### Phase 2: 統合ログ連携 (優先度: 高)
1. **UnifiedLogWriter.cs**: PERFORMANCE_METRICS追加
2. **IntelligentMonitoringSystem.cs**: UnifiedLogWriter統合
3. **DeviceScanner.cs**: 詳細記録機能追加

### Phase 3: 統合出力システム (優先度: 中)
1. **IntegratedOutputManager.cs**: 新規作成
2. **ターミナル表示機能**: 実装・統合
3. **設定ファイル**: 完全対応

## 🧪 テスト・検証方法

### 検証項目1: SLMPフレーム生データ取得
**テスト手順**:
1. `run_rawdata_logging.bat` 実行
2. Step4実行中のログ確認
3. `rawdata_analysis.log` でrawDataが16進数で記録されることを確認

**期待される結果**:
```json
{
  "EntryType": "CYCLE_COMMUNICATION",
  "RawDataAnalysis": {
    "RequestFrameHex": "5400000000FF03000C001400010400000000010001000064000000",
    "ResponseFrameHex": "D4000000000300020000000000000000",
    "HexDump": "00000000: D4 00 00 00 00 03 00 02  00 00 00 00 00 00 00 00 |................|"
  }
}
```

### 検証項目2: 全エントリータイプ出力
**テスト手順**:
1. 6ステップフロー完全実行
2. `rawdata_analysis.log` で全7エントリータイプが出力されることを確認

**期待されるエントリータイプ**:
- SESSION_START
- CYCLE_START
- CYCLE_COMMUNICATION
- ERROR_OCCURRED (エラー時)
- STATISTICS
- PERFORMANCE_METRICS
- SESSION_END

### 検証項目3: ターミナル・ファイル同期出力
**テスト手順**:
1. リアルタイムでターミナル出力確認
2. 同内容がログファイルに記録されることを確認

## 📊 期待される結果の具体例

### Step4実行時のターミナル出力例
```
=== Step 4実行: 全デバイスコード＋一般的機器番号で網羅的スキャン ===
📡 M100-M107 スキャン中...
  - 送信フレーム: 540000000...
  - 受信フレーム: D400000000...
  - 応答時間: 2.3ms
  - 結果: M102=ON, M105=ON (2個アクティブ)

📡 D200-D207 スキャン中...
  - 送信フレーム: 540000000...
  - 受信フレーム: D400000000...
  - 応答時間: 1.8ms
  - 結果: D205=1234 (1個アクティブ)
```

### rawdata_analysis.log出力例
```json
{
  "EntryType": "CYCLE_COMMUNICATION",
  "Timestamp": "2024-10-01T16:30:45.123+09:00",
  "SessionId": "session_20241001_163045",
  "CycleNumber": 4,
  "PhaseInfo": {
    "Phase": "BitDeviceRead",
    "StatusMessage": "M100-M107 スキャン中...",
    "DeviceAddress": "M100"
  },
  "CommunicationDetails": {
    "OperationType": "BitDeviceRead",
    "DeviceCode": "M",
    "DeviceNumber": 100,
    "DeviceAddress": "M100",
    "Values": [false, false, true, false, false, true, false, false],
    "ResponseTimeMs": 2.3,
    "Success": true
  },
  "RawDataAnalysis": {
    "RequestFrameHex": "5400000000FF03000C001400010400000000010001000064000000",
    "ResponseFrameHex": "D4000000000300020000000000000014",
    "HexDump": "00000000: D4 00 00 00 00 03 00 02  00 00 00 00 00 00 00 14 |................|\n",
    "FrameAnalysis": {
      "SubHeader": "0x00D4",
      "SubHeaderDescription": "4Eフレーム",
      "NetworkNumber": 0,
      "PcNumber": 3,
      "UnitIONumber": "0x0002",
      "UnitStationNumber": 0,
      "ResponseDataLength": 2,
      "EndCode": "0x0000",
      "EndCodeDescription": "正常終了",
      "DataSection": "0000000000000014"
    }
  }
}
```

## ✅ 実装後の動作確認チェックリスト

### 必須確認項目
- [ ] rawResponseDataがnullでなく実際のバイナリデータが取得される
- [ ] Step4実行時に各デバイスアクセスでCYCLE_COMMUNICATIONエントリが出力される
- [ ] 送信・受信フレームが16進数で完全記録される
- [ ] 全7エントリータイプが適切なタイミングで出力される
- [ ] ターミナルとログファイルに同期した内容が出力される
- [ ] エラー時にERROR_OCCURREDエントリが出力される
- [ ] セッション開始・終了が正しく記録される

### パフォーマンス確認項目
- [ ] 大量デバイススキャン時のログ出力性能
- [ ] ファイルサイズ制限・ローテーション機能
- [ ] メモリ使用量への影響確認

## 📝 実装完了後の注意事項

### 運用時の注意点
1. **ログファイルサイズ管理**: 大量のバイナリデータ記録により急速にファイルサイズが増大
2. **パフォーマンス影響**: 詳細ログ出力による処理速度への影響を監視
3. **ディスク容量管理**: 継続監視時のログ蓄積に注意

### 今後の拡張予定
1. **ログレベル制御**: 詳細度の動的調整機能
2. **分析機能**: ログデータの自動分析・レポート機能
3. **アラート機能**: 異常パターン検出・通知機能

## 🔍 個別デバイス値確認機能要件

### 追加日時
- **追加日**: 2025年10月1日
- **要件名**: Step4個別デバイス値確認機能
- **目的**: 網羅的スキャン時の各デバイス値を個別に確認可能にする

### 📋 機能要件概要

#### 現在の制限事項
- **`DeviceScanResult`**: アクティブなアドレスのみ記録、具体的な値は破棄
- **ビットデバイス（M, X, Y等）**: `true`のデバイスアドレスのみ、値(`true/false`)は未保存
- **ワードデバイス（D, W等）**: 非ゼロのデバイスアドレスのみ、具体的な値(`1234, 567`等)は未保存

#### 要求される機能
1. **全デバイス値の保存**: バッチ読み取り結果の全値をアドレスと紐付けて保存
2. **個別値確認**: `M102=true, M105=true, D205=1234, D200=0` といった具体的な値確認
3. **ターミナル表示**: リアルタイムでの個別デバイス値表示
4. **ログ記録**: 構造化ログファイルへの詳細値情報出力

### 🎯 実装仕様

#### データモデル拡張
**新規クラス: `DeviceValueInfo`**
```csharp
public class DeviceValueInfo
{
    public uint Address { get; set; }              // デバイスアドレス（100, 101等）
    public object Value { get; set; }              // 実際の値（bool または ushort/uint）
    public DeviceCode DeviceCode { get; set; }     // デバイス種類（M, D等）
    public string DeviceName { get; set; }         // 表示名（"M105", "D250"等）
    public DateTime ReadAt { get; set; }           // 読み取り時刻
}
```

**既存クラス拡張: `DeviceScanResult`**
```csharp
// 新規プロパティ追加
public List<DeviceValueInfo> DeviceValues { get; set; } = new();
```

#### SLMPバッチ読み取り対応
- **ビットデバイス**: `bool[]`配列の各要素を対応するアドレスと紐付け
- **ワードデバイス**: `ushort[]`配列の各要素を対応するアドレスと紐付け
- **効率性維持**: 既存のバッチ読み取り性能を維持しつつ値を保存

### 📊 期待される出力例

#### ターミナル出力
```
📡 M100-M107 スキャン結果:
  ⭕ M100 = false (OFF)
  ⭕ M101 = false (OFF)
  ✅ M102 = true (ON状態) ← アクティブ
  ⭕ M103 = false (OFF)
  ⭕ M104 = false (OFF)
  ✅ M105 = true (ON状態) ← アクティブ
  ⭕ M106 = false (OFF)
  ⭕ M107 = false (OFF)
  📊 バッチ読み取り: 1回の通信で8個取得
  📊 アクティブ: 2個 / 8個スキャン

📡 D200-D207 スキャン結果:
  ⭕ D200 = 0
  ⭕ D201 = 0
  ⭕ D202 = 0
  ⭕ D203 = 0
  ⭕ D204 = 0
  ✅ D205 = 1234 ← アクティブ
  ⭕ D206 = 0
  ⭕ D207 = 0
  📊 バッチ読み取り: 1回の通信で8個取得
  📊 アクティブ: 1個 / 8個スキャン
```

#### ログファイル出力 (`logs/rawdata_analysis.log`)
```json
{
  "EntryType": "CYCLE_COMMUNICATION",
  "Timestamp": "2025-10-01T16:30:45.123+09:00",
  "CommunicationDetails": {
    "OperationType": "BitDeviceRead",
    "DeviceCode": "M",
    "StartAddress": 100,
    "ReadCount": 8,
    "DeviceValues": [
      {"Address": 100, "DeviceName": "M100", "Value": false},
      {"Address": 101, "DeviceName": "M101", "Value": false},
      {"Address": 102, "DeviceName": "M102", "Value": true},
      {"Address": 103, "DeviceName": "M103", "Value": false},
      {"Address": 104, "DeviceName": "M104", "Value": false},
      {"Address": 105, "DeviceName": "M105", "Value": true},
      {"Address": 106, "DeviceName": "M106", "Value": false},
      {"Address": 107, "DeviceName": "M107", "Value": false}
    ],
    "ActiveDevices": [102, 105],
    "BatchReadEfficiency": "1通信で8デバイス取得"
  }
}
```

### 🔧 実装対象ファイル
1. **`DeviceDiscoveryModels.cs`**: `DeviceValueInfo`クラス追加、`DeviceScanResult`拡張
2. **`DeviceScanner.cs`**: `FindActiveBitDevices`/`FindActiveWordDevices`拡張
3. **`IntelligentMonitoringSystem.cs`**: Step5での値利用、ログ表示改善
4. **`UnifiedLogWriter.cs`**: 構造化ログへの値情報追加

### ✅ 実装完了基準
- [ ] 全デバイスの具体的な値が`DeviceValues`プロパティに保存される
- [ ] ターミナルで個別デバイス値がリアルタイム表示される
- [ ] ログファイルに構造化された値情報が出力される
- [ ] バッチ読み取りの効率性が維持される
- [ ] アクティブ・非アクティブ問わず全値が確認可能
- [ ] Step5で保存された値を使用した非ゼロ判定が動作する

### 🎯 技術的考慮事項
- **メモリ使用量**: 大量デバイス値保存によるメモリ影響の最小化
- **パフォーマンス**: バッチ読み取り効率を損なわない実装
- **データ整合性**: アドレスと値の正確な対応付け
- **ログサイズ**: 詳細値情報によるログファイル肥大化への対策

---

**このドキュメントは完全再現可能な実装手順を提供します。記載された手順に従うことで、設計書要求の全機能を実装し、Step4での生データ記録を完全に実現できます。**