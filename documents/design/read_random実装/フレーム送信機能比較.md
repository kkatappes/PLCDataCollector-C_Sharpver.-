# PLC通信 フレーム送信機能比較

比較対象:
- andon (C#プロジェクト)
- ConMoni (Pythonサンプル)
- ConMoni3 (C#サンプル)
- PySLMPClient (Pythonライブラリ)

作成日: 2025-11-18
更新日: 2025-11-18 (ConMoni3追加)

---

## 1. andon (C#) のフレーム送信処理フロー

### 処理概要
- 設計段階でReadRandom(0x0403)コマンドの送信フレーム構築機能が計画済み
- 現時点では未実装（Phase2として実装計画が存在）

### 設計上の処理フロー

```
┌───────────────────────────────────────────┐
│ BuildReadRandomRequest()                   │
│ (設計文書: Phase2_フレーム構築機能の追加.md) │
├───────────────────────────────────────────┤
│ 1. 入力検証                                 │
│    - デバイスリスト存在確認                  │
│    - デバイス点数上限チェック (255点以下)     │
│    - ReadRandom対応デバイスコード検証        │
│      (TS/TC/CS/CCは使用不可)               │
│                                            │
│ 2. フレームタイプ判定                        │
│    - 3E or 4E選択                          │
│                                            │
│ 3. ヘッダ部構築                             │
│    【3Eフレーム】                           │
│    - サブヘッダ: 0x50 0x00                 │
│    - ネットワーク番号: 0x00                 │
│    - PC番号: 0xFF                          │
│    - I/O番号: 0xFF 0x03 (LE)              │
│    - マルチドロップ局番: 0x00               │
│    - データ長: (動的計算、後で確定)          │
│                                            │
│    【4Eフレーム】                           │
│    - サブヘッダ: 0x54 0x00                 │
│    - シリアル番号: 0x00 0x00               │
│    - 予約: 0x00 0x00                       │
│    - (以降3Eと同じ)                         │
│                                            │
│ 4. 監視タイマ設定                           │
│    - 250ms単位 (デフォルト: 32 = 8秒)      │
│    - リトルエンディアンで格納               │
│                                            │
│ 5. コマンド部構築                           │
│    - コマンド: 0x03 0x04 (LE)             │
│    - サブコマンド: 0x00 0x00 (LE)         │
│    - ワード点数: デバイス数 (1バイト)       │
│    - Dword点数: 0x00 (未対応)              │
│                                            │
│ 6. デバイス指定部構築                       │
│    各デバイスごとに4バイト:                  │
│    - デバイス番号: 3バイト (LE)            │
│    - デバイスコード: 1バイト                │
│                                            │
│ 7. データ長確定                             │
│    - 監視タイマ以降のバイト数を計算          │
│    - ヘッダのデータ長フィールドに書き込み     │
│                                            │
│ 8. フレーム送信                             │
│    - socket.SendAsync()で送信              │
│    - 送信バイト数検証                       │
│    - 送信時刻・所要時間記録                  │
└───────────────────────────────────────────┘
```

### 特徴
✅ **SLMP仕様書準拠の厳密な設計**
✅ **入力検証の徹底** (デバイスコード制約チェック含む)
✅ **3E/4E両対応** (フレームタイプを引数で指定)
✅ **動的データ長計算** (可変長デバイスリストに対応)
✅ **リトルエンディアン処理の明示** (BitConverter使用)
✅ **エラーハンドリング充実** (ArgumentException等)

⚠️ **実装未完了** (Phase2として設計のみ存在)
⚠️ **Dword読み出し未対応** (ワードのみ)

---

## 2. ConMoni (Python) のフレーム送信処理フロー

### 処理概要
- 設定ファイル(JSON)に格納された固定バイト配列を直接送信
- フレーム構築ロジックなし（事前に構築済みのバイト列を使用）

### 処理フロー

```
┌───────────────────────────────────────────┐
│ getPlcData() メソッド                      │
│ (GetPlcData.py: 280-327行目)              │
├───────────────────────────────────────────┤
│ 1. 設定ファイルから送信フレーム取得          │
│    self.settingData["accessPlcSetting"]   │
│    ↓                                       │
│    例: [0x54, 0x00, 0x00, ...]            │
│       (4Eフレーム、ランダム読出し)          │
│                                            │
│ 2. bytes型へ変換                           │
│    bytes(self.settingData["accessPlcSetting"]) │
│                                            │
│ 3. ソケット送信                             │
│    self.sock.send(バイト配列)              │
│    - TCP/UDP自動判定済み                   │
│    - タイムアウト設定あり                   │
│                                            │
│ 4. 応答受信                                 │
│    res = self.sock.recv(self.BUFSIZE)     │
│    - BUFSIZE = 4096バイト                 │
│                                            │
│ 5. HEX文字列変換                           │
│    resRaw = [format(i,'02X') for i in res]│
│    - バイト配列 → ['D4','00','00',...]    │
│                                            │
│ 6. データ解析（受信処理へ）                  │
│    - デバイス値抽出                         │
│    - ビット展開処理                         │
└───────────────────────────────────────────┘
```

### accessPlcSetting の構造例
```json
{
  "accessPlcSetting": [
    84, 0, 0, 0, 0, 0, 0, 255, 255, 3, 0, 200, 0, 32, 0,
    3, 4, 0, 0, 48, 0,
    72, 238, 0, 168,
    75, 238, 0, 168,
    ...
  ]
}
```

**フレーム解析結果**:
- サブヘッダ: 0x54 0x00 (4Eフレーム)
- データ長: 0x00C8 (200バイト)
- 監視タイマ: 0x0020 (32 = 8秒)
- コマンド: 0x0403 (ランダム読出し)
- ワード点数: 0x30 (48点)

### 特徴
✅ **シンプルな実装** (コード量最小)
✅ **高速処理** (フレーム構築処理なし)
✅ **設定ファイルで柔軟に変更可能**
✅ **実績あり** (実機稼働済み)

⚠️ **フレーム構築機能なし** (手動で事前作成必要)
⚠️ **動的なデバイス変更不可** (設定ファイル再作成必要)
⚠️ **検証機能なし** (不正なフレームでもそのまま送信)
⚠️ **4Eフレーム固定** (3E未対応)

---

## 3. ConMoni3 (C#) のフレーム送信処理フロー

### 処理概要
- ConMoni (Python版) のC#移植版
- 設定ファイル(JSON)に格納された固定バイト配列を直接送信
- フレーム構築ロジックなし（Pythonサンプルと同じアプローチ）
- PostgreSQLへのRawデータ保存が目的

### 処理フロー

```
┌───────────────────────────────────────────┐
│ SocketConnection() メソッド                │
│ (Program.cs: App.SocketConnection)        │
├───────────────────────────────────────────┤
│ 1. 設定データ読み込み                       │
│    SettingData (JSONから逆シリアル化)       │
│    - AccessPlcSetting: List<int>          │
│    - IPAddress: string                    │
│    - Port: int                            │
│    - ConnectionMethod: "TCP" or "UDP"     │
│    - Key: string (DB格納用キー)            │
│                                            │
│ 2. ソケットタイプ判定                       │
│    if (ConnectionMethod == "TCP")         │
│        SocketType.Stream / ProtocolType.Tcp │
│    else                                    │
│        SocketType.Dgram / ProtocolType.Udp │
│                                            │
│ 3. PLC接続                                 │
│    sock.Connect(IPAddress, Port)          │
│    - ReceiveTimeout: 3ミリ秒               │
│                                            │
│ 4. フレーム送信                             │
│    var accessPlcSetting =                 │
│        settingData.AccessPlcSetting       │
│            .Select(i => (byte)i).ToArray() │
│    sock.Send(accessPlcSetting)            │
│                                            │
│ 5. 応答受信                                 │
│    byte[] buffer = new byte[4096]         │
│    int bytesRead = sock.Receive(buffer)   │
│                                            │
│ 6. 受信データ返却                           │
│    return (buffer[0..bytesRead], key, DateTime.Now) │
│                                            │
│ 7. エラーハンドリング                       │
│    - SocketException: コンソール出力のみ    │
│    - Exception: 汎用エラー処理              │
│    - 失敗時: (null, null, default)返却     │
└───────────────────────────────────────────┘
        ↓
┌───────────────────────────────────────────┐
│ Run() メソッド (メインループ)               │
├───────────────────────────────────────────┤
│ 1. 設定リストループ                         │
│    foreach (var settings in _targetList)  │
│                                            │
│ 2. PLC通信実行                              │
│    var (response, key, dateTime) =        │
│        SocketConnection(settings)         │
│                                            │
│ 3. 応答検証                                 │
│    if (response == null) continue         │
│                                            │
│ 4. PostgreSQL保存                          │
│    INSERT INTO cbm (c_datetime, key, value) │
│    VALUES (@datetime, @key, @value)       │
│    - key: 設定ファイルのKey                 │
│    - value: 受信したバイト配列 (Raw)        │
│                                            │
│ 5. DB接続失敗時の再接続                     │
│    EstablishConnection()                  │
│    - 無限ループで接続成功まで再試行          │
│    - 3秒間隔でリトライ                      │
│                                            │
│ 6. スロットリング                           │
│    Thread.Sleep(10)                       │
│    - CPU過負荷防止のため10ms待機            │
└───────────────────────────────────────────┘
```

### AccessPlcSetting の構造例 (JSON設定ファイル)
```json
{
  "AccessPlcSetting": [
    84, 0, 0, 0, 0, 0, 0, 255, 255, 3, 0, 200, 0, 32, 0,
    3, 4, 0, 0, 48, 0,
    72, 238, 0, 168,
    75, 238, 0, 168
  ],
  "IPAddress": "172.30.40.15",
  "Port": 8192,
  "ConnectionMethod": "UDP",
  "Key": "Equipment_A_Line1"
}
```

**フレーム解析結果**:
- サブヘッダ: 0x54 0x00 (4Eフレーム)
- データ長: 0x00C8 (200バイト)
- 監視タイマ: 0x0020 (32 = 8秒)
- コマンド: 0x0403 (ランダム読出し)
- ワード点数: 0x30 (48点)

### 特徴
✅ **C#による実装** (Python版の完全移植)
✅ **シンプルな実装** (フレーム構築なし)
✅ **高速処理** (固定バイト配列を直接送信)
✅ **DB統合** (PostgreSQLへRawデータ保存)
✅ **複数PLC対応** (設定ファイルリストをループ処理)
✅ **自動再接続** (DB/PLC接続失敗時の自動リトライ)
✅ **TCP/UDP両対応** (設定ファイルで切替可能)

⚠️ **フレーム構築機能なし** (ConMoniと同じアプローチ)
⚠️ **検証機能なし** (不正なフレームでもそのまま送信)
⚠️ **受信タイムアウトが極端に短い** (3ミリ秒 - 実用的でない可能性)
⚠️ **動的なデバイス変更不可** (設定ファイル再作成必要)
⚠️ **受信データの解析なし** (RawデータをそのままDB保存)

### Python版ConMoniとの違い

| 項目 | ConMoni (Python) | ConMoni3 (C#) |
|-----|-----------------|--------------|
| **言語** | Python | C# |
| **送信処理** | self.sock.send(bytes(...)) | sock.Send(byte[]) |
| **受信処理** | res = self.sock.recv(4096) | sock.Receive(buffer) |
| **データ保存** | CSV/Parquetファイル | PostgreSQLデータベース |
| **データ解析** | ✅ あり (HEX変換、ビット展開) | ❌ なし (Rawデータのみ) |
| **ビット展開** | ✅ 実装済み | ❌ 未実装 |
| **桁数変換** | ✅ digitControl対応 | ❌ 未実装 |
| **前回値比較** | ✅ 不連続データ対応 | ❌ 未実装 |
| **エラー処理** | 最小限 | 最小限 (ほぼ同等) |
| **受信タイムアウト** | 2秒 (実用的) | 3ミリ秒 (⚠️ 短すぎ) |

### DB保存フォーマット

**PostgreSQLテーブル構造** (推定):
```sql
CREATE TABLE cbm (
    c_datetime TIMESTAMP,
    key TEXT,
    value BYTEA  -- Rawバイト配列
);
```

**保存例**:
```
c_datetime: 2025-11-18 10:30:45.123
key: Equipment_A_Line1
value: \xd4000000000000ffff0300620000...
```

### 用途の違い

| プロジェクト | 想定用途 |
|------------|---------|
| **ConMoni (Python)** | - リアルタイムモニタリング<br>- CSV/Parquetファイル出力<br>- データ解析・可視化 |
| **ConMoni3 (C#)** | - Rawデータ収集<br>- 中央DB集約<br>- 後処理用データ蓄積 |

---

## 4. PySLMPClient (Python) のフレーム送信処理フロー

### 処理概要
- 汎用SLMPライブラリとして完全実装
- read_random_word_devices()メソッドで自動フレーム構築

### 処理フロー

```
┌───────────────────────────────────────────┐
│ read_random_word_devices() メソッド        │
│ (pyslmpclient/__init__.py)                │
├───────────────────────────────────────────┤
│ 1. 入力検証                                 │
│    - デバイスリスト存在確認                  │
│    - 点数上限チェック (192点以下)           │
│    - デバイスコード妥当性検証                │
│                                            │
│ 2. コマンドフレーム構築 (__cmd_format)      │
│    - コマンドコード: 0x0403               │
│    - サブコマンド: 0x0000                  │
│    - ワード点数・Dword点数設定              │
│                                            │
│ 3. デバイス指定部構築                       │
│    各デバイスごとに:                        │
│    - デバイス番号 (3バイト、LE)            │
│    - デバイスコード (1バイト)              │
│                                            │
│ 4. ヘッダ付与 (フレーム形式別)              │
│    【3E Binary】                           │
│    - サブヘッダ: 0xD0 0x00                │
│    - (共通ヘッダ + コマンド部)             │
│                                            │
│    【4E Binary】                           │
│    - サブヘッダ: 0xD4 0x00                │
│    - シリアル番号: 自動インクリメント        │
│    - (共通ヘッダ + コマンド部)             │
│                                            │
│    【3E ASCII】                            │
│    - サブヘッダ: "D0"                     │
│    - 全データを16進文字列化                 │
│                                            │
│    【4E ASCII】                            │
│    - サブヘッダ: "D4"                     │
│    - シリアル番号: 16進文字列              │
│    - 全データを16進文字列化                 │
│                                            │
│ 5. データ長計算・設定                       │
│    - フレーム形式別に計算                   │
│    - リトルエンディアン変換                 │
│                                            │
│ 6. シーケンス番号管理 (4Eのみ)              │
│    self.__seq += 1                        │
│                                            │
│ 7. フレーム送信                             │
│    self.__socket.send(frame)              │
│                                            │
│ 8. 応答待機 (__recv_loop)                  │
│    - 別スレッドで非同期受信                 │
│    - シーケンス番号でマッチング             │
│    - タイムアウト管理                       │
│                                            │
│ 9. 応答解析                                 │
│    - 終了コード検証                         │
│    - デバイス値抽出                         │
│    - array.array('H')でuint16配列化       │
│                                            │
│ 10. 統計情報記録                            │
│    - 送受信回数                             │
│    - 応答時間                               │
│    - エラー回数                             │
└───────────────────────────────────────────┘
```

### 特徴
✅ **完全なSLMP実装** (3E/4E × Binary/ASCII 全対応)
✅ **動的フレーム構築** (引数からリアルタイム生成)
✅ **シーケンス番号管理** (4Eフレームの複数要求対応)
✅ **非同期受信処理** (別スレッドで受信待機)
✅ **厳格な終了コード検証** (EndCodeクラスで詳細判定)
✅ **汎用性が高い** (ライブラリとして多様なコマンド対応)

⚠️ **ライブラリ依存** (単独利用が前提)
⚠️ **オーバーヘッド** (汎用性のため処理が重い)
⚠️ **カスタマイズ困難** (内部実装の変更が難しい)

---

## 5. 4プロジェクトの機能比較表

| 項目 | andon (C#) | ConMoni (Python) | ConMoni3 (C#) | PySLMPClient (Python) |
|-----|-----------|-----------------|--------------|---------------------|
| **フレーム構築方式** | 動的構築 (設計段階) | 固定バイト配列 | 固定バイト配列 | 動的構築 (実装済み) |
| **対応フレーム形式** | 3E/4E Binary (計画) | 4E Binary固定 | 4E Binary固定 | 3E/4E × Binary/ASCII |
| **コマンド指定** | 引数で指定 | 設定ファイル固定 | 設定ファイル固定 | 引数で指定 |
| **デバイスリスト** | List<DeviceSpecification> | JSONファイル (固定) | JSONファイル (固定) | List[(device, address)] |
| **デバイス数上限** | 255点 (検証あり) | 制限なし (検証なし) | 制限なし (検証なし) | 192点 (検証あり) |
| **データ長計算** | 動的計算 | 固定値 (設定ファイル) | 固定値 (設定ファイル) | 動的計算 |
| **監視タイマ** | 引数で指定可能 | 固定値 (設定ファイル) | 固定値 (設定ファイル) | 引数で指定可能 |
| **シーケンス番号** | 未実装 (4Eで必要) | 固定 (0x0000) | 固定 (0x0000) | 自動インクリメント |
| **リトルエンディアン処理** | BitConverter使用 | 手動結合 (文字列反転) | Select(i => (byte)i) | struct.pack使用 |
| **入力検証** | 厳格 (デバイスコード制約含む) | なし | なし | 標準的 |
| **エラーハンドリング** | 多層的 (設計段階) | 最小限 | 最小限 | 充実 (例外クラス) |
| **送信処理** | SendAsync (非同期) | send (同期) | Send (同期) | send (同期) |
| **応答待機** | ReceiveAsync (非同期) | recv (同期) | Receive (同期) | 別スレッド (非同期) |
| **受信タイムアウト** | 設定可能 | 2秒 (実用的) | ⚠️ 3ミリ秒 (短すぎ) | 設定可能 |
| **データ保存** | - | CSV/Parquet | PostgreSQL (Raw) | - |
| **データ解析** | ✅ 実装済み | ✅ 実装済み | ❌ なし (Raw保存のみ) | ✅ 実装済み |
| **実装状況** | ⚠️ 未実装 (設計のみ) | ✅ 実装済み (実績あり) | ✅ 実装済み | ✅ 実装済み (ライブラリ) |

---

## 6. 送信フレームの具体例

### 6.1 ReadRandom: D100, D200, D300 を読み出す

#### andon (設計上の出力)
```
50 00                # サブヘッダ (3E)
00 FF FF 03 00       # ネットワーク・局番・I/O・マルチドロップ
10 00                # データ長 (16バイト)
20 00                # 監視タイマ (32 = 8秒)
03 04 00 00          # コマンド (0x0403) + サブコマンド
03 00                # ワード点数=3, Dword点数=0
64 00 00 A8          # D100 (0x000064, デバイスコード 0xA8)
C8 00 00 A8          # D200 (0x0000C8, デバイスコード 0xA8)
2C 01 00 A8          # D300 (0x00012C, デバイスコード 0xA8)
```

#### ConMoni / ConMoni3 (実際の送信データ例)
```json
"AccessPlcSetting": [
  84, 0, 0, 0, 0, 0,    // サブヘッダ (4E) + シリアル + 予約
  0, 255, 255, 3, 0,    // ネットワーク・局番・I/O・マルチドロップ
  16, 0,                // データ長
  32, 0,                // 監視タイマ
  3, 4, 0, 0,           // コマンド
  3, 0,                 // ワード点数=3, Dword点数=0
  100, 0, 0, 168,       // D100
  200, 0, 0, 168,       // D200
  44, 1, 0, 168         // D300
]
```

**注**: ConMoni3では同じ構造のJSONを読み込み、`Select(i => (byte)i).ToArray()`でbyte配列に変換して送信

#### PySLMPClient (3E Binary)
```python
client.read_random_word_devices([
    ('D', 100),
    ('D', 200),
    ('D', 300)
])

# 内部で生成されるフレーム:
# 50 00 00 FF FF 03 00 10 00 20 00
# 03 04 00 00 03 00
# 64 00 00 A8 C8 00 00 A8 2C 01 00 A8
```

---

## 7. 実装の違いによる影響

### 7.1 柔軟性

| プロジェクト | デバイス変更時の対応 |
|------------|-------------------|
| **andon** | プログラム内で動的に変更可能<br>コード修正のみで対応 |
| **ConMoni** | 設定ファイル(JSON)を手動編集<br>フレームバイナリ計算が必要 |
| **ConMoni3** | 設定ファイル(JSON)を手動編集<br>フレームバイナリ計算が必要<br>ConMoniと同等 |
| **PySLMPClient** | プログラム内で動的に変更可能<br>引数変更のみで対応 |

### 7.2 保守性

| プロジェクト | 保守性評価 |
|------------|-----------|
| **andon** | ✅ **高**: フレーム構築ロジックが明確<br>SLMP仕様変更時も対応容易 |
| **ConMoni** | ⚠️ **低**: フレーム構造がブラックボックス<br>設定ファイル作成に専門知識必要 |
| **ConMoni3** | ⚠️ **低**: ConMoniと同等<br>C#だが構造は同じくブラックボックス |
| **PySLMPClient** | ✅ **高**: ライブラリとして洗練<br>ただしカスタマイズは困難 |

### 7.3 パフォーマンス

| プロジェクト | パフォーマンス |
|------------|--------------|
| **andon** | 中速: フレーム構築処理がある<br>ただしC#の高速実行で補完 |
| **ConMoni** | **最速 (Python)**: フレーム構築なし<br>固定バイト配列を直接送信 |
| **ConMoni3** | ⚠️ **最速 (C#)**: フレーム構築なし<br>C#のためさらに高速 |
| **PySLMPClient** | 低速: 汎用処理が多い<br>非同期処理のオーバーヘッド |

### 7.4 エラー耐性

| プロジェクト | エラー検出能力 |
|------------|--------------|
| **andon** | ✅ **最高**: 送信前に多段階検証<br>不正な設定でフレーム構築失敗 |
| **ConMoni** | ❌ **最低**: 検証なし<br>不正なフレームでもそのまま送信 |
| **ConMoni3** | ❌ **最低**: ConMoniと同等<br>検証なし |
| **PySLMPClient** | ✅ **高**: 標準的な検証機能<br>終了コード検証も充実 |

### 7.5 用途適性

| プロジェクト | 最適な用途 |
|------------|-----------|
| **andon** | 汎用PLCデータ収集システム<br>柔軟性と堅牢性が必要な場面 |
| **ConMoni** | 固定レイアウトのモニタリング<br>CSV/Parquet出力が必要な場面 |
| **ConMoni3** | 中央DB集約システム<br>複数PLCからのRawデータ収集 |
| **PySLMPClient** | プロトタイピング<br>多様なPLCとの通信テスト |

---

## 8. andonプロジェクトへの推奨事項

### 8.1 ConMoni/ConMoni3から学ぶべき点

#### ❌ 採用しない機能
- **固定バイト配列方式**
  - 理由: 保守性が低く、柔軟性に欠ける
  - 例外: 性能検証用のベンチマークツールとしては有効

- **3ミリ秒の受信タイムアウト (ConMoni3)**
  - 理由: 実用的でない、ネットワーク遅延に対応不可
  - ConMoniの2秒設定の方が実用的

#### ✅ 参考にすべき点
- **複数PLC設定リストのループ処理** (ConMoni3)
  - andonでも複数PLC対応を検討可能
  - 設定ファイルリストからの読み込み機能

- **DB接続の自動再接続機能** (ConMoni3)
  - EstablishConnection()パターンは有用
  - PostgreSQL統合も将来的に検討価値あり

### 8.2 PySLMPClientから採用すべき点
- ✅ **シーケンス番号の自動管理** (4Eフレーム用)
  - 複数要求の並行処理に必須
  - 要求-応答のマッチング精度向上

- ✅ **フレーム形式の完全対応** (ASCII形式の追加)
  - 現在はBinary専用だが、将来的にASCII対応も視野

- ✅ **終了コードの詳細検証**
  - EndCodeクラスのような詳細エラーマッピング

### 8.3 andon独自の強み (維持すべき点)
- ✅ **SLMP仕様書準拠の厳密な設計**
  - デバイスコード制約チェック (TS/TC/CS/CC除外)
  - データ長の動的計算
  - 入力検証の徹底

- ✅ **C#の型安全性**
  - DeviceSpecificationクラスによる型付き処理
  - BitConverterによる明示的なエンディアン処理

- ✅ **非同期処理の活用**
  - SendAsync/ReceiveAsyncによる高効率通信

---

## 9. 実装優先度

### Phase 1: 基本機能実装 (最優先)
1. ✅ BuildReadRandomRequest()メソッド実装
   - 3Eフレーム対応
   - ワード読み出しのみ
   - 入力検証充実

2. ✅ SendAsync()との統合
   - 既存の送信処理との連携

3. ✅ 単体テスト作成
   - フレーム構造の正確性検証
   - 実機データとの照合

### Phase 2: 拡張機能 (高優先)
1. 4Eフレーム対応
   - シーケンス番号管理機能追加

2. Dword読み出し対応
   - 32ビットデバイス対応

### Phase 3: 高度な機能 (中優先)
1. ASCII形式対応
   - Binary/ASCII自動切替

2. エラーコード詳細マッピング
   - PySLMPClient方式の採用

---

## 10. 結論

### 各プロジェクトの位置づけ

**andon (C#)**:
- 設計品質が最も高い
- 実装完了後は最もバランスの取れたソリューションになる見込み
- SLMP仕様書に最も忠実

**ConMoni (Python)**:
- 最も単純で高速
- 固定用途には最適
- CSV/Parquetファイル出力に強み

**ConMoni3 (C#)**:
- ConMoniのC#移植版
- DB統合に特化
- 複数PLC対応、自動再接続機能が有用
- ただしデータ解析機能なし（Rawデータ保存のみ）

**PySLMPClient (Python)**:
- 技術的完成度が最も高い
- ライブラリとして最も洗練
- andonの将来的な機能拡張の参考になる

### 最終推奨

**andonプロジェクトは、以下を組み合わせることで最も堅牢なSLMP実装を実現できる:**

1. **PySLMPClientの設計思想**
   - 動的フレーム構築
   - シーケンス番号管理
   - 終了コード詳細検証

2. **andon独自の厳格な検証機能**
   - デバイスコード制約チェック
   - 入力パラメータ検証
   - C#の型安全性

3. **ConMoni3の有用な機能** (部分的に採用)
   - 複数PLC設定リストのループ処理
   - DB接続の自動再接続パターン

**採用しないもの:**
- ConMoni/ConMoni3の固定バイト配列方式 (保守性・柔軟性に欠ける)
- ConMoni3の3ミリ秒タイムアウト (実用的でない)

**結論:** 動的フレーム構築を最優先とし、PySLMPClientとandon独自機能の融合を目指す。
