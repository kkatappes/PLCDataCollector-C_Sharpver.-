# LogFrameStructure フレーム構造可視化機能追加 実装記録

## 実装日
2025-11-11

## 対応するToDoリスト項目
`documents/ToDo/PLC不存在エラー対応ToDoリスト.md` の「2. ArraySegmentの範囲確認 - Phase 3: フレーム構造可視化」

## 実装目的
- PLCフレームの各フィールドを人間が読みやすい形式で表示する
- デバッグ時にフレーム内容を素早く理解できるようにする
- バイナリダンプだけでは分かりにくいフィールドの意味を明示化する
- フレーム構築の正確性を視覚的に確認できるようにする

## 実装対象
- ファイル: `PlcRealDeviceTest/Program.cs`
- 新規メソッド: `LogFrameStructure`
- 呼び出し元: `ExecuteTest` メソッド（フレーム構築後）

## 実装前の状態
フレーム表示は以下の2つのメソッドで行われていた：
1. `LogBinaryRawData`: 1行の16進数表記
2. `LogHexDump`: 16進数ダンプ（16バイト単位、ASCII表示付き）

### 問題点
- フィールドの区切りが視覚的に分かりにくい
- 各バイトの意味を手動で数えて確認する必要がある
- デバイスコード、アドレス、点数などの値を頭の中で変換する必要がある
- フレーム形式（3E/4E）による構造の違いが分かりにくい

## 実装内容

### 新規メソッド: LogFrameStructure
- 3E/4E Binary フレームの構造を解析して表示
- 各フィールドを名前付きで表示（例: "サブヘッダ: 0x50 0x00"）
- リトルエンディアンの値を正しく解釈して表示
- デバイスコードを記号で表示（0xA8 → D、0xB4 → W）

### 表示内容
1. **ヘッダ部**
   - サブヘッダ（3E: 0x50 0x00、4E: 0x54 0x00 + シリアル番号）
   - ネットワーク番号
   - PC番号
   - ユニットI/O番号
   - 局番
   - データ長

2. **コマンド部**
   - CPU監視タイマー
   - コマンド（0x0401 = READ、0x1401 = WRITE）
   - サブコマンド（0x0000 = ワード、0x0001 = ビット）

3. **データ部**
   - デバイスコード（数値 + 記号）
   - 開始デバイス番号
   - デバイス点数

## 実装判断の根拠

### なぜフレーム構造可視化が必要か
1. **デバッグ効率の向上**: フィールド単位で確認できるため、問題箇所の特定が容易
2. **フレーム構築の検証**: 各フィールドが正しく設定されているか即座に確認可能
3. **学習効果**: フレーム構造を視覚的に理解できる
4. **ドキュメンテーション**: ログ自体がフレーム構造の説明書として機能

### 他の方法との比較

#### 検討した方法1: 既存のLogHexDumpのみ使用
- ❌ フィールドの意味が分かりにくい
- ❌ 値の変換（リトルエンディアン）を手動で行う必要がある
- ❌ デバッグ効率が低い

#### 検討した方法2: 外部ツールでの解析
- ❌ ログファイルを別ツールで処理する手間
- ❌ リアルタイムでの確認ができない
- ❌ 開発効率が悪い

#### 採用した方法: 専用メソッドでの構造化表示
- ✅ ログ出力時に構造化された情報が得られる
- ✅ リトルエンディアンの値を自動変換
- ✅ デバイスコードを記号で表示
- ✅ フレーム形式（3E/4E）に応じた表示

## 技術選択のトレードオフ

### メリット
1. **デバッグ容易性の大幅向上**: フィールド単位での確認が可能
2. **ヒューマンエラーの削減**: 手動での値変換が不要
3. **可読性の向上**: ログが自己文書化される
4. **保守性の向上**: 将来的なフレーム形式追加が容易

### デメリット
1. **コード量の増加**: 新しいメソッド追加により約60-80行増加
2. **ログサイズの増加**: 構造化表示により1フレームあたり約10-15行追加
3. **パフォーマンスへの影響**: ログ出力のオーバーヘッド（微小）

### トレードオフの判断
- テストプログラムであり、デバッグ情報の充実度が最優先
- ログサイズの増加は問題にならない（テスト実行回数が限定的）
- パフォーマンスへの影響は無視できるレベル
- メリットがデメリットを大きく上回ると判断

## 実装後のコード構造

### 新規メソッド LogFrameStructure の仕様
```csharp
private static void LogFrameStructure(TestPattern pattern, byte[] frame)
{
    // 3E/4E Binary フレームの構造解析と表示
    // - ヘッダ部の解析
    // - コマンド部の解析
    // - データ部の解析
}
```

### ExecuteTest での呼び出し
```csharp
byte[] requestFrame = BuildFrame(pattern);

// 既存の表示
LogBinaryRawData(requestFrame);
LogHexDump(requestFrame);

// 新規追加: 構造化表示
Log($"[構築] フレーム構造（詳細）:");
LogFrameStructure(pattern, requestFrame);
```

## 期待される効果
1. デバッグ時間の短縮（フィールド確認が即座に可能）
2. フレーム構築エラーの早期発見
3. 学習曲線の改善（フレーム構造の理解が容易）
4. ログの自己文書化（追加説明不要）

## テスト計画
### 単体テストは不要
- テストプログラム自体がテストケースであるため、個別の単体テストは作成しない
- 実機テスト実行時に以下を確認:
  1. 構造化表示が正しく出力される
  2. 各フィールドの値が正確に表示される
  3. リトルエンディアンの値が正しく変換される
  4. デバイスコードが記号で表示される

### 実機テスト時の確認項目
- [ ] ログに構造化されたフレーム情報が出力される
- [ ] サブヘッダが正しく表示される（3E: 0x5000、4E: 0x5400）
- [ ] ユニットI/O番号が正しく表示される（0x03FF）
- [ ] デバイスコードが記号で表示される（D、W等）
- [ ] 開始デバイス番号が正しく表示される
- [ ] デバイス点数が正しく表示される

## 発生した問題と解決過程
問題なく実装完了。

### 実装の詳細
1. **LogFrameStructureメソッドの追加** (599-736行目)
   - 3E/4E Binary フレームの構造を解析
   - 各フィールドを構造化して表示
   - リトルエンディアンの値を正しく解釈
   - デバイスコードを記号で表示

2. **ExecuteTestメソッドへの呼び出し追加** (167-168行目)
   - LogHexDumpの後にLogFrameStructureを呼び出し
   - フレーム構築後に構造化表示

### コード変更箇所

**PlcRealDeviceTest/Program.cs:599-736 (新規メソッド追加)**
```csharp
/// <summary>
/// フレーム構造の可視化（3E/4E Binaryフレーム）
/// </summary>
private static void LogFrameStructure(TestPattern pattern, byte[] frame)
{
    // 3E/4E Binary フレームの構造を解析して表示
    // - サブヘッダ（3E: 0x5000、4E: 0x5400 + シリアル番号）
    // - ネットワーク情報（5バイト）
    // - 要求データ長（2バイト）
    // - CPU監視タイマー（2バイト）
    // - コマンド（2バイト）- 一括読み出し/書き込み等
    // - サブコマンド（2バイト）- ワード/ビット単位
    // - デバイスコード（1バイト）- D/W/M等
    // - 開始デバイス番号（3バイト）
    // - デバイス点数（2バイト）
}
```

**PlcRealDeviceTest/Program.cs:167-168 (呼び出し追加)**
```csharp
Log($"[構築] フレーム構造（詳細）:");
LogFrameStructure(pattern, requestFrame);
```

### 実装したデバイスコード一覧
以下のデバイスコードに対応:
- 0xA8: D (データレジスタ)
- 0xB4: W (リンクレジスタ)
- 0x9C: M (内部リレー)
- 0x90: SM (特殊リレー)
- 0x94: X (入力)
- 0x9D: Y (出力)
- 0xA0: L (ラッチリレー)
- 0xA1: F (アナンシエータ)
- 0xA9: R (ファイルレジスタ)
- 0xAF: Z (インデックスレジスタ)

### 実装したコマンド一覧
以下のコマンドに対応:
- 0x0401: 一括読み出し
- 0x1401: 一括書き込み
- 0x0406: ランダム読み出し
- 0x1406: ランダム書き込み

### 実装したサブコマンド一覧
以下のサブコマンドに対応:
- 0x0000: ワード単位
- 0x0001: ビット単位

## 実装完了日時
2025-11-11

## 出力例（期待される表示）
```
[構築] フレーム構造（詳細）:
  サブヘッダ      : 0x50 0x00 (0x0050) - 3Eフレーム
  ネットワーク番号: 0x00
  PC番号          : 0xFF
  ユニットI/O番号 : 0xFF 0x03 (0x03FF)
  局番            : 0x00
  要求データ長    : 0x0C 0x00 (12バイト, 0x000C)
  CPU監視タイマー : 0x00 0x00 (0ms, 0x0000)
  コマンド        : 0x01 0x04 (0x0401) - 一括読み出し
  サブコマンド    : 0x00 0x00 (0x0000) - ワード単位
  ---
  デバイスコード  : 0xA8 - D (データレジスタ)
  開始デバイス番号: 0x00 0x00 0x00 (0, 0x000000)
  デバイス点数    : 0x01 0x00 (1点, 0x0001)
```

## 次のステップ
実機環境で以下を実施:
1. ビルド: `dotnet build`
2. テスト実行: `PlcRealDeviceTest.exe`
3. ログファイル確認:
   - フレーム構造が正しく表示されているか
   - 各フィールドの値が正確か
   - デバイスコード、コマンド、サブコマンドが記号で表示されているか

## 備考
- このPCはPLC接続環境ではないため、ビルドは実施しない
- 実機テストは環境がある場所で実施する必要がある
- ASCII形式フレームへの対応は将来的な拡張として考慮
- 実装記録ファイル: `documents/implementation_records/method_records/LogFrameStructure_フレーム構造可視化機能追加.md`
