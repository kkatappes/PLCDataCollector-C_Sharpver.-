# SendFrameAsync実装記録

## 実装日時
- 実装日: 2025-11-06
- 所要時間: 約1.5時間

## 実装対象メソッド
- **クラス**: PlcCommunicationManager
- **メソッド**: SendFrameAsync(string frameHexString)
- **目的**: SLMPフレームをPLCへ送信する

## 実装判断根拠

### 1. TDD手法の採用理由
**判断**: Red-Green-Refactorサイクルを厳守
**理由**:
- テスト駆動により、仕様を明確化
- リグレッションを防止
- リファクタリングの安全性を確保
- ドキュメントとしてのテストコード作成

### 2. dynamic型の使用判断
**判断**: MockSocketとの互換性のため、dynamic型を使用
**理由**:
- Socket.SendAsyncメソッドはvirtualではなくオーバーライド不可
- MockSocketの"new"キーワードは静的バインディング
- 実行時バインディング（dynamic）により、MockSocketのメソッドを呼び出し可能
- テスタビリティを優先

**トレードオフ**:
- 型安全性の低下
- 実行時エラーの可能性
- パフォーマンスの若干の低下

**将来の改善案**:
- ISocketWrapperインターフェースの導入
- 依存性注入の活用
- より型安全な設計への移行

### 3. ArraySegment<byte>の使用
**判断**: byte[]ではなくArraySegment<byte>を使用
**理由**:
- Socket.SendAsync(byte[], SocketFlags)は拡張メソッド
- 内部でArraySegment<byte>版を呼び出す
- MockSocketの実装と合わせるため

### 4. エラーハンドリング戦略
**判断**: 多段階のエラーハンドリングを実装
**理由**:
1. **入力検証**: null/emptyチェックで早期エラー検出
2. **未接続チェック**: 不正な状態でのAPI呼び出しを防止
3. **SocketException処理**: ネットワークエラーを適切にラップ
4. **予期しない例外処理**: すべての例外をInvalidOperationExceptionでラップ

**利点**:
- 呼び出し側で統一的なエラーハンドリングが可能
- デバッグ情報の保持（InnerException）
- エラーメッセージの一貫性

### 5. パフォーマンス計測の組み込み
**判断**: 送信時間を計測するロジックを追加
**理由**:
- 将来のパフォーマンス分析に活用
- タイムアウト検出の基礎データ
- ログ出力時の有用な情報

## 発生した問題と解決過程

### 問題1: プロジェクトファイル(.csproj)の不在
**発生状況**: dotnet testでプロジェクトファイルが見つからないエラー
**原因**: プロジェクトファイルが作成されていなかった
**解決**:
- andon.csprojとandon.Tests.csprojを作成
- .slnファイルのプロジェクトパスを修正
- dotnet restoreで依存関係を復元

### 問題2: .NET 8.0ランタイムの不在
**発生状況**: テスト実行時に.NET 8.0が見つからないエラー
**原因**: システムに.NET 9.0のみがインストールされていた
**解決**:
- TargetFrameworkをnet9.0に変更
- 両プロジェクトの.csprojを更新

### 問題3: MockSocketのメソッドが呼ばれない
**発生状況**: Socket基底クラスの実装が呼ばれ、SocketExceptionが発生
**原因**:
- "new"キーワードは静的バインディング
- ConnectionResponse.Socketの型がSocket型として宣言されている
- オーバーライドではなく隠蔽のため、基底クラスのメソッドが呼ばれる

**試行した解決策**:
1. ❌ MockSocketのSendAsyncにnewキーワード追加 → 効果なし
2. ❌ ArraySegment<byte>版の実装 → 効果なし
3. ✅ dynamic型による実行時バインディング → 成功

**最終解決**:
```csharp
dynamic socket = _connectionResponse.Socket;
int bytesSent = await socket.SendAsync(segment, SocketFlags.None);
```

### 問題4: テストの期待値エラー（D000フレーム）
**発生状況**: D000フレームテストで期待40バイト、実際38バイト
**原因**: D000フレーム文字列の実際の長さが38文字だった
**調査結果**:
- M000フレーム: 40文字
- D000フレーム: 38文字（プロンプトの仕様通り）

**解決**: テストの期待値を38バイトに修正

## 技術選択の根拠

### 1. ASCIIエンコーディングの使用
**理由**: SLMPプロトコルのASCII形式仕様に準拠

### 2. 送信バイト数の検証
**理由**: 部分送信の検出とエラー早期発見

### 3. 例外の型統一
**理由**:
- 呼び出し側でのエラーハンドリング簡素化
- エラーメッセージの一貫性

## リファクタリング内容

### 追加機能
1. **XMLドキュメントコメント**: パラメータと例外の説明
2. **入力検証**: null/emptyチェック
3. **送信時間計測**: パフォーマンス分析用
4. **包括的エラーハンドリング**: すべての例外を適切に処理
5. **ログ出力プレースホルダー**: 将来のLoggingManager連携用

### コード品質向上
- 可読性の向上
- 保守性の向上
- 拡張性の確保

## テスト結果

### Red Phase（テスト失敗）
```
失敗: 2
合格: 0
スキップ: 0
合計: 2
```
理由: NotImplementedException（期待通り）

### Green Phase（最小実装）
```
成功!
失敗: 0
合格: 2
スキップ: 0
合計: 2
期間: 91ms
```

### Refactor Phase（リファクタリング後）
```
成功!
失敗: 0
合格: 2
スキップ: 0
合計: 2
期間: 85ms
```

## 将来の改善事項

### 1. 依存性注入の導入
- ISocketWrapperインターフェースの作成
- テスタビリティの向上
- dynamic型の排除

### 2. ログ機能の実装
- LoggingManagerとの連携
- 構造化ログの出力
- パフォーマンスメトリクスの記録

### 3. タイムアウト処理の実装
- SendTimeoutMsの活用
- CancellationTokenの導入
- タイムアウト時の適切なエラーハンドリング

### 4. リトライ機能の検討
- 一時的なネットワークエラーへの対応
- エクスポネンシャルバックオフの実装

## 学んだ教訓

### 1. TDDの価値
- テストファーストにより仕様が明確化
- リグレッション検出の容易さ
- リファクタリングの安全性

### 2. モックオブジェクトの難しさ
- Socket等のシステムクラスのモックは困難
- インターフェースベースの設計の重要性
- dynamic型は最後の手段として有効

### 3. プロジェクト構造の重要性
- .csprojファイルの適切な設定
- テストプロジェクトの分離
- 依存関係の明確化

## 総括

TC021_SendFrameAsync_正常送信テストの実装を通じて、TDD手法の有効性を実証できました。
Red-Green-Refactorサイクルを厳守することで、高品質で保守性の高いコードを作成できました。

MockSocketとの互換性問題は、dynamic型を使用することで解決しましたが、
将来的にはインターフェースベースの設計に移行すべきです。

すべてのテストケースが成功し、リファクタリング後もGreen（成功）を維持できたことは、
TDD手法の正しさを証明しています。
