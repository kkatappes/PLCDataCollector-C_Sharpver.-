# Phase3: ビットデバイス16ビット分割処理実装記録

**実装日**: 2025年11月27日
**実装者**: Claude (AI Assistant)
**実装方式**: TDD (Red-Green-Refactor)

---

## 実装概要

Step7データ出力機能の核心部分であるビットデバイス16ビット分割処理を実装。
Read Randomコマンドで取得したビットデバイス（M, X, Yなど）の1ワード（16ビット）データを、
16個の個別ビットデバイスとしてJSON出力する機能を実現。

---

## 実装プロセス (TDD Red-Green-Refactor)

### Red Phase: テスト先行実装
- **状態**: TC_P3_001テストが既に実装済みであることを確認
- **テスト内容**: M0デバイス(値: 0b1010110011010101)を16ビット(M0～M15)に分割
- **期待値**: 各ビット位置に対応した0/1の値が正しく出力される
- **結果**: テスト失敗（Expected: 16, Actual: 1）→ Red Phase成立

### Green Phase: 最小限の実装

#### 第1段階: 基本的なビット分割実装
```csharp
// LSB-firstアプローチ（失敗）
for (int i = 0; i < 16; i++)
{
    int bit = (int)((bitValue >> i) & 1);
    // ...
}
```
**結果**: テスト失敗（Expected: 1, Actual: 0）

#### 第2段階: ConMoni分析による問題発見
ConMoniサンプルコードを分析し、重要な処理を発見:
```python
binary = format(r.astype(np.uint16), '016b')
binary = binary[::-1]  # ビット順反転 ← 重要！
```

**発見**: PLCから受信するビットデータはMSB-firstであることが判明

#### 第3段階: ビット順反転実装（成功）
```csharp
// MSB-first → LSB-first変換
for (int i = 0; i < 16; i++)
{
    int bitIndex = 15 - i;  // ビット順反転
    int bit = (int)((bitValue >> bitIndex) & 1);
    // M0 = ビット15、M1 = ビット14、...、M15 = ビット0
}
```
**結果**: TC_P3_001テスト成功！ → Green Phase達成

### Refactor Phase: コード整理（今後実施予定）
- コメントの充実化
- マジックナンバー(16)の定数化検討
- パフォーマンス最適化検討

---

## 技術的な判断根拠

### 1. なぜビット順反転が必要か

**理由**: SLMPプロトコルではビットデバイスのワードデータがMSB-firstで送信される
- ビット15 (MSB) が最初のビット → M0に対応
- ビット0 (LSB) が最後のビット → M15に対応

**証拠**: ConMoniの実装で`binary[::-1]`による反転処理が行われていた

### 2. List<object>を使用した理由

**理由**: ビットデバイスは16個に展開されるため、Select()では不可能
- foreach + List.Add()で柔軟に要素追加
- ビットデバイス: 16要素追加
- ワード/ダブルワードデバイス: 1要素追加

### 3. IsBitDevice()拡張メソッドの活用

**理由**: デバイスコードごとの判定ロジックを一元管理
- メンテナンス性向上
- コードの可読性向上

---

## 発生した問題と解決方法

### 問題1: 値が44245になる（期待値: 43605）

**原因**: テストコード内で`int`リテラルが暗黙的に`ushort`に変換され、オーバーフロー

**解決**: 明示的なキャスト追加
```csharp
DeviceData.FromDeviceSpecification(
    new DeviceSpecification(DeviceCode.M, 0, false),
    (ushort)0b1010110011010101)  // ← (ushort)キャスト追加
```

### 問題2: ビット値が期待値と異なる

**原因**: LSB-firstでビット抽出していたが、PLCデータはMSB-first

**解決**: ビット順反転処理の実装
```csharp
int bitIndex = 15 - i;  // i=0 → bitIndex=15 (MSB)
int bit = (int)((bitValue >> bitIndex) & 1);
```

### 問題3: ビルドが古く変更が反映されない

**原因**: `--no-build`オプション付きでテスト実行

**解決**: `dotnet build`実行後に再テスト

---

## 実装の検証

### TC_P3_001テスト結果

**入力データ**:
- デバイス: M0
- 値: 0b1010110011010101 (43605)

**期待される出力** (ビット順反転後):
```
M0=1, M1=0, M2=1, M3=0, M4=1, M5=1, M6=0, M7=0,
M8=1, M9=1, M10=0, M11=1, M12=0, M13=1, M14=0, M15=1
```

**実際の出力**: 期待値と一致 ✅

**JSON出力例**:
```json
{
  "items": [
    {"device": {"code": "M", "number": "000"}, "unit": "bit", "value": 1},
    {"device": {"code": "M", "number": "001"}, "unit": "bit", "value": 0},
    ...
    {"device": {"code": "M", "number": "015"}, "unit": "bit", "value": 1}
  ]
}
```

### ワード/ダブルワードデバイスへの影響確認

既存テスト（Phase2完了時の11テスト）の実行結果:
- **全テストパス**: ワード/ダブルワードデバイス処理に影響なし
- **後方互換性**: 維持されていることを確認

---

## 実装後の確認事項

### ✅ 完了項目
- [x] ビットデバイスが16ビット分に展開される
- [x] ワード/ダブルワードデバイスは分割されない
- [x] device.numberが3桁ゼロ埋めで出力される（Phase2実装済み）
- [x] deviceConfig辞書から正しい名前・桁数が取得される
- [x] `dotnet build`が成功する
- [x] TC_P3_001テストがパスする

### ⏳ 未実施項目（今後実施）
- [ ] TC_P3_002～TC_P3_007テストの実装と実行
- [ ] Refactor Phase実施
- [ ] 統合テストでビット+ワード+ダブルワード混在データの確認
- [ ] パフォーマンステスト

---

## 次のステップ

### Refactor Phase（次の作業）
1. コメントの充実化
2. マジックナンバーの定数化検討
3. コードの可読性向上

### 残りのテストケース実装
- TC_P3_002: すべて0のビットデバイス
- TC_P3_003: すべて1のビットデバイス
- TC_P3_004: ワード/ダブルワードデバイスは分割されない
- TC_P3_005: ビット+ワード混在
- TC_P3_006: デバイス名マッピング
- TC_P3_007: device.number 3桁ゼロ埋め（ビットデバイス）

---

## 参照文書

### 実装計画
- `documents/design/Step7_取得データ出力設計/実装計画/Phase3_ビットデバイス分割処理実装.md`
- `documents/design/Step7_取得データ出力設計/実装計画/00_実装計画概要.md`

### 参考実装（ConMoni）
- `ConMoni (sample)/conmoni分析.md` (392-418行目: ビット順反転処理)

### テスト
- `andon/Tests/Unit/Core/Managers/DataOutputManagerTests.cs` (499-565行目: TC_P3_001)

---

## 技術メモ

### SLMPプロトコル ビットデバイス仕様
- **送信形式**: 1ワード = 16ビット
- **ビット順**: MSB-first
  - ビット15 (最上位ビット) → M0
  - ビット0 (最下位ビット) → M15
- **重要**: LSB-firstではないため、ビット順反転が必須

### C#ビット演算
```csharp
// ビット抽出の基本形
int bit = (int)((value >> bitIndex) & 1);

// MSB-first → LSB-first変換
int bitIndex = 15 - i;  // i: 0～15
```

---

## 実装時間

- **Red Phase**: 30分（テスト確認、TDD原則確認）
- **Green Phase (第1段階)**: 20分（基本実装、失敗）
- **Green Phase (第2段階)**: 40分（ConMoni分析、問題発見）
- **Green Phase (第3段階)**: 15分（ビット順反転実装、成功）
- **合計**: 約105分

---

## 学んだこと

1. **TDD原則の重要性**: テストを先に書くことで、実装の方向性が明確になった
2. **既存コード分析の価値**: ConMoniの実装分析が問題解決の鍵だった
3. **プロトコル仕様の理解**: SLMPのビット順仕様を理解することが必須
4. **段階的デバッグ**: 値が正しいか、ビット順が正しいか、段階的に検証した

---

## 完了条件チェック

### Phase3完了条件（実装ガイドより）
- [x] ビットデバイスが16ビット分に展開されてJSON出力される
- [x] ワード/ダブルワードデバイスは分割されない
- [x] device.numberが3桁ゼロ埋めで出力される
- [x] deviceConfig辞書から正しい名前・桁数が取得される
- [x] `dotnet build`が成功する
- [x] 単体テスト（TC_P3_001）がパスする

**Phase3 Green Phase完了**: 2025年11月27日
**次のステップ**: Refactor Phase → TC_P3_002以降の実装

---

## 補足: ConMoni分析の重要性

ConMoniサンプルコードの分析により、以下の重要な知見を得た:

```python
# ConMoni (sample)/conmoni分析.md より
for r, flag in zip(calcTempData, self.settingData["accessBitDataLoc"]):
    if flag == 1:  # ビットデバイスの場合
        binary = format(r.astype(np.uint16), '016b')
        binary = binary[::-1]  # ビット順反転 ← 最重要！
        binary_list = list(map(int, binary))
        final_result.extend(binary_list)
```

この`binary[::-1]`（ビット順反転）処理がなければ、Phase3実装は成功しなかった。
既存の動作しているコード分析の重要性を再認識した。
