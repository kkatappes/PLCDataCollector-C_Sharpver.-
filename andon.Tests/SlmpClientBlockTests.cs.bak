using System;
using System.Threading;
using System.Threading.Tasks;
using Xunit;
using Moq;
using Microsoft.Extensions.Logging;
using SlmpClient.Core;
using SlmpClient.Constants;
using SlmpClient.Transport;
using SlmpClient.Exceptions;
using System.Collections.Generic;

namespace andon.Tests
{
    public class SlmpClientBlockTests
    {
        private readonly Mock<ILogger<SlmpClient.Core.SlmpClient>> _mockLogger;
        private readonly Mock<ISlmpTransport> _mockTransport;
        private readonly SlmpClient.Core.SlmpClient _client;

        public SlmpClientBlockTests()
        {
            _mockLogger = new Mock<ILogger<SlmpClient.Core.SlmpClient>>();
            _mockTransport = new Mock<ISlmpTransport>();
            
            var settings = new SlmpConnectionSettings();
            _client = new SlmpClient.Core.SlmpClient("192.168.1.100", settings, _mockLogger.Object);
        }

        [Fact]
        public async Task ReadBlockAsync_ValidWordBlocks_ReturnsCorrectData()
        {
            // Arrange
            var wordBlocks = new List<(DeviceCode deviceCode, uint address, ushort count)>
            {
                (DeviceCode.D, 100, 5),
                (DeviceCode.D, 200, 3)
            };
            var bitBlocks = new List<(DeviceCode deviceCode, uint address, ushort count)>();

            var expectedWordData = new ushort[][]
            {
                new ushort[] { 1, 2, 3, 4, 5 },
                new ushort[] { 10, 20, 30 }
            };

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()))
                         .ReturnsAsync(CreateBlockReadResponse(expectedWordData, new bool[0][]));

            // Act
            var result = await _client.ReadBlockAsync(wordBlocks, bitBlocks);

            // Assert
            Assert.Equal(2, result.wordBlocks.Length);
            Assert.Empty(result.bitBlocks);
            Assert.Equal(expectedWordData[0], result.wordBlocks[0]);
            Assert.Equal(expectedWordData[1], result.wordBlocks[1]);
        }

        [Fact]
        public async Task ReadBlockAsync_ValidBitBlocks_ReturnsCorrectData()
        {
            // Arrange
            var wordBlocks = new List<(DeviceCode deviceCode, uint address, ushort count)>();
            var bitBlocks = new List<(DeviceCode deviceCode, uint address, ushort count)>
            {
                (DeviceCode.M, 100, 8),
                (DeviceCode.X, 0, 16)
            };

            var expectedBitData = new bool[][]
            {
                new bool[] { true, false, true, false, true, false, true, false },
                new bool[] { false, true, false, true, false, true, false, true, 
                           true, false, true, false, true, false, true, false }
            };

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()))
                         .ReturnsAsync(CreateBlockReadResponse(new ushort[0][], expectedBitData));

            // Act
            var result = await _client.ReadBlockAsync(wordBlocks, bitBlocks);

            // Assert
            Assert.Empty(result.wordBlocks);
            Assert.Equal(2, result.bitBlocks.Length);
            Assert.Equal(expectedBitData[0], result.bitBlocks[0]);
            Assert.Equal(expectedBitData[1], result.bitBlocks[1]);
        }

        [Fact]
        public async Task WriteBlockAsync_ValidWordBlocks_SendsCorrectData()
        {
            // Arrange
            var wordBlocks = new List<(DeviceCode deviceCode, uint address, ushort count, ushort[] data)>
            {
                (DeviceCode.D, 100, 3, new ushort[] { 100, 200, 300 }),
                (DeviceCode.D, 200, 2, new ushort[] { 400, 500 })
            };
            var bitBlocks = new List<(DeviceCode deviceCode, uint address, ushort count, bool[] data)>();

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()))
                         .ReturnsAsync(CreateSuccessResponse());

            // Act
            await _client.WriteBlockAsync(wordBlocks, bitBlocks);

            // Assert
            _mockTransport.Verify(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()), Times.Once);
        }

        [Fact]
        public async Task WriteBlockAsync_ValidBitBlocks_SendsCorrectData()
        {
            // Arrange
            var wordBlocks = new List<(DeviceCode deviceCode, uint address, ushort count, ushort[] data)>();
            var bitBlocks = new List<(DeviceCode deviceCode, uint address, ushort count, bool[] data)>
            {
                (DeviceCode.M, 100, 8, new bool[] { true, false, true, false, true, false, true, false }),
                (DeviceCode.Y, 0, 4, new bool[] { false, true, false, true })
            };

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()))
                         .ReturnsAsync(CreateSuccessResponse());

            // Act
            await _client.WriteBlockAsync(wordBlocks, bitBlocks);

            // Assert
            _mockTransport.Verify(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()), Times.Once);
        }

        [Fact]
        public async Task ReadBlockAsync_TooManyBlocks_ThrowsArgumentException()
        {
            // Arrange
            var wordBlocks = new List<(DeviceCode deviceCode, uint address, ushort count)>();
            for (int i = 0; i < 121; i++) // Exceeds 120 block limit
            {
                wordBlocks.Add((DeviceCode.D, (uint)(i * 10), 1));
            }
            var bitBlocks = new List<(DeviceCode deviceCode, uint address, ushort count)>();

            // Act & Assert
            await Assert.ThrowsAsync<ArgumentException>(() => 
                _client.ReadBlockAsync(wordBlocks, bitBlocks));
        }

        [Fact]
        public async Task WriteBlockAsync_DataCountMismatch_ThrowsArgumentException()
        {
            // Arrange
            var wordBlocks = new List<(DeviceCode deviceCode, uint address, ushort count, ushort[] data)>
            {
                (DeviceCode.D, 100, 5, new ushort[] { 1, 2, 3 }) // count=5 but data has 3 elements
            };
            var bitBlocks = new List<(DeviceCode deviceCode, uint address, ushort count, bool[] data)>();

            // Act & Assert
            await Assert.ThrowsAsync<ArgumentException>(() => 
                _client.WriteBlockAsync(wordBlocks, bitBlocks));
        }

        [Theory]
        [InlineData(0)]
        [InlineData(7169)] // Exceeds 7168 bit limit
        public async Task ReadBlockAsync_InvalidBitCount_ThrowsArgumentException(ushort count)
        {
            // Arrange
            var wordBlocks = new List<(DeviceCode deviceCode, uint address, ushort count)>();
            var bitBlocks = new List<(DeviceCode deviceCode, uint address, ushort count)>
            {
                (DeviceCode.M, 100, count)
            };

            // Act & Assert
            await Assert.ThrowsAsync<ArgumentException>(() => 
                _client.ReadBlockAsync(wordBlocks, bitBlocks));
        }

        private byte[] CreateBlockReadResponse(ushort[][] wordData, bool[][] bitData)
        {
            var response = new List<byte>();
            
            // SLMP header (successful response)
            response.AddRange(new byte[] { 0xD0, 0x00 }); // Success end code
            
            // Word data
            foreach (var block in wordData)
            {
                foreach (var value in block)
                {
                    response.AddRange(BitConverter.GetBytes(value));
                }
            }
            
            // Bit data (packed)
            foreach (var block in bitData)
            {
                var packed = SlmpClient.Utils.SlmpBitConverter.PackBits(block);
                response.AddRange(packed);
            }
            
            return response.ToArray();
        }

        private byte[] CreateSuccessResponse()
        {
            return new byte[] { 0x00, 0x00 }; // Success end code
        }
    }
}