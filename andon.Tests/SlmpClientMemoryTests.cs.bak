using System;
using System.Threading;
using System.Threading.Tasks;
using Xunit;
using Moq;
using Microsoft.Extensions.Logging;
using SlmpClient.Core;
using SlmpClient.Constants;
using SlmpClient.Transport;
using SlmpClient.Exceptions;
using System.Collections.Generic;

namespace andon.Tests
{
    public class SlmpClientMemoryTests
    {
        private readonly Mock<ILogger<SlmpClient.Core.SlmpClient>> _mockLogger;
        private readonly Mock<ISlmpTransport> _mockTransport;
        private readonly SlmpClient.Core.SlmpClient _client;

        public SlmpClientMemoryTests()
        {
            _mockLogger = new Mock<ILogger<SlmpClient.Core.SlmpClient>>();
            _mockTransport = new Mock<ISlmpTransport>();
            
            var settings = new SlmpConnectionSettings();
            _client = new SlmpClient.Core.SlmpClient("192.168.1.100", settings, _mockLogger.Object);
        }

        [Fact]
        public async Task MemoryReadAsync_ValidAddress_ReturnsData()
        {
            // Arrange
            uint address = 0x1000;
            ushort length = 100;
            var expectedData = new byte[length];
            for (int i = 0; i < length; i++)
            {
                expectedData[i] = (byte)(i % 256);
            }

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()))
                         .ReturnsAsync(CreateMemoryReadResponse(expectedData));

            // Act
            var result = await _client.MemoryReadAsync(address, length);

            // Assert
            Assert.Equal(expectedData, result);
        }

        [Theory]
        [InlineData(0x0000, 1)]
        [InlineData(0x1000, 50)]
        [InlineData(0xFFFF, 480)] // Maximum length
        public async Task MemoryReadAsync_VariousAddressesAndLengths_ReturnsCorrectData(uint address, ushort length)
        {
            // Arrange
            var expectedData = new byte[length];
            for (int i = 0; i < length; i++)
            {
                expectedData[i] = (byte)(i % 256);
            }

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()))
                         .ReturnsAsync(CreateMemoryReadResponse(expectedData));

            // Act
            var result = await _client.MemoryReadAsync(address, length);

            // Assert
            Assert.Equal(length, result.Length);
            Assert.Equal(expectedData, result);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(481)] // Exceeds 480 word limit
        public async Task MemoryReadAsync_InvalidLength_ThrowsArgumentException(ushort length)
        {
            // Arrange
            uint address = 0x1000;

            // Act & Assert
            await Assert.ThrowsAsync<ArgumentException>(() => 
                _client.MemoryReadAsync(address, length));
        }

        [Fact]
        public async Task MemoryWriteAsync_ValidData_WritesSuccessfully()
        {
            // Arrange
            uint address = 0x1000;
            var data = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()))
                         .ReturnsAsync(CreateSuccessResponse());

            // Act
            await _client.MemoryWriteAsync(address, data);

            // Assert
            _mockTransport.Verify(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()), Times.Once);
        }

        [Fact]
        public async Task MemoryWriteAsync_MaximumData_WritesSuccessfully()
        {
            // Arrange
            uint address = 0x1000;
            var data = new byte[480]; // Maximum allowed length
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)(i % 256);
            }

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()))
                         .ReturnsAsync(CreateSuccessResponse());

            // Act
            await _client.MemoryWriteAsync(address, data);

            // Assert
            _mockTransport.Verify(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()), Times.Once);
        }

        [Fact]
        public async Task MemoryWriteAsync_EmptyData_ThrowsArgumentException()
        {
            // Arrange
            uint address = 0x1000;
            var data = new byte[0];

            // Act & Assert
            await Assert.ThrowsAsync<ArgumentException>(() => 
                _client.MemoryWriteAsync(address, data));
        }

        [Fact]
        public async Task MemoryWriteAsync_TooMuchData_ThrowsArgumentException()
        {
            // Arrange
            uint address = 0x1000;
            var data = new byte[481]; // Exceeds 480 word limit

            // Act & Assert
            await Assert.ThrowsAsync<ArgumentException>(() => 
                _client.MemoryWriteAsync(address, data));
        }

        [Fact]
        public async Task MemoryWriteAsync_NullData_ThrowsArgumentNullException()
        {
            // Arrange
            uint address = 0x1000;
            byte[] data = null;

            // Act & Assert
            await Assert.ThrowsAsync<ArgumentNullException>(() => 
                _client.MemoryWriteAsync(address, data));
        }

        [Theory]
        [InlineData(0)]
        [InlineData(5)]
        [InlineData(20)]
        public async Task MemoryReadAsync_WithTimeout_CompletesWithinTimeout(ushort timeout)
        {
            // Arrange
            uint address = 0x1000;
            ushort length = 10;
            var expectedData = new byte[length];

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), timeout, It.IsAny<CancellationToken>()))
                         .ReturnsAsync(CreateMemoryReadResponse(expectedData));

            // Act
            var result = await _client.MemoryReadAsync(address, length, timeout);

            // Assert
            Assert.Equal(length, result.Length);
            _mockTransport.Verify(t => t.SendReceiveAsync(It.IsAny<byte[]>(), timeout, It.IsAny<CancellationToken>()), Times.Once);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(5)]
        [InlineData(20)]
        public async Task MemoryWriteAsync_WithTimeout_CompletesWithinTimeout(ushort timeout)
        {
            // Arrange
            uint address = 0x1000;
            var data = new byte[] { 0x01, 0x02, 0x03, 0x04 };

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), timeout, It.IsAny<CancellationToken>()))
                         .ReturnsAsync(CreateSuccessResponse());

            // Act
            await _client.MemoryWriteAsync(address, data, timeout);

            // Assert
            _mockTransport.Verify(t => t.SendReceiveAsync(It.IsAny<byte[]>(), timeout, It.IsAny<CancellationToken>()), Times.Once);
        }

        [Fact]
        public async Task MemoryReadAsync_CommunicationError_ThrowsSlmpCommunicationException()
        {
            // Arrange
            uint address = 0x1000;
            ushort length = 10;

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()))
                         .ReturnsAsync(CreateErrorResponse(EndCode.WrongCommand));

            // Act & Assert
            await Assert.ThrowsAsync<SlmpCommunicationException>(() => 
                _client.MemoryReadAsync(address, length));
        }

        [Fact]
        public async Task MemoryWriteAsync_CommunicationError_ThrowsSlmpCommunicationException()
        {
            // Arrange
            uint address = 0x1000;
            var data = new byte[] { 0x01, 0x02, 0x03, 0x04 };

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()))
                         .ReturnsAsync(CreateErrorResponse(EndCode.Busy));

            // Act & Assert
            await Assert.ThrowsAsync<SlmpCommunicationException>(() => 
                _client.MemoryWriteAsync(address, data));
        }

        [Fact]
        public async Task MemoryReadAsync_WithCancellation_PropagatesCancellation()
        {
            // Arrange
            var cts = new CancellationTokenSource();
            cts.Cancel();

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()))
                         .ThrowsAsync(new OperationCanceledException());

            // Act & Assert
            await Assert.ThrowsAsync<OperationCanceledException>(() => 
                _client.MemoryReadAsync(0x1000, 10, 0, cts.Token));
        }

        [Fact]
        public async Task MemoryWriteAsync_WithCancellation_PropagatesCancellation()
        {
            // Arrange
            var cts = new CancellationTokenSource();
            cts.Cancel();
            var data = new byte[] { 0x01, 0x02 };

            _mockTransport.Setup(t => t.SendReceiveAsync(It.IsAny<byte[]>(), It.IsAny<ushort>(), It.IsAny<CancellationToken>()))
                         .ThrowsAsync(new OperationCanceledException());

            // Act & Assert
            await Assert.ThrowsAsync<OperationCanceledException>(() => 
                _client.MemoryWriteAsync(0x1000, data, 0, cts.Token));
        }

        private byte[] CreateSuccessResponse()
        {
            return new byte[] { 0x00, 0x00 }; // Success end code
        }

        private byte[] CreateErrorResponse(EndCode endCode)
        {
            var errorCode = (ushort)endCode;
            return new byte[] { (byte)(errorCode & 0xFF), (byte)(errorCode >> 8) };
        }

        private byte[] CreateMemoryReadResponse(byte[] data)
        {
            var response = new List<byte>();
            
            // Success end code
            response.AddRange(new byte[] { 0x00, 0x00 });
            
            // Memory data
            response.AddRange(data);
            
            return response.ToArray();
        }
    }
}